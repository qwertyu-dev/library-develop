新しい要件が出てきました

まずは理解をお願いします


## 要件
外部テーブルを持たず、パター編集で対処を前提としている業務パターンがあります
業務要件変更があった際には以下の対応が見込まれています

１．編集定義の修正
評価範囲は
編集部品、Facade定義、ディシジョンテーブルが対象になります

２，マスターテーブルの明細修正
既存のテーブル明細に対して新しいルールを適用した結果で更新する必要があります

## 課題
外部テーブルを持つ業務はテーブル変更定義要請と、そのテーブル要請で既存のマスターテーブルを更新する申請が来ます。
一方で外部テーブルを持たずパターン編集で対応するものは、その対処項目が利用者申請により付与されずに
システム内部の判断でデータ編集をしているために、明示的に既存のマスターテーブル値を修正する明細申請がこないというか
申請にその項目がないになっています。

ここでの問題は、ルール改修以外に既存のマスター明細をどのトリガーで修正するかという点にあり
今の所候補がいくつか上がっています

１．マスターテーブル明細更新するパッチを、要件定義に從い作成する
２．マスターテーブルを更新する、更新明細を作成し、DB更新テーブルに追加エントリする



ご指示ありがとうございます。ご要望に基づいて、案を再定義し、評価表を更新いたします。

案1: マスターテーブル明細を更新するパッチを、要件定義に従い作成する
案2: 一括申請のフェーズから自前で申請を書いて投入（パターン編集修正リリースの後）
案3: DB更新テーブルに明細を自前で作って投入

これらの案に基づいて、評価表を作成します。

承知しました。以下にMarkdown形式で表を出力します。

| 評価軸 | 案1: 申請からの投入 | 案2: リクエストテーブルへの明細作成パッチ/投入 | 案3: パッチ作成 |
|--------|---------------------|------------------------------------------------|------------------|
| 制御の精度 | ◎実運用コードでの対応、制御に問題はない | ◎実運用コードでの対応、制御に問題はない | ◎直接改修の制御下可能 |
| 対応までの時間猶予 |局面による、時間余力あればパターン編集への新ルール反映も完了している | ○時間的余力中程度、まずはデータの修正を前提に後からパターン編集定義追いつき | 緊急対応 |
| トレーサビリティ | ○フェーズを介しての確認、各フェーズ結果のチェック必要 | ○フェーズを介しての確認、各フェーズ結果のチェック必要 | 直接的、確認容易 |
| テスト性 | ○フェーズを介しての確認、各フェーズ結果のチェック必要 | ○フェーズを介しての確認、各フェーズ結果のチェック必要 | 直接的、確認容易 |
| 柔軟性 | ○ルール前提、必要なルール下での作業 | ○ルール前提、必要なルール下での作業 | どうとでもなる、ただし誤データ作成とトレードオフ |
| 開発コスト | ○開発部門向けデータ生成シートなど工夫すれば | ○開発部門向けデータ生成シートなど工夫すれば | ○コードを書くスキルは必要、部品の再利用なども視野に入れる必要はある |
| 人的ミスのリスク | 混入するリスクはあるがパターン編集のValidationで検出可能 | パターン編集のValidationで検出可能だが掛けられるかは確認 | △人が気づけない可能性残る + 送信フェーズで検出できる可能性はあるが検出が遅れる |
| 実装時間 | ○レイアウト、整合性など確認しつつマニュアルでデータ作成 + パターン編集定義更新前提 | ○レイアウト、整合性など確認しつつマニュアルでデータ作成 + パターン編集定義更新異存なし | 直接のゴールが見えてのパッチ作成作業,ただし対応明細量が大量だと実装時間急増懸念あり |
| 既存プロセスとの統合 | ○フロー途中からの投入だがフェーズ制御に準拠と考えられる | ○フロー途中からの投入だがフェーズ制御に準拠と考えられる | 独自対応 |
| 運用の簡素さ | リグレからの投入 本番持ち上げの作業が発生 | リグレからの投入 本番持ち上げの作業が発生 | 本番実行のみ |
| ロールバック | △リファレンス2世代前からのリラン、ただし不備のあったリクエスト明細の扱いの決め事が必要 | △リファレンス2世代前からのリラン、ただし不備のあったリクエスト明細の扱いの決め事が必要 | ○2世代前からパッチ再投入 |
| データ整合性 | ◎パターン編集後のValidationチェック利用が可能 | ◎パターン編集後のValidationチェック利用が可能 | △送信フェーズで判明する可能性はあるが検出が遅れる |
| 修正用コード/明細作成の複雑度 | ○人によるデータ作成の工夫課題あり、データ整合性など留意 | ○人によるデータ作成の工夫課題あり、データ整合性など留意 | 直接コードの改修、難易度低いがコードを書ける要員維持が必要 |


この表では、3つの案それぞれの特徴を各評価軸に沿って比較しています。案2と案3は更新明細を作成する方法の違いを反映しており、それぞれ異なる特徴と課題があることがわかります。実際の選択に当たっては、プロジェクトの具体的な要件、リスク許容度、既存システムの制約などを考慮して判断する必要があります。


各案にはそれぞれ長所と短所がありますが、総合的に判断すると、私のおすすめは **案2: 一括申請のフェーズから自前で申請を書いて投入** です。

その理由は以下の通りです：

1. 既存プロセスとの統合性が高い：
   既存の申請プロセスを利用するため、システム全体との整合性が保たれやすく、運用面でも混乱が少ないです。

2. リスク管理がしやすい：
   既存のチェック機構や承認プロセスを利用できるため、人的ミスのリスクが低減されます。

3. トレーサビリティが高い：
   申請履歴として変更の追跡が容易で、監査や問題解決時に有利です。

4. データ整合性の維持：
   既存プロセスのチェックにより、データの整合性が維持されやすいです。

5. 柔軟性とコントロールのバランス：
   パッチ作成ほど複雑ではなく、かつDB直接操作ほどリスキーでもないため、柔軟性とコントロールのバランスが取れています。

6. スケーラビリティ：
   既存プロセスを利用するため、大規模な更新にも対応しやすいです。

ただし、この推奨には以下の前提があります：

- 既存の申請プロセスが十分に整備されており、効率的に機能していること。
- パターン編集の修正がリリースされた後に適用できること。
- 申請作成に必要な知識とリソースが確保できること。

プロジェクトの特性や組織の状況によっては、他の案が適している可能性もあります。例えば：

- 非常に複雑な修正や、既存プロセスでは対応できない特殊なケースがある場合は、案1（パッチ作成）が適しているかもしれません。
- 緊急性が高く、既存プロセスをバイパスする必要がある場合は、案3（DB更新テーブルへの直接投入）を検討する価値があるかもしれません。

最終的な選択は、プロジェクトの具体的な要件、リスク許容度、既存システムの制約、そして組織の運用能力を総合的に考慮して行う必要があります。
